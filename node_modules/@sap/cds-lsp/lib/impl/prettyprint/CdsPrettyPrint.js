"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EditorOptions_1 = require("./EditorOptions");
const CdsFormatOptions_1 = require("./formatOptions/CdsFormatOptions");
const MetaModel_1 = require("./formatOptions/MetaModel");
const PpFormatter_1 = require("./PpFormatter");
const PpParser_1 = require("./PpParser");
const Logger_1 = require("./util/Logger");
const StringUtil_1 = require("./util/StringUtil");
function tokenContext(tokens, index) {
    const start = Math.max(0, index - 10);
    const end = Math.min(tokens.length, index + 10);
    let result = '';
    for (let i = start; i < end; i++) {
        if (i === index) {
            result += `>>${tokens[i]}<<`;
        }
        else {
            result += tokens[i];
        }
        result += ' ';
    }
    return result;
}
exports.tokenContext = tokenContext;
function canonicalText(token) {
    if (token.isComment()) {
        return token.text.split(/[\s]+/).filter(word => word.length > 0).join(' ');
    }
    if (token.isKeyword()) {
        return token.text.toLowerCase();
    }
    return token.text;
}
function verifyTokens(originalTokens, formattedTokens) {
    const minTokens = Math.min(originalTokens.length, formattedTokens.length);
    for (let i = 0; i < minTokens; i++) {
        const canonOrg = canonicalText(originalTokens[i]);
        const canonForm = canonicalText(formattedTokens[i]);
        if (canonOrg !== canonForm) {
            throw new Error('Tokens differ at token index ' + i + '.\nOriginal: ' + tokenContext(originalTokens, i) + '\nFormatted: ' + tokenContext(formattedTokens, i));
        }
    }
    if (formattedTokens.length !== originalTokens.length) {
        throw new Error('Number of tokens has changed! Original ' + originalTokens.length + ', formatted ' + formattedTokens.length);
    }
}
exports.verifyTokens = verifyTokens;
class CdsPrettyPrint {
    constructor(logger = new Logger_1.Logger(), formatOptionsMetaModel = new MetaModel_1.MetaModel(Object.freeze(new CdsFormatOptions_1.CdsFormatOptions()), logger)) {
        this.logger = logger;
        this.formatOptionsMetaModel = formatOptionsMetaModel;
    }
    getCommandLineOptions() {
        const options = this.formatOptionsMetaModel.emptySet('CmdlineOptions');
        let currentOptionsName;
        const setOpt = (val) => {
            options.setOption(currentOptionsName, PpParser_1.convertSourceConfigValueToNativeType(val));
            currentOptionsName = undefined;
        };
        process.argv.forEach(a => {
            const matched = a.match(/^-+([-\w]+)([:=](["'\w]+))?/);
            if (matched && matched.length > 1) {
                currentOptionsName = StringUtil_1.toCamelCase(matched[1]);
                if (matched[3] !== undefined) {
                    setOpt(matched[3]);
                }
            }
            else if (currentOptionsName) {
                setOpt(a);
            }
        });
        return options;
    }
    getDefaultOptions() {
        return this.formatOptionsMetaModel.defaultSet();
    }
    getEffectiveFormattingOptions(userOptions, sourcePath, workspaceRoot) {
        var _a;
        const formattingOptions = this.getDefaultOptions();
        formattingOptions.overlayWith(EditorOptions_1.mapLspOptions(this.formatOptionsMetaModel, userOptions, this.logger));
        formattingOptions.overlayWith((_a = EditorOptions_1.fileOptions(this.formatOptionsMetaModel, sourcePath, workspaceRoot, this.logger)) === null || _a === void 0 ? void 0 : _a.formattingOptions);
        formattingOptions.overlayWith(this.getCommandLineOptions());
        return formattingOptions;
    }
    async beautify(sOriginalSource, lspFormattingOptions, sourcePath, workspaceRoot) {
        const logger = this.logger;
        logger.logInfo(`Beautifying ${sourcePath}  

,d88b.d88b,
88888888888
\`Y8888888Y'
  \`Y888Y'  
    \`Y'
`);
        const parser = new PpParser_1.PpParser(this.logger);
        try {
            const topNode = await parser.fetchRuleTree(sOriginalSource);
            logger.logInfo(() => 'Assembling formatting options');
            const formattingOptions = this.getEffectiveFormattingOptions(lspFormattingOptions, sourcePath, workspaceRoot);
            topNode.getTokenList().forEach(token => {
                this.adjustTokenCasing(token, formattingOptions.getOption('cqlKeywordCapitalization'));
            });
            const { formatted: formattedSource, exclusionRanges } = new PpFormatter_1.PpFormatter().format(topNode, formattingOptions, sOriginalSource);
            const originalTokens = topNode.getTokenList();
            const formattedTokens = await parser.tokenize(formattedSource);
            verifyTokens(originalTokens, formattedTokens);
            return {
                originalContent: sOriginalSource,
                formattedContent: formattedSource,
                originalTokens,
                formattedTokens,
                exclusionRanges
            };
        }
        catch (e) {
            logger.logWarn(() => 'Beautify impossible:');
            logger.logWarn(() => e.stack || e);
            throw e;
        }
    }
    adjustTokenCasing(tok, cqlCasing) {
        const getTargetCasing = () => {
            if (!tok.isKeyword()) {
                return MetaModel_1.KeywordCasing['as-is'];
            }
            switch (tok.text.toLowerCase()) {
                case 'association':
                case 'composition':
                    return MetaModel_1.KeywordCasing.title;
            }
            if (tok.isCqlKeyword()) {
                return cqlCasing || MetaModel_1.KeywordCasing['as-is'];
            }
            return MetaModel_1.KeywordCasing.lower;
        };
        const caseLexem = () => {
            switch (getTargetCasing()) {
                case MetaModel_1.KeywordCasing.lower: return tok.text.toLowerCase();
                case MetaModel_1.KeywordCasing.upper: return tok.text.toUpperCase();
                case MetaModel_1.KeywordCasing.title: return toTitleCase(tok.text);
                default:
                    return tok.text;
            }
        };
        tok.text = caseLexem();
    }
}
exports.CdsPrettyPrint = CdsPrettyPrint;
function toTitleCase(str) {
    return str.toLowerCase().replace(/(?:^|\s)\w/g, match => match.toUpperCase());
}
//# sourceMappingURL=CdsPrettyPrint.js.map