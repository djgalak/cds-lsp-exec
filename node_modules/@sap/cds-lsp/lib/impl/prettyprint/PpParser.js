"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const containedCompiler = require("@sap/cds-compiler");
const PpBaseTypes_1 = require("./PpBaseTypes");
const PpRuleNode_1 = require("./PpRuleNode");
const PpRuleToken_1 = require("./PpRuleToken");
const Logger_1 = require("./util/Logger");
const TreeUtil_1 = require("./util/TreeUtil");
class PpParser {
    constructor(logger = new Logger_1.Logger()) {
        this.logger = logger;
    }
    async fetchRuleTree(sOriginalSource) {
        const parserContext = new PpBaseTypes_1.PpParserContext();
        parserContext.logger = this.logger;
        const { logger } = parserContext;
        const topNode = await this.parse(sOriginalSource, parserContext);
        logger.trace('====== Grammar Tree =====');
        logger.trace(topNode.debugPrint(0, new Logger_1.AnsiColorProvider()));
        topNode.reduceTree();
        logger.trace('====== Fixed Reduced Tree =====');
        logger.trace(topNode.debugPrint(0, new Logger_1.AnsiColorProvider()));
        return topNode;
    }
    getDefaultOptions() {
        return {
            fallbackParser: 'cds',
            parseOnly: true,
            lintMode: true,
            attachTokens: true
        };
    }
    async tokenize(content) {
        const x = await containedCompiler.parse(content, 'a.cds', this.getDefaultOptions());
        let ppTokens = x.tokenStream.tokens.map(t => new PpRuleToken_1.PpToken(t).finalizeCategory());
        if (ppTokens.length && ppTokens[ppTokens.length - 1].text === '<EOF>') {
            ppTokens = ppTokens.slice(0, -1);
        }
        return ppTokens;
    }
    async parse(content, context = new PpBaseTypes_1.PpParserContext()) {
        const ruleStack = [];
        const ruleContextToRuleNode = new Map();
        let rootRuleNode;
        let currentRuleNode;
        let currentTokenIndex = -1;
        const onRuleToken = (ruleToken) => {
            const parentRuleNode = ruleToken.parent;
            const isStartRule = !parentRuleNode.parent;
            if (isStartRule && ruleToken.isComment()) {
                const index = parentRuleNode.children.findIndex(c => c instanceof PpRuleNode_1.PpRuleNode && !c.getFirstToken(TreeUtil_1.any));
                if (index >= 0) {
                    parentRuleNode.children.splice(index, 0, ruleToken);
                }
                else {
                    parentRuleNode.addChild(ruleToken);
                }
            }
            else {
                parentRuleNode.addChild(ruleToken);
            }
            context.allTokens.push(ruleToken);
            currentTokenIndex = ruleToken.tokenIndex;
        };
        const onCommentToken = (commentToken, tokenAfterComment) => {
            const determineRuleNode = (token) => {
                for (let i = ruleStack.length - 1; i >= 0; i--) {
                    const ruleContext = ruleStack[i];
                    const isStartRule = i === 0;
                    if (isStartRule || ruleContext.start.tokenIndex <= token.tokenIndex) {
                        return ruleContextToRuleNode.get(ruleContext);
                    }
                }
                throw new Error(`Failed to determine rule context for comment token#${token.tokenIndex} '${token.text}'`);
            };
            let parentRuleNode = determineRuleNode(commentToken);
            const previousToken = context.getPreviousToken(commentToken, TreeUtil_1.any);
            const isLineEndComment = previousToken && previousToken.endLine === commentToken.line - 1;
            if (isLineEndComment) {
                parentRuleNode = previousToken.parent;
            }
            else {
                let isIntroToken = true;
                const tokensToCheckIfConsecutive = context.rawTokens.slice(commentToken.tokenIndex, tokenAfterComment.tokenIndex + 1);
                for (let i = 1; i < tokensToCheckIfConsecutive.length; i++) {
                    const aToken = tokensToCheckIfConsecutive[i - 1];
                    const nextToken = tokensToCheckIfConsecutive[i];
                    const emptyLinesInBetween = (nextToken.line - 1) - PpRuleToken_1.endLine(aToken) > 1;
                    if (emptyLinesInBetween) {
                        isIntroToken = false;
                        break;
                    }
                }
                if (isIntroToken) {
                    parentRuleNode = tokenAfterComment.parent;
                }
            }
            const ppToken = new PpRuleToken_1.PpRuleToken(context, parentRuleNode, commentToken);
            if (isLineEndComment) {
                previousToken.followUpLineEndCommentToken = ppToken;
            }
            onRuleToken(ppToken);
        };
        const handleSkippedComments = (ruleToken) => {
            const tokenIndex = ruleToken.tokenIndex;
            if (tokenIndex > currentTokenIndex + 1) {
                const parser = rootRuleNode.ruleContext.parser;
                const tokenStream = parser.getInputStream();
                const rawTokens = tokenStream.tokens;
                for (let i = currentTokenIndex + 1; i < tokenIndex; i++) {
                    const missedToken = rawTokens[i];
                    onCommentToken(missedToken, ruleToken);
                }
            }
        };
        const onToken = (token, isError = false) => {
            const ppToken = new PpRuleToken_1.PpRuleToken(context, currentRuleNode, token, isError);
            handleSkippedComments(ppToken);
            if (token.text === '<EOF>') {
                return;
            }
            onRuleToken(ppToken);
        };
        const parseListener = {
            visitTerminal(terminalNode) {
                onToken(terminalNode.symbol);
            },
            visitErrorNode(errorNode) {
                onToken(errorNode.symbol, true);
            },
            enterEveryRule(ruleContext) {
                const newRuleNode = new PpRuleNode_1.PpRuleNode(context, ruleContext, currentRuleNode);
                ruleContextToRuleNode.set(ruleContext, newRuleNode);
                if (!rootRuleNode) {
                    rootRuleNode = newRuleNode;
                    const parser = rootRuleNode.ruleContext.parser;
                    const tokenStream = parser.getInputStream();
                    context.rawTokens = tokenStream.tokens;
                }
                if (currentRuleNode) {
                    currentRuleNode.addChild(newRuleNode);
                }
                currentRuleNode = newRuleNode;
                ruleStack.push(ruleContext);
            },
            exitEveryRule(ruleContext) {
                ruleStack.length = ruleStack.indexOf(ruleContext);
                currentRuleNode = currentRuleNode.parent;
            }
        };
        const parseOptions = this.getDefaultOptions();
        parseOptions.parseListener = parseListener;
        await containedCompiler.parse(content, 'a.cds', parseOptions);
        context.allTokens.forEach(t => t.finalizeCategory());
        return rootRuleNode;
    }
}
exports.PpParser = PpParser;
function convertSourceConfigValueToNativeType(sConfigValue) {
    const lower = destringify(sConfigValue.toLowerCase());
    switch (lower) {
        case 'off':
        case 'no':
        case 'false':
            return false;
        case 'on':
        case 'yes':
        case 'true':
            return true;
    }
    const n = parseInt(lower, 10);
    if (!n && n !== 0) {
        return destringify(sConfigValue);
    }
    return n;
}
exports.convertSourceConfigValueToNativeType = convertSourceConfigValueToNativeType;
function destringify(stringWithinOptionalQuotes) {
    function checkQuotes(quoteChar) {
        if (stringWithinOptionalQuotes.indexOf(quoteChar) === 0) {
            if (stringWithinOptionalQuotes.lastIndexOf(quoteChar) === stringWithinOptionalQuotes.length - 1) {
                return stringWithinOptionalQuotes.slice(1, -1);
            }
            else {
                return stringWithinOptionalQuotes;
            }
        }
        return stringWithinOptionalQuotes;
    }
    const s = checkQuotes('"');
    if (s === stringWithinOptionalQuotes) {
        return checkQuotes("'");
    }
    return s;
}
//# sourceMappingURL=PpParser.js.map