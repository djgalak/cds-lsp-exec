"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Alignment_1 = require("./Alignment");
const BlockAlignment_1 = require("./BlockAlignment");
const BlockAlignmentManager_1 = require("./BlockAlignmentManager");
const FacsimileAlignment_1 = require("./FacsimileAlignment");
const FormattingBasics_1 = require("./formatters/FormattingBasics");
const FormattingInstructions_1 = require("./FormattingInstructions");
const FormattingProcessor_1 = require("./FormattingProcessor");
const PpRuleNode_1 = require("./PpRuleNode");
const PpRuleToken_1 = require("./PpRuleToken");
const RenderOptions_1 = require("./RenderOptions");
const AnnotationUtil_1 = require("./util/AnnotationUtil");
const StringUtil_1 = require("./util/StringUtil");
const TreeUtil_1 = require("./util/TreeUtil");
class RenderingFinished {
    constructor() {
        this.child = {};
    }
}
class GenericRuleRenderer {
    constructor(blockRenderOptions, globalContext) {
        this.blockRenderOptions = blockRenderOptions;
        this.globalContext = globalContext;
        this.blockAlignmentManager = new BlockAlignmentManager_1.BlockAlignmentManager(globalContext);
        this._formattingProcessor = new FormattingProcessor_1.FormattingProcessor(globalContext, this.blockAlignmentManager);
    }
    processInstructions(things, formattedObject, trigger, ignoreCache) {
        things.forEach(thing => {
            if (thing instanceof Alignment_1.Alignment) {
                this._formattingProcessor.logFormattingInstructions(thing instanceof BlockAlignment_1.BlockAlignment ? '[BA]' : '[A]', formattedObject, trigger, thing.id);
                return this.appendAlignments([thing]);
            }
            return this.processFormatting(thing, formattedObject, trigger, ignoreCache);
        });
    }
    appendAlignments(alignments) {
        alignments.forEach((alignment) => {
            if (alignment instanceof BlockAlignment_1.BlockAlignment) {
                this.blockAlignmentManager.appendBlockAlignment(alignment);
            }
            else {
                this.appendToStream(alignment);
            }
        });
    }
    processFormatting(sFormat, formattedObject, trigger, ignoreCache = false) {
        this._formattingProcessor.processFormatting(sFormat, formattedObject, trigger, ignoreCache);
    }
    appendToStream(thing) {
        if (thing instanceof PpRuleToken_1.PpRuleToken) {
            if (this.globalContext.formatOptions.getOption('keepOriginalEmptyLines', thing.tokenIndex)) {
                const newlinesBefore = this.globalContext.lastProcessedToken
                    ? Math.min(thing.line - this.globalContext.lastProcessedToken.endLine, this.globalContext.formatOptions.getOption('maxKeepEmptyLines', thing.tokenIndex) + 1)
                    : 0;
                if (newlinesBefore > 1) {
                    this.processFormatting('\n'.repeat(newlinesBefore), thing, 'before', true);
                }
            }
            this.globalContext.lastProcessedToken = thing;
        }
        this.globalContext.formattingStream.append(thing);
    }
    ejectToken(tok, ignoreCache = false) {
        const lowerLexIfKeywordOrOperator = FormattingBasics_1.lowerLexem(tok);
        const isOpeningBracket = (token) => !!token && ['{', '[', '('].includes(token.text);
        const isClosingBracket = (token) => !!token && ['}', ']', ')'].includes(token.text);
        const bracketType = (token) => ['{', '}'].includes(token.text) ? 'curly' : ['[', ']'].includes(token.text) ? 'square' : ['(', ')'].includes(token.text) ? 'round' : 'none';
        let previousToken;
        let nextToken;
        const before = this.globalContext.formatOptions.getOption('keepEmptyBracketsTogether', tok.tokenIndex) &&
            isClosingBracket(tok) && isOpeningBracket((previousToken = tok.getPreviousToken(TreeUtil_1.any))) &&
            bracketType(tok) === bracketType(previousToken)
            ? FormattingBasics_1.WhitespaceAtLeastZero
            : RenderOptions_1.getFormattingInstructions('before', this.globalContext.formatOptions, tok.tokenIndex, tok.parent)[lowerLexIfKeywordOrOperator];
        const stream = this.globalContext.formattingStream.stream;
        const blankBefore = before === undefined && !(stream[stream.length - 1] instanceof Alignment_1.Alignment);
        this.processFormatting(blankBefore ? FormattingBasics_1.WhitespaceOptionalSimple : before, tok, 'before', true);
        if (!ignoreCache) {
            this.prependDelayedThingsOnToken(tok);
        }
        this.appendToStream(tok);
        const followUpComment = tok.getFollowUpLineEndComment();
        const after = this.globalContext.formatOptions.getOption('keepEmptyBracketsTogether', tok.tokenIndex) &&
            isOpeningBracket(tok) && isClosingBracket((nextToken = tok.getNextToken(TreeUtil_1.any))) &&
            bracketType(tok) === bracketType(nextToken)
            ? FormattingBasics_1.WhitespaceAtLeastZero
            : RenderOptions_1.getFormattingInstructions('after', this.globalContext.formatOptions, tok.tokenIndex, tok.parent)[lowerLexIfKeywordOrOperator];
        if (after === undefined) {
            this.processFormatting(FormattingBasics_1.WhitespaceOptionalSimple, tok, 'after', true);
        }
        else {
            if (followUpComment) {
                const firstLineBreak = after.indexOf('\n');
                if (firstLineBreak >= 0) {
                    this.processFormatting(after.slice(0, firstLineBreak), tok, 'after', true);
                    this.onToken(followUpComment, true);
                    this.processFormatting(after.slice(firstLineBreak), tok, 'after', true);
                }
                else {
                    this.processInstructions([after, FormattingBasics_1.WhitespaceOptionalSimple], tok, 'after', true);
                }
            }
            else {
                this.processFormatting(after, tok, 'after', true);
            }
        }
    }
    prependDelayedThingsOnToken(triggeringToken) {
        var _a, _b;
        if (this.globalContext.thingsDelayedTillToken.length === 0) {
            return;
        }
        const originalAlignment = this.blockAlignmentManager.lastAlignment();
        let prependAlignment = (_b = (_a = triggeringToken === null || triggeringToken === void 0 ? void 0 : triggeringToken.parent) === null || _a === void 0 ? void 0 : _a.getFormatter(this.globalContext)) === null || _b === void 0 ? void 0 : _b.getAnnotationAlignment(triggeringToken);
        if (!prependAlignment && !(originalAlignment instanceof BlockAlignment_1.BlockAlignment)) {
            prependAlignment = new BlockAlignment_1.BlockAlignment(this.globalContext, '_eq:' + (originalAlignment ? originalAlignment.id : '?'));
            prependAlignment.setRelativeAlignment(originalAlignment, 0);
        }
        if (prependAlignment) {
            this.processInstructions([prependAlignment], triggeringToken, 'before', true);
        }
        this.globalContext.thingsDelayedTillToken.forEach(delayed => {
            if (delayed instanceof PpRuleToken_1.PpRuleToken) {
                this.onToken(delayed, true);
            }
            else if (delayed instanceof PpRuleNode_1.PpRuleNode) {
                this.onBlock(delayed, true);
            }
            else {
                this.processInstructions([delayed.instructionOrAlignment], delayed.formattedObject, delayed.trigger, true);
            }
        });
        this.globalContext.thingsDelayedTillToken = [];
        if (prependAlignment) {
            if (prependAlignment instanceof BlockAlignment_1.BlockAlignment) {
                this.blockAlignmentManager.popBlockAlignment(prependAlignment.id);
            }
            this.processInstructions([originalAlignment], triggeringToken, 'before', true);
        }
        this.processFormatting(FormattingBasics_1.WhitespaceOptionalSimple, triggeringToken, 'before', true);
    }
    onCommentToken(token) {
        function processLocalFormatOption(context) {
            const match = token.text.match(/@formatter\s+([^:\s]+)\s*:\s*(([\S]*)(?=\*\/)|([\S]*))/);
            if (!match) {
                return false;
            }
            const option = match[1];
            const valueString = match[2];
            switch (valueString) {
                case undefined:
                    context.logger.logError(`invalid formatter setting: value missing: ${token.text}`);
                    return false;
                case 'reset':
                    context.formatOptions.resetLocally(option, token.tokenIndex);
                    break;
                default:
                    context.formatOptions.setLocallyFromString(option, valueString, token.tokenIndex);
            }
            return true;
        }
        function checkLocalFormatterEnablement(context) {
            const match = token.text.match(/@formatter\s*:\s*(on|off)?/);
            if (!match) {
                return;
            }
            const state = match[1];
            if (!state) {
                context.logger.logError(`invalid formatter enablement: ${token.text}`);
                return;
            }
            context.formattingEnablements.push({ token, enabled: state === 'on' });
        }
        const previousToken = token.getPreviousToken(TreeUtil_1.any);
        const nextToken = token.getNextToken(TreeUtil_1.any);
        const emptyLinesBefore = previousToken ? Math.max(0, token.line - previousToken.endLine - 1) : undefined;
        const emptyLinesAfter = nextToken ? Math.max(0, nextToken.line - token.endLine - 1) : undefined;
        if (token.isComment() && !processLocalFormatOption(this.globalContext)) {
            checkLocalFormatterEnablement(this.globalContext);
        }
        if (token.ejected) {
            return;
        }
        try {
            if (emptyLinesBefore) {
                const n = 1 + Math.min(emptyLinesBefore, this.globalContext.formatOptions.getOption('maxKeepEmptyLines', token.tokenIndex));
                this.processFormatting('\n'.repeat(n), token, 'before', true);
            }
            this.processFormatting(token.isFollowUpComment()
                ? FormattingBasics_1.WhitespaceAtLeast1
                : FormattingBasics_1.NewLine, token, 'before', true);
            const isInlineComment = token.isInlineComment();
            if (token.isBlockComment() && !isInlineComment) {
                this.renderTokensAsIs([token]);
            }
            else {
                this.appendToStream(token);
            }
            if (isInlineComment) {
                if (!(nextToken && nextToken.isOperator())) {
                    this.processFormatting(FormattingBasics_1.WhitespaceAtLeast1, token, 'after', true);
                }
                return;
            }
            this.processFormatting('\n', token, 'after', true);
        }
        finally {
            token.ejected = true;
            if (emptyLinesAfter) {
                const n = 1 + Math.min(emptyLinesAfter, this.globalContext.formatOptions.getOption('maxKeepEmptyLines', token.tokenIndex));
                this.processFormatting('\n'.repeat(n), token, 'after', true);
            }
        }
    }
    renderTokensAsIs(tokens) {
        const calculateEffectiveStartColumn = (s, tabWidth) => {
            let startColumn = 0;
            for (const ch of s) {
                startColumn += ch === '\t' ? tabWidth - (startColumn % tabWidth) : 1;
            }
            return startColumn;
        };
        const lineTokens = tokens.reduce((expanded, token) => {
            token = Object.create(token);
            token.text = token.text;
            const sLine = this.globalContext.originalSourceLines[token.line];
            const tabWidth = this.globalContext.formatOptions.getOption('tabSize', token.tokenIndex);
            token.column = calculateEffectiveStartColumn(sLine.slice(0, token.column), tabWidth);
            if (token.isComment()) {
                const split = StringUtil_1.splitLines(token.text);
                let start = token.start;
                for (let i = 0; i < split.lineCount; i++) {
                    const line = split.leftTrimmedLines[i];
                    const clone = new PpRuleToken_1.PpCommentToken(token);
                    clone.line = token.line + i;
                    clone.column = i === 0 ? token.column : split.firstCharacterOffsets[i];
                    clone.text = line;
                    clone.start = start;
                    expanded.push(clone);
                    start += split.lines[i].length + split.lineBreaks[i].length;
                }
            }
            else {
                expanded.push(token);
            }
            return expanded;
        }, []);
        let firstLine;
        let firstColumn;
        let facsimileAlignment;
        let align = () => { };
        for (let i = 0; i < lineTokens.length; i++) {
            const token = lineTokens[i];
            const previousToken = lineTokens[i - 1];
            if (i === 0) {
                firstLine = token.line;
                firstColumn = token.column;
                const isVeryFirstToken = token.tokenIndex === 0;
                facsimileAlignment = new FacsimileAlignment_1.FacsimileAlignment(this.globalContext, firstColumn);
                const alignments = [facsimileAlignment];
                const lastBlockAlignment = this.globalContext.lastBlockAlignment();
                if (lastBlockAlignment) {
                    alignments.unshift(lastBlockAlignment);
                }
                align = () => {
                    alignments.forEach((alignment) => {
                        this.processInstructions([alignment], token, 'before', true);
                    });
                };
                align();
                if (isVeryFirstToken) {
                    if (firstColumn > 0) {
                        this.appendToStream(FormattingInstructions_1.blanks(firstColumn));
                    }
                    firstColumn = 0;
                }
            }
            if (previousToken) {
                const lineDelta = token.line - previousToken.endLine;
                let indent = null;
                if (lineDelta > 0) {
                    facsimileAlignment.setIndentation(token.line - firstLine, token.column);
                    this.appendToStream(new FormattingInstructions_1.LineBreak().atLeast(lineDelta - 1));
                    align();
                }
                else {
                    indent = FormattingInstructions_1.blanks(token.column - (previousToken.column + previousToken.text.length));
                    this.appendToStream(indent);
                }
            }
            this.appendToStream(token);
        }
    }
    formatAroundChild(node, child, trigger, formatter, finished, ignoreCache) {
        const children = node.children;
        const instructions = trigger === 'before'
            ? formatter.beforeChild(node, child, children) || null
            : formatter.afterChild(node, child, children) || null;
        if (instructions.length) {
            if (AnnotationUtil_1.isAnnotation(child) && !ignoreCache) {
                instructions.forEach(instruction => this.globalContext.thingsDelayedTillToken.push({ trigger, formattedObject: child, instructionOrAlignment: instruction }));
            }
            else {
                this.processInstructions(instructions, child, trigger, ignoreCache);
            }
            finished.child[trigger] = instructions.includes('°');
        }
    }
    renderNode(node, ignoreCache = false) {
        const finished = new RenderingFinished();
        const formatter = node.getFormatter(this.globalContext);
        if (formatter) {
            const instructions = formatter.beforeNode(node);
            this.processInstructions(instructions, node, 'before', ignoreCache);
            finished.node = instructions.includes('°');
        }
        for (const child of node.children) {
            const formatterRelevant = formatter &&
                !finished.node &&
                !(formatter.onlyTokenChildren && child instanceof PpRuleNode_1.PpRuleNode) &&
                !(formatter.ignoreComments && (child instanceof PpRuleToken_1.PpRuleToken && child.isComment())) &&
                !(formatter.ignoreAnnotations && AnnotationUtil_1.isAnnotation(child));
            if (formatterRelevant && !finished.child.before) {
                this.formatAroundChild(node, child, 'before', formatter, finished, ignoreCache);
            }
            if (child instanceof PpRuleToken_1.PpRuleToken) {
                this.onToken(child, ignoreCache);
            }
            else {
                this.onBlock(child, ignoreCache);
            }
            if (formatterRelevant && !finished.child.after) {
                this.formatAroundChild(node, child, 'after', formatter, finished, ignoreCache);
            }
        }
        if (!ignoreCache) {
            this.prependDelayedThingsOnToken(undefined);
        }
        if (formatter) {
            if (!finished.node) {
                this.processInstructions(formatter.afterNode(node), node, 'after', ignoreCache);
            }
            formatter.destroy();
        }
        let cursor = node.parent;
        while (cursor) {
            cursor.streamIndexFrom = cursor.streamIndexFrom === -1 || node.streamIndexFrom === -1
                ? node.streamIndexFrom === -1
                    ? cursor.streamIndexFrom
                    : node.streamIndexFrom
                : Math.min(cursor.streamIndexFrom, node.streamIndexFrom);
            cursor.streamIndexTo = Math.max(cursor.streamIndexTo, node.streamIndexTo);
            cursor = cursor.parent;
        }
    }
    onToken(token, ignoreCache = false) {
        if (token.isComment()) {
            if (ignoreCache || (token.isFollowUpComment() && token.isSingleLined()) && this.globalContext.thingsDelayedTillToken.length === 0) {
                this.onCommentToken(token);
            }
            else if (!token.ejected) {
                this.globalContext.thingsDelayedTillToken.push(token);
            }
        }
        else {
            this.ejectToken(token, ignoreCache);
        }
    }
    onBlock(node, ignoreCache = false) {
        const annoType = AnnotationUtil_1.getAndRememberAnnotationType(node, this.globalContext);
        this.globalContext.annotationTypes[node.id] = annoType;
        if (annoType === 'pre' && !ignoreCache) {
            this.globalContext.thingsDelayedTillToken.push(node);
        }
        else {
            node.format(this.globalContext, ignoreCache);
        }
    }
    beginBlock(blockTreeNode, ignoreCache = false) {
        function findPrecedingLineBreak(stream) {
            let item;
            let index;
            for (index = stream.length - 1; index >= 0; index--) {
                item = stream[index];
                if (item instanceof FormattingInstructions_1.LineBreak || !(item instanceof Alignment_1.Alignment)) {
                    break;
                }
            }
            if (!(item instanceof FormattingInstructions_1.LineBreak)) {
                return undefined;
            }
            const lineBreak = item.clone();
            return new LineBreakAtIndex(lineBreak, index);
        }
        let beforeFormatting = this.blockRenderOptions.beforeBlock;
        let retVal;
        const previousSibling = TreeUtil_1.getPreviousSibling(blockTreeNode, TreeUtil_1.any);
        let trigger = 'before';
        if (previousSibling && previousSibling instanceof PpRuleNode_1.PpRuleNode) {
            const newBlockGroup = previousSibling.ruleName !== blockTreeNode.ruleName;
            if (newBlockGroup) {
                beforeFormatting = this.blockRenderOptions.beforeBlockGroup;
            }
            else {
                trigger = 'between';
                const potentiallyRevert = this.isSingleLined(previousSibling) && this.globalContext.formatOptions.getOption('keepSingleLinedBlocksTogether', blockTreeNode.getStartTokenIndex());
                let originalLineBreak;
                if (potentiallyRevert) {
                    originalLineBreak = findPrecedingLineBreak(this.globalContext.formattingStream.stream);
                }
                beforeFormatting = this.blockRenderOptions.betweenBlocks;
                retVal = originalLineBreak;
            }
        }
        this.processFormatting(beforeFormatting, blockTreeNode, trigger, ignoreCache);
        return retVal;
    }
    endBlock(blockTreeNode, originalLineBreak, ignoreCache = false) {
        if (originalLineBreak && this.isSingleLined(blockTreeNode)) {
            this.globalContext.logger.logDebug('Reverting newline after ' + blockTreeNode.id);
            this.globalContext.formattingStream.stream.splice(originalLineBreak.index, 1, originalLineBreak.lineBreak);
        }
        let afterFormatting = this.blockRenderOptions.afterBlock;
        const nextSibling = TreeUtil_1.getNextSibling(blockTreeNode, TreeUtil_1.any);
        if (nextSibling && nextSibling instanceof PpRuleNode_1.PpRuleNode) {
            const newBlockGroup = nextSibling.ruleName !== blockTreeNode.ruleName;
            if (newBlockGroup) {
                afterFormatting = this.blockRenderOptions.afterBlockGroup;
            }
        }
        this.processFormatting(afterFormatting, blockTreeNode, 'after', ignoreCache);
    }
    isSingleLined(block) {
        return this.globalContext.formattingStream.stream
            .slice(block.streamIndexFrom, block.streamIndexTo + 1)
            .find((child, i, array) => {
            if (child instanceof FormattingInstructions_1.LineBreak) {
                const predecessor = array[i - 1];
                return !(predecessor instanceof PpRuleToken_1.PpRuleToken && predecessor.isComment());
            }
            return false;
        }) === undefined;
    }
    static replaceNewlineWithWhitespace(streamIndex, globalContext) {
        if (!globalContext.removableNewlines.has(streamIndex)) {
            return;
        }
        globalContext.removableNewlines.delete(streamIndex);
        const stream = globalContext.formattingStream.stream;
        const previousItem = stream[streamIndex - 1];
        const whitespace = new FormattingInstructions_1.Whitespace().optionalSimple();
        if (previousItem instanceof FormattingInstructions_1.Whitespace) {
            previousItem.merge(whitespace);
            stream.splice(streamIndex, 1, new FormattingInstructions_1.Whitespace());
        }
        else {
            stream.splice(streamIndex, 1, whitespace);
        }
    }
}
exports.GenericRuleRenderer = GenericRuleRenderer;
class LineBreakAtIndex {
    constructor(lineBreak, index) {
        this.lineBreak = lineBreak;
        this.index = index;
    }
}
//# sourceMappingURL=GenericRuleRenderer.js.map