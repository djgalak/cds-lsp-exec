"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Alignment_1 = require("./Alignment");
const BlockAlignment_1 = require("./BlockAlignment");
const CustomAlignment_1 = require("./CustomAlignment");
const FacsimileAlignment_1 = require("./FacsimileAlignment");
const OptionRanges_1 = require("./formatOptions/OptionRanges");
const FormattingInstructions_1 = require("./FormattingInstructions");
const PpRuleToken_1 = require("./PpRuleToken");
const Ansi_1 = require("./util/Ansi");
function isHardenedLine(x) {
    return x.completedLine !== undefined;
}
const PRE_FORMAT = '#';
function hardenLine(context, logger, aLine, alignmentIdToHarden, onObscuredAlignmentFound) {
    var _a;
    const onlyWhitespace = /^\s*$/;
    let line = '';
    const aPreFormatted = [];
    let item;
    let precedingText = '';
    let precedingToken;
    for (let i = 0; i < aLine.length; i++) {
        item = aLine[i];
        if (item instanceof FacsimileAlignment_1.FacsimileAlignment) {
            if (alignmentIdToHarden === PRE_FORMAT) {
                item.registerFirstHardenedLine(aLine.lineNumber);
            }
            else {
                item.registerFirstHardenedColumn(aLine.lineNumber, line.length);
            }
        }
        if (item instanceof Alignment_1.Alignment) {
            if (alignmentIdToHarden === item.id) {
                item.alignmentDone = true;
                const column = item.getColumn(aLine.lineNumber);
                trace(logger, Ansi_1.Ansi.RULE, `Aligned at ${aLine.lineNumber}:${column}: ${item.id} --${aLine}`);
                const delta = column - line.length;
                if (delta < 0 && onlyWhitespace.test(line.slice(column))) {
                    line = line.slice(0, column);
                }
                else {
                    line += FormattingInstructions_1.blanks(delta);
                }
                continue;
            }
            else {
                item.setColumn(line.length);
                if (item instanceof BlockAlignment_1.BlockAlignment && item.relativeAlignment && !item.relativeAlignment.alignmentDone) {
                    if (onObscuredAlignmentFound) {
                        onObscuredAlignmentFound(item, item.relativeAlignment);
                    }
                }
                aPreFormatted.push(line);
                aPreFormatted.push(item);
                while (++i < aLine.length) {
                    const laterItem = aLine[i];
                    if (laterItem instanceof Alignment_1.Alignment) {
                        if (item === laterItem) {
                            logger.logWarn(() => `Hardening: Same alignment twice in line ${aLine.lineNumber}, ignoring last: ${laterItem.id}`);
                            aLine[i] = new CustomAlignment_1.CustomAlignment(context, 'duplicate disabled: ' + item.id + ' ' + new Date());
                            continue;
                        }
                        else if (onObscuredAlignmentFound) {
                            onObscuredAlignmentFound(laterItem, item);
                        }
                    }
                    if (laterItem) {
                        aPreFormatted.push(laterItem);
                    }
                }
                return {
                    nextOutstandingAlignment: item,
                    outstandingLineItems: aPreFormatted
                };
            }
        }
        if (item instanceof PpRuleToken_1.PpRuleToken) {
            line += item.text;
            precedingText = item.text;
            precedingToken = item;
        }
        else if (typeof item === 'string') {
            line += item;
            precedingText = item;
        }
        else if (item instanceof FormattingInstructions_1.Whitespace) {
            if (i === aLine.length - 1 || i === aLine.length - 2 && aLine[aLine.length - 1] instanceof FormattingInstructions_1.LineBreak) {
                break;
            }
            const relevantSuccessor = (_a = aLine.slice(i + 1).find(item => typeof item === 'string' || item instanceof PpRuleToken_1.PpRuleToken)) !== null && _a !== void 0 ? _a : '';
            line += item.renderString({
                precedingText,
                succeedingText: relevantSuccessor instanceof PpRuleToken_1.PpRuleToken
                    ? relevantSuccessor.text
                    : relevantSuccessor,
                precedingToken
            }, context);
        }
    }
    if (line) {
        line = line.trimRight();
    }
    return {
        completedLine: line
    };
}
function hardenSpecificLines(hardeningContext, sIdToAlign) {
    const { logger } = hardeningContext.globalContext;
    const nPendingLinesBefore = hardeningContext.lineNumbersToBeHardened.size;
    const nDetIdsBefore = hardeningContext.mPreformattedIdToLineNumbers.size;
    const aSpecificLineNumbers = hardeningContext.mPreformattedIdToLineNumbers.get(sIdToAlign);
    aSpecificLineNumbers.forEach(function (x, nLineNumber) {
        const aLine = hardeningContext.globalContext.outputLines[nLineNumber];
        aLine.lineNumber = nLineNumber;
        const hardenedLine = hardenLine(hardeningContext.globalContext, logger, aLine, sIdToAlign, function (obscuredAlignment, byAlignment) {
            const obscuredId = obscuredAlignment.id;
            hardeningContext.obscuredAlignmentIds.set(obscuredId, {
                obscuredBy: byAlignment,
                inLine: aLine.lineNumber,
                id: `Line ${aLine.lineNumber}: ${byAlignment.id}`
            });
            hardeningContext.mPreformattedIdToLineNumbers.delete(obscuredId);
        });
        if (isHardenedLine(hardenedLine)) {
            hardeningContext.hardenedLines[nLineNumber] = hardenedLine.completedLine;
            aSpecificLineNumbers.delete(nLineNumber);
            hardeningContext.lineNumbersToBeHardened.delete(nLineNumber);
        }
        else {
            hardeningContext.globalContext.outputLines[nLineNumber] = hardenedLine.outstandingLineItems;
            const oFirstAlignment = hardenedLine.nextOutstandingAlignment;
            if (!hardeningContext.obscuredAlignmentIds.get(oFirstAlignment.id)) {
                let aLineNumbers = hardeningContext.mPreformattedIdToLineNumbers.get(oFirstAlignment.id);
                if (!aLineNumbers) {
                    aLineNumbers = new Set();
                    hardeningContext.mPreformattedIdToLineNumbers.set(oFirstAlignment.id, aLineNumbers);
                }
                aLineNumbers.add(nLineNumber);
            }
        }
    });
    hardeningContext.mPreformattedIdToLineNumbers.delete(sIdToAlign);
    if (sIdToAlign === PRE_FORMAT) {
        const nPendingLinesAfter = hardeningContext.lineNumbersToBeHardened.size;
        const nDetIdsAfter = hardeningContext.mPreformattedIdToLineNumbers.size;
        trace(logger, Ansi_1.Ansi.TOKEN, 'preformat: pending[' + nPendingLinesBefore + ' -> ' + nPendingLinesAfter + '] headingAlignments[' + (nDetIdsBefore - 1) + ' -> ' + nDetIdsAfter + ']');
        if (nPendingLinesBefore === nPendingLinesAfter && (nDetIdsBefore - 1) === nDetIdsAfter) {
            let sLines = '';
            let aDeadlockCycle;
            try {
                aDeadlockCycle = _findDeadlock(hardeningContext);
                hardeningContext.lineNumbersToBeHardened.forEach(function (lineNumber) {
                    sLines += _printLine(hardeningContext, lineNumber, aDeadlockCycle);
                });
            }
            catch (e) {
                logger.logError(e);
            }
            const msg = `Deadlock during alignment detected.
${Ansi_1.Ansi.RESET}Dependency chain:
${aDeadlockCycle.map(elem => `${elem.inLine}:${Ansi_1.Ansi.ERROR}${elem.obscuredBy.id}${Ansi_1.Ansi.RESET} -> `)}${Ansi_1.Ansi.RESET}
Pending Lines:${sLines}`;
            if (hardeningContext.globalContext.formatOptions.getOption('cancelFormattingOnAlignmentDeadlocks', OptionRanges_1.GLOBAL)) {
                throw new Error(msg);
            }
            logger.logError(msg);
            logger.logInfo(() => 'Trying to break deadlock by ignoring last found circular dependency...');
            for (const alignmentInDeadlockCycle of aDeadlockCycle) {
                const id = alignmentInDeadlockCycle.id.match(/.*?: (.*)/)[1];
                const outputLineInvolvedInDeadlock = hardeningContext.globalContext.outputLines[alignmentInDeadlockCycle.inLine];
                const i = outputLineInvolvedInDeadlock.findIndex(x => x instanceof Alignment_1.Alignment && x.id === id);
                if (i >= 0) {
                    logger.logInfo(() => `Ignoring alignment ${id} in line ${alignmentInDeadlockCycle.inLine}`);
                    outputLineInvolvedInDeadlock[i] = '';
                    break;
                }
            }
        }
    }
    else {
        trace(logger, Ansi_1.Ansi.TOKEN, `hardenSpecificLines(${sIdToAlign}): pending[${nPendingLinesBefore} -> ${hardeningContext.lineNumbersToBeHardened.size}] headingAlignments[${nDetIdsBefore} -> ${hardeningContext.mPreformattedIdToLineNumbers.size}]`);
    }
}
function _printLine(hardeningContext, lineNumber, aDeadlockCycle) {
    const outputLine = hardeningContext.globalContext.outputLines[lineNumber];
    const x = outputLine.reduce((line, item) => {
        if (item instanceof Alignment_1.Alignment) {
            const found = aDeadlockCycle.find(elem => elem.obscuredBy.id === item.id && elem.inLine === lineNumber);
            line += `${found ? Ansi_1.Ansi.ERROR : Ansi_1.Ansi.RULE}${item}${Ansi_1.Ansi.RESET}`;
        }
        else {
            line += `${item instanceof FormattingInstructions_1.FormatBase ? Ansi_1.Ansi.CATEGORY : Ansi_1.Ansi.TOKEN}${item}${Ansi_1.Ansi.RESET}`;
        }
        return line + ', ';
    }, '');
    return `${Ansi_1.Ansi.RESET}\n\t${lineNumber}: ${x}`;
}
function _collectCycle(visited, obscuredAlignmentId, f, aChain) {
    const x = f.obscuredAlignmentIds.get(obscuredAlignmentId);
    aChain.push(x);
    if (visited[obscuredAlignmentId]) {
        return aChain;
    }
    visited[obscuredAlignmentId] = true;
    return _collectCycle(visited, x.obscuredBy.id, f, aChain);
}
function _findDeadlock(f) {
    const obscuredAlignmentId = f.obscuredAlignmentIds.keys().next().value;
    return _collectCycle({}, obscuredAlignmentId, f, []);
}
function preformat(context, hardeningContext) {
    hardeningContext.mPreformattedIdToLineNumbers.set(PRE_FORMAT, hardeningContext.lineNumbersToBeHardened);
    hardenSpecificLines(hardeningContext, PRE_FORMAT);
}
function hardenLines(context) {
    const aAllLineNumbers = new Set();
    for (let lineNumber = 0; lineNumber < context.outputLines.length; lineNumber++) {
        aAllLineNumbers.add(lineNumber);
    }
    const hardeningContext = {
        globalContext: context,
        lineNumbersToBeHardened: aAllLineNumbers,
        mPreformattedIdToLineNumbers: new Map(),
        obscuredAlignmentIds: new Map(),
        hardenedLines: [''],
    };
    while (hardeningContext.lineNumbersToBeHardened.size > 0) {
        preformat(context, hardeningContext);
        for (const [sId] of hardeningContext.mPreformattedIdToLineNumbers) {
            hardenSpecificLines(hardeningContext, sId);
        }
        hardeningContext.obscuredAlignmentIds = new Map();
    }
    return hardeningContext.hardenedLines;
}
exports.hardenLines = hardenLines;
function trace(logger, color, message) {
    logger.trace('pp', color, message, Ansi_1.Ansi.RESET);
}
//# sourceMappingURL=Hardening.js.map