import { Alignment } from './Alignment';
import { CdsFormatOptions, CdsFormatOptionSet } from './formatOptions/CdsFormatOptions';
import { OptionRanges } from './formatOptions/OptionRanges';
import { AlignmentIdAliases, FormattingInstruction, FormattingInstructionOrAlignment } from './formatters/FormattingBasics';
import { LineBreak } from './FormattingInstructions';
import { FormattingStream } from './FormattingStream';
import { FormattingTrigger } from './GenericRuleRenderer';
import { PpChild } from './PpBaseTypes';
import { PpRuleToken, PpToken } from './PpRuleToken';
import { Logger } from './util/Logger';
export declare type OutputType = (LineBreak | Alignment | string) & {
    alignmentDone?: boolean;
};
export declare type OutputLine = OutputType[] & {
    lineNumber?: number;
};
export declare type AnnotationType = 'pre' | 'post';
export interface ContextRange {
    startToken: PpToken;
    endToken: PpToken;
    includingWhitespaceBefore: boolean;
    includingWhitespaceAfter: boolean;
}
export interface FormattingEnablement {
    token: PpToken;
    enabled: boolean;
}
interface CachedInstruction {
    trigger: FormattingTrigger;
    formattedObject: PpChild;
    instructionOrAlignment: FormattingInstructionOrAlignment;
}
export declare class GlobalContext {
    originalSource: string;
    private globalFormatOptions;
    logger: Logger;
    constructor(originalSource: string, globalFormatOptions: CdsFormatOptionSet, logger?: Logger);
    get nextFreeAlignmentId(): number;
    get nextFreeBlockAlignmentId(): number;
    lastBlockAlignment(): Alignment;
    originalSourceLines: string[];
    formattingStream: FormattingStream;
    outputLines: OutputLine[];
    lineNumbersForAlignmentId: Map<string, number[]>;
    lastProcessedToken: PpRuleToken;
    blockAlignmentStack: Alignment[];
    private _nextFreeBlockAlignmentId;
    private _nextFreeAlignmentId;
    _knownAlignmentsById: {
        [id: string]: Alignment;
    };
    formattingEnablements: FormattingEnablement[];
    instructionsDelayedTillNewline: Map<PpChild, FormattingInstruction[]>;
    removableNewlines: Map<number, PpChild>;
    thingsDelayedTillToken: Array<CachedInstruction | PpChild>;
    annotationTypes: {
        [id: string]: AnnotationType;
    };
    formatOptions: OptionRanges<CdsFormatOptions>;
    alignmentIdAliases: AlignmentIdAliases;
    alignmentIdAliasesSet: boolean;
}
export declare function calculateExclusionRanges(tokens: PpToken[], formattingEnablements: FormattingEnablement[]): ContextRange[];
export declare function calculateInclusionRanges(tokens: PpToken[], exclusionRanges: ContextRange[], inclusionRange?: ContextRange): ContextRange[];
export {};
