"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PpBaseTypes_1 = require("./PpBaseTypes");
const Logger_1 = require("./util/Logger");
const StringUtil_1 = require("./util/StringUtil");
const TreeUtil_1 = require("./util/TreeUtil");
class PpToken {
    constructor(token) {
        this._tokenIndex = token.tokenIndex;
        this.text = token.text;
        this.originalText = token.text;
        this.id = `#${this._tokenIndex} ${this.text}`;
        this._category = PpBaseTypes_1.getCategory(token);
        this.line = token.line - 1;
        this.column = token.column;
        this.start = token.start;
        this._temporaryAntlrToken = token;
    }
    finalizeCategory() {
        this._category = PpBaseTypes_1.getCategory(this._temporaryAntlrToken);
        this._temporaryAntlrToken = undefined;
        return this;
    }
    get category() {
        return this._category;
    }
    get line() {
        return this._line;
    }
    set line(line) {
        this._line = line;
        this._endLine = undefined;
    }
    get column() {
        return this._column;
    }
    set column(column) {
        this._column = column;
        this._endColumn = undefined;
    }
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
        this._endLine = undefined;
        this._endColumn = undefined;
    }
    get endLine() {
        if (this._endLine === undefined) {
            this._endLine = _endLine(this.line, this.text);
        }
        return this._endLine;
    }
    get endColumn() {
        if (this._endColumn === undefined) {
            const ix = this.text.lastIndexOf('\n');
            if (ix === -1) {
                this._endColumn = this.column + this.text.length;
            }
            else {
                this._endColumn = this.text.length - ix - 1;
            }
        }
        return this._endColumn;
    }
    getStartCursor() {
        return {
            line: this.line,
            character: this.column
        };
    }
    getEndCursor() {
        return {
            line: this.endLine,
            character: this.endColumn
        };
    }
    get range() {
        return {
            start: this.getStartCursor(),
            end: this.getEndCursor()
        };
    }
    getLowerLexem() {
        return this.text.toLowerCase();
    }
    get tokenIndex() {
        return this._tokenIndex;
    }
    assureFinalized() {
        if (this._temporaryAntlrToken) {
            throw new Error(`Cannot determine if token is Keyword or Identifier before rule has exited - ${this.text}#${this.tokenIndex}`);
        }
    }
    isIdentifier() {
        this.assureFinalized();
        return this.category === 'Identifier';
    }
    isOperator() {
        return this.category === 'Operator';
    }
    isKeyword() {
        this.assureFinalized();
        return this.category === 'Keyword';
    }
    isComment() {
        return this.category === 'Comment' || this.category === 'LineComment' || this.category === 'DocComment';
    }
    isLineComment() {
        return this.category === 'LineComment';
    }
    isBlockComment() {
        return this.isComment() && this.text.indexOf('/*') === 0;
    }
    toString() {
        return this.text;
    }
    getStartOffset() {
        return this.start;
    }
    getEndOffset() {
        return this.start + this.text.length - 1;
    }
    relativeToCursor(cursor) {
        return rangeRelativeToCursor({ start: this.getStartCursor(), end: this.getEndCursor() }, cursor);
    }
}
exports.PpToken = PpToken;
function rangeRelativeToCursor(range, cursor) {
    const start = range.start;
    const end = range.end;
    if (cursor.line < start.line) {
        return 'tokenAfterCursor';
    }
    if (end.line < cursor.line) {
        return 'tokenBeforeCursor';
    }
    if (start.line === end.line) {
        if (cursor.character < start.character) {
            return 'tokenAfterCursor';
        }
        if (cursor.character === start.character) {
            return 'tokenStartsAtCursor';
        }
        if (cursor.character < end.character) {
            return 'tokenContainsCursor';
        }
        if (cursor.character === end.character) {
            return 'tokenEndsWithCursor';
        }
        return 'tokenBeforeCursor';
    }
    else {
        if (start.line === cursor.line) {
            if (cursor.character < start.character) {
                return 'tokenAfterCursor';
            }
            if (start.character === cursor.character) {
                return 'tokenStartsAtCursor';
            }
            return 'tokenContainsCursor';
        }
        else if (start.line < cursor.line && cursor.line < end.line) {
            return 'tokenContainsCursor';
        }
        else if (end.line === cursor.line) {
            if (cursor.character < end.character) {
                return 'tokenContainsCursor';
            }
            if (cursor.character === end.character) {
                return 'tokenEndsWithCursor';
            }
        }
        return 'tokenBeforeCursor';
    }
}
exports.rangeRelativeToCursor = rangeRelativeToCursor;
function _endLine(line, text) {
    return line + lineCount(text) - 1;
}
function lineCount(text) {
    return (text.match(StringUtil_1.NEWLINE_REGEX) || []).length + 1;
}
function endLine(token) {
    return _endLine(token.line - 1, token.text);
}
exports.endLine = endLine;
class PpRuleToken extends PpToken {
    constructor(context, parent, token, isErrorToken = false) {
        super(token);
        this.context = context;
        this.parent = parent;
        this.token = token;
        this.isErrorToken = isErrorToken;
    }
    debugPrint(colorProvider) {
        const isComment = this.isComment();
        const color = this.isErrorToken
            ? colorProvider.get(Logger_1.Color.ERROR_TOKEN) || '~E~'
            : isComment
                ? colorProvider.get(Logger_1.Color.COMMENT_TOKEN)
                : colorProvider.get(Logger_1.Color.TOKEN);
        let output = color + this.text + colorProvider.get(Logger_1.Color.RESET);
        output += `${colorProvider.get(Logger_1.Color.CATEGORY)}[#${this._tokenIndex} ${this.category}]${colorProvider.get(Logger_1.Color.RESET)}`;
        return output;
    }
    getStartTokenIndex() {
        return this._tokenIndex;
    }
    isInlineComment() {
        const nextToken = this.getNextToken(TreeUtil_1.any);
        return this.isBlockComment()
            && this.isSingleLined()
            && !!nextToken && this.endLine === nextToken.line;
    }
    isSingleLined() {
        return this.line === this.endLine;
    }
    isFollowUpComment() {
        if (!this.isComment()) {
            return false;
        }
        const previousToken = this.getPreviousToken(TreeUtil_1.any);
        if (!previousToken) {
            return false;
        }
        return previousToken.endLine === this.line;
    }
    getFollowUpLineEndComment() {
        return this.followUpLineEndCommentToken;
    }
    getPreviousToken(predicate) {
        return this.context.getPreviousToken(this.token, predicate);
    }
    getNextToken(predicate) {
        return this.context.getNextToken(this.token, predicate);
    }
    isCqlKeyword() {
        if (!this.isKeyword()) {
            return false;
        }
        let ruleCursor = this.parent;
        while (ruleCursor) {
            if (ruleCursor.blockRule === 'queryExpression') {
                return true;
            }
            ruleCursor = ruleCursor.parent;
        }
        return false;
    }
}
exports.PpRuleToken = PpRuleToken;
class PpCommentToken extends PpRuleToken {
    constructor(token) {
        super(token.context, token.parent, token.token);
    }
}
exports.PpCommentToken = PpCommentToken;
//# sourceMappingURL=PpRuleToken.js.map