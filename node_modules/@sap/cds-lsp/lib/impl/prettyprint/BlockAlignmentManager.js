"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Alignment_1 = require("./Alignment");
const BlockAlignment_1 = require("./BlockAlignment");
const FormattingInstructions_1 = require("./FormattingInstructions");
class BlockAlignmentManager {
    constructor(globalContext) {
        this.globalContext = globalContext;
    }
    appendToStream(x) {
        this.globalContext.formattingStream.append(x);
    }
    appendBlockAlignment(blockAlignment) {
        const alignmentStack = this.globalContext.blockAlignmentStack;
        if (alignmentStack[alignmentStack.length - 1] !== blockAlignment) {
            alignmentStack.push(blockAlignment);
        }
        traceStack(this.globalContext.logger, '-> ', alignmentStack);
        this.appendToStream(blockAlignment);
    }
    popBlockAlignment(alignmentId, excludingGivenAlignmentId) {
        let index = alignmentId
            ? this.globalContext.blockAlignmentStack.findIndex(blockAlignment => blockAlignment.id === alignmentId)
            : this.globalContext.blockAlignmentStack.indexOf(this.globalContext.lastBlockAlignment());
        if (index < 0) {
            this.globalContext.logger.logWarn(() => `Cannot pop block alignment '${alignmentId}'; assuming it has already been dropped`);
            return;
        }
        if (excludingGivenAlignmentId) {
            index++;
        }
        this.globalContext.blockAlignmentStack.length = index;
        traceStack(this.globalContext.logger, '<- ', this.globalContext.blockAlignmentStack);
    }
    newBlockAlignment(alignmentId, relativeColumn, node) {
        const blockAlignment = this.createBlockAlignment(alignmentId, relativeColumn, node);
        this.appendBlockAlignment(blockAlignment);
        return blockAlignment;
    }
    createBlockAlignment(alignmentId, relativeColumn, node, autoRename = true) {
        let blockAlignment = BlockAlignment_1.BlockAlignment.forId(this.globalContext, alignmentId);
        let isReuse = false;
        if (blockAlignment.ruleNode) {
            if (autoRename) {
                blockAlignment = BlockAlignment_1.BlockAlignment.forId(this.globalContext, alignmentId + '!' + this.globalContext.nextFreeBlockAlignmentId);
                node.context.logger.trace('pp_stack', 'WARN: auto-renamed block alignment to prevent id clash: ', blockAlignment.id);
            }
            else {
                isReuse = true;
            }
        }
        if (!isReuse) {
            blockAlignment.setNode(node);
            blockAlignment.setRelativeAlignment(this.lastAlignment(), relativeColumn);
        }
        return blockAlignment;
    }
    lastAlignment() {
        const stream = this.globalContext.formattingStream.stream;
        for (let i = stream.length - 1; i >= 0; i--) {
            const item = stream[i];
            if (item instanceof FormattingInstructions_1.LineBreak) {
                break;
            }
            if (item instanceof Alignment_1.Alignment) {
                return item;
            }
        }
        return this.globalContext.lastBlockAlignment();
    }
}
exports.BlockAlignmentManager = BlockAlignmentManager;
function traceStack(logger, sHead, alignmentStack) {
    const alignmentIdStack = alignmentStack.map(function (alignment) {
        return alignment.id;
    });
    logger.trace('pp_stack', sHead, alignmentIdStack);
}
//# sourceMappingURL=BlockAlignmentManager.js.map