"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Alignment_1 = require("./Alignment");
const BlockRules_1 = require("./BlockRules");
const FormattingInstructions_1 = require("./FormattingInstructions");
const FormattingStream_1 = require("./FormattingStream");
const GlobalContext_1 = require("./GlobalContext");
const Hardening_1 = require("./Hardening");
const Ansi_1 = require("./util/Ansi");
const TreeUtil_1 = require("./util/TreeUtil");
class PpFormatter {
    format(topNode, effectiveFormattingOptions, originalSource) {
        const result = {
            formatted: '',
            exclusionRanges: []
        };
        const globalContext = new GlobalContext_1.GlobalContext(originalSource, effectiveFormattingOptions, topNode.context.logger);
        globalContext.formattingStream = new FormattingStream_1.FormattingStream(globalContext);
        Alignment_1.Alignment.resetIds(globalContext);
        topNode.format(globalContext);
        globalContext.formattingStream.trace();
        globalContext.formattingStream.stream.forEach(function (item) {
            if (item instanceof FormattingInstructions_1.LineBreak) {
                item.renderArray(globalContext.outputLines);
            }
            else {
                const currentLineNumber = globalContext.outputLines.length - 1;
                if (item instanceof Alignment_1.Alignment) {
                    const lineNumbersForAlignmentId = globalContext.lineNumbersForAlignmentId;
                    let linesNumbersForId = lineNumbersForAlignmentId.get(item.id);
                    if (!linesNumbersForId) {
                        linesNumbersForId = [];
                        lineNumbersForAlignmentId.set(item.id, linesNumbersForId);
                    }
                    linesNumbersForId.push(currentLineNumber);
                }
                globalContext.outputLines[currentLineNumber].push(item);
            }
        });
        const tokens = topNode.context.allTokens;
        if (!tokens.length) {
            if (originalSource.trim() !== '') {
                throw new Error(`No tokens for source: ${originalSource.slice(0, 100)}`);
            }
            return result;
        }
        result.exclusionRanges = GlobalContext_1.calculateExclusionRanges(tokens, globalContext.formattingEnablements);
        let hardenedLines = Hardening_1.hardenLines(globalContext);
        {
            while (hardenedLines.length > 0 && hardenedLines[0].trim() === '') {
                hardenedLines = hardenedLines.slice(1);
            }
            while (hardenedLines.length > 0 && hardenedLines[hardenedLines.length - 1].trim() === '') {
                hardenedLines = hardenedLines.slice(0, hardenedLines.length - 1);
            }
            if (effectiveFormattingOptions.getOption('finalNewline')) {
                hardenedLines.push('');
            }
            result.formatted = hardenedLines.join('\n');
        }
        globalContext.logger.trace('pp', '\n', Ansi_1.Ansi.TOKEN, result.formatted, Ansi_1.Ansi.RESET, '\n');
        return result;
    }
}
exports.PpFormatter = PpFormatter;
function determineRangeTokens(tokens, range, closingCharacterPosition) {
    let contextRange;
    if (closingCharacterPosition) {
        contextRange = positionToContextRange(tokens, closingCharacterPosition);
    }
    else if (range) {
        contextRange = rangeToContextRange(tokens, range);
    }
    if (contextRange && contextRange.startToken && contextRange.endToken) {
        if (contextRange.endToken.tokenIndex >= contextRange.startToken.tokenIndex) {
            return contextRange;
        }
    }
    return undefined;
}
exports.determineRangeTokens = determineRangeTokens;
function rangeToContextRange(tokens, range) {
    range.start.line = validatePositionNumber(range.start.line);
    range.start.character = validatePositionNumber(range.start.character);
    range.end.line = validatePositionNumber(range.end.line);
    range.end.character = validatePositionNumber(range.end.character);
    if (range.start.line > range.end.line || (range.start.line === range.end.line && range.start.character > range.end.character)) {
        throw new Error('Start position must not be after end position: [' + range.start.line + '/' + range.start.character + ', ' + range.end.line + '/' + range.end.character);
    }
    let includingWhitespaceBefore = false;
    let includingWhitespaceAfter = false;
    const startToken = tokens.find(token => {
        const relativeStart = token.relativeToCursor(range.start);
        switch (relativeStart) {
            case 'tokenAfterCursor':
                includingWhitespaceBefore = true;
                return true;
            case 'tokenStartsAtCursor':
            case 'tokenContainsCursor':
                return true;
            case 'tokenEndsWithCursor':
            case 'tokenBeforeCursor':
                return false;
        }
    });
    const reverseFind = (array, predicate) => {
        for (let i = array.length - 1; i >= 0; i--) {
            const t = array[i];
            if (predicate(t)) {
                return t;
            }
        }
        return undefined;
    };
    const endToken = reverseFind(tokens, token => {
        const relativeEnd = token.relativeToCursor(range.end);
        switch (relativeEnd) {
            case 'tokenBeforeCursor':
                includingWhitespaceAfter = true;
                return true;
            case 'tokenEndsWithCursor':
            case 'tokenContainsCursor':
                return true;
            case 'tokenStartsAtCursor':
            case 'tokenAfterCursor':
                return false;
        }
    });
    return {
        startToken,
        endToken,
        includingWhitespaceBefore,
        includingWhitespaceAfter
    };
}
exports.rangeToContextRange = rangeToContextRange;
function getRelevantScopeForFormatOnTyping(closingToken) {
    let cursor = closingToken.parent;
    const essentialScopes = [
        BlockRules_1.BlockRules.artifactDef,
        BlockRules_1.BlockRules.elementDef,
        BlockRules_1.BlockRules.usingDeclaration,
        BlockRules_1.BlockRules.namespaceDeclaration,
        BlockRules_1.BlockRules.start
    ];
    while (cursor && !essentialScopes.includes(cursor.blockRule)) {
        cursor = cursor.parent;
    }
    return cursor;
}
function positionToContextRange(tokens, position) {
    const closingToken = tokens.find(t => t.relativeToCursor(position) === 'tokenEndsWithCursor');
    if (closingToken) {
        let includingWhitespaceBefore = false;
        const blockNode = getRelevantScopeForFormatOnTyping(closingToken);
        const startToken = blockNode.getFirstToken(TreeUtil_1.any);
        if (startToken && startToken.tokenIndex >= 0) {
            includingWhitespaceBefore = true;
        }
        const endToken = blockNode.getLastToken(TreeUtil_1.any);
        return {
            startToken,
            endToken,
            includingWhitespaceBefore,
            includingWhitespaceAfter: false
        };
    }
    throw new Error(`Failed to determine token for given position ${position.line}:${position.character} in given ${tokens.length} tokens`);
}
exports.positionToContextRange = positionToContextRange;
function isInteger(n) {
    return n === +n && n === (n || 0);
}
function validatePositionNumber(n) {
    if (n === undefined) {
        throw new Error('Value is undefined');
    }
    if (!isInteger(n)) {
        throw new Error('Value must be integer: ' + n);
    }
    if (n < 0) {
        if (n === -1) {
            n = Number.MAX_VALUE;
        }
        else {
            throw new Error('Value must not be negative: ' + n);
        }
    }
    return n;
}
//# sourceMappingURL=PpFormatter.js.map