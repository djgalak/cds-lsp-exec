"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("./BlockRules");
const MetaModel_1 = require("./formatOptions/MetaModel");
const FormattingBasics_1 = require("./formatters/FormattingBasics");
const AnnotationUtil_1 = require("./util/AnnotationUtil");
const TreeUtil_1 = require("./util/TreeUtil");
function createArtificialBlockId() {
    return ++createArtificialBlockId.__artificialBlockId;
}
createArtificialBlockId.__artificialBlockId = 0;
function getBlockRenderOptions(userOptions, node) {
    const standaloneBlock = {
        blockAlignment: true,
        beforeBlock: FormattingBasics_1.NewLine,
        beforeBlockGroup: FormattingBasics_1.NewLine,
        afterBlock: FormattingBasics_1.NewLine,
        afterBlockGroup: FormattingBasics_1.NewLine2,
        betweenBlocks: undefined
    };
    const newlineBlock = {
        blockAlignment: false,
        beforeBlock: FormattingBasics_1.NewLine,
        beforeBlockGroup: FormattingBasics_1.NewLine,
        afterBlock: FormattingBasics_1.NewLine,
        afterBlockGroup: FormattingBasics_1.NewLine,
        betweenBlocks: undefined
    };
    const indentedNewlineBlock = {
        blockAlignment: false,
        beforeBlock: FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent,
        beforeBlockGroup: FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent,
        afterBlock: FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent,
        afterBlockGroup: FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent,
        betweenBlocks: FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent
    };
    const inlineBlock = {
        blockAlignment: false,
        beforeBlock: undefined,
        beforeBlockGroup: undefined,
        afterBlock: undefined,
        afterBlockGroup: undefined,
        betweenBlocks: undefined
    };
    const optionsByRule = {
        annotateElement: standaloneBlock,
        annotationAssignment_paren: inlineBlock,
        annotationDef: standaloneBlock,
        condition: inlineBlock,
        elementDef: standaloneBlock,
        expression: inlineBlock,
        extendContext: inlineBlock,
        mixinElementDef: newlineBlock,
        namespaceDeclaration: standaloneBlock,
        orderBySpec: indentedNewlineBlock,
        projectionExclusion: newlineBlock,
        queryExpression: inlineBlock,
        queryPrimary: inlineBlock,
        selectItemDef: inlineBlock,
        tableExpression: inlineBlock,
        typeAssociationCont: inlineBlock,
        typeAssociationElementCont: inlineBlock,
        typeDef: standaloneBlock,
        usingDeclaration: standaloneBlock,
        value: inlineBlock
    };
    const options = optionsByRule[node.blockRule];
    if (options) {
        return options;
    }
    switch (node.blockRule) {
        case BlockRules_1.BlockRules.annotationAssignment_ll1:
        case BlockRules_1.BlockRules.annotationAssignment_atn: {
            const keepInOriginalLine = userOptions.getOption('keepAnnotationsInOriginalLine', node.getStartTokenIndex());
            switch (keepInOriginalLine) {
                case MetaModel_1.AnnotationLines.separateLine:
                    return {
                        beforeBlockGroup: FormattingBasics_1.NewLine,
                        beforeBlock: FormattingBasics_1.NewLine,
                        afterBlock: FormattingBasics_1.NewLine,
                        afterBlockGroup: FormattingBasics_1.NewLine
                    };
                case MetaModel_1.AnnotationLines.keepLine: {
                    const individualOptions = {};
                    individualOptions.betweenBlocks = FormattingBasics_1.WhitespaceAtLeast2;
                    const nodeTokens = node.getTokens();
                    const skipComments = (t) => !t.isComment();
                    const firstToken = nodeTokens.find(skipComments);
                    const previousToken = firstToken.getPreviousToken(TreeUtil_1.any);
                    const annotationStartsInSameLineAsPreviousToken = !previousToken || previousToken.getEndCursor().line === firstToken.line;
                    if (!annotationStartsInSameLineAsPreviousToken) {
                        individualOptions.beforeBlock = FormattingBasics_1.NewLine;
                        individualOptions.beforeBlockGroup = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                        individualOptions.afterBlockGroup = FormattingBasics_1.IndentResetToOriginalBlockIndent;
                    }
                    const lastToken = nodeTokens.reverse().find(skipComments);
                    const nextToken = lastToken.getNextToken(TreeUtil_1.any);
                    const annotationEndsInSameLineAsNextToken = !nextToken || nextToken.line === lastToken.getEndCursor().line;
                    if (!annotationEndsInSameLineAsNextToken) {
                        if (nextToken.getLowerLexem() === '{' && !userOptions.getOption('openingBraceInNewLine', node.getStartTokenIndex())) {
                            individualOptions.afterBlock = FormattingBasics_1.WhitespaceAtLeast1;
                            individualOptions.afterBlockGroup = FormattingBasics_1.WhitespaceAtLeast1;
                        }
                        else {
                            individualOptions.afterBlock = FormattingBasics_1.NewLine;
                            individualOptions.afterBlockGroup = FormattingBasics_1.NewLine;
                        }
                    }
                    const allAnnotations = node.parent.children.filter(child => AnnotationUtil_1.isAnnotation(child));
                    if (allAnnotations.length > 1) {
                        const nodeChildIndex = allAnnotations.findIndex(n => n === node);
                        if (nodeChildIndex > 0) {
                            const previousChild = allAnnotations[nodeChildIndex - 1];
                            if (previousChild.getLastToken(TreeUtil_1.any).getEndCursor().line === node.getFirstToken(TreeUtil_1.any).line) {
                                TreeUtil_1.setAnnotationNumberInLine(node, TreeUtil_1.getAnnotationNumberInLine(previousChild) + 1);
                                individualOptions.beforeBlock = FormattingBasics_1.WhitespaceAtLeast2;
                                individualOptions.betweenBlocks = FormattingBasics_1.WhitespaceAtLeast2;
                            }
                        }
                    }
                    return individualOptions;
                }
            }
            break;
        }
        case BlockRules_1.BlockRules.annotationAssignment_1:
            return TreeUtil_1.getNearestAncestor(node, BlockRules_1.BlockRules.annotationAssignment_paren).countDescendants(BlockRules_1.BlockRules.annotationAssignment_1) > 1
                ? standaloneBlock
                : inlineBlock;
        case BlockRules_1.BlockRules.artifactDef:
            standaloneBlock.betweenBlocks = FormattingBasics_1.NewLine2;
            return standaloneBlock;
        case BlockRules_1.BlockRules.arrayValue: {
            const valueParent = TreeUtil_1.getNearestAncestor(node, BlockRules_1.BlockRules.value, BlockRules_1.BlockRules.arrayValue, BlockRules_1.BlockRules.namedValueInArray);
            if (valueParent) {
                if (valueParent.countDescendants(BlockRules_1.BlockRules.arrayValue) > 1) {
                    return standaloneBlock;
                }
            }
            return inlineBlock;
        }
        case BlockRules_1.BlockRules.contextDef:
            standaloneBlock.betweenBlocks = FormattingBasics_1.NewLine2;
            return standaloneBlock;
        case BlockRules_1.BlockRules.entityDef:
            standaloneBlock.betweenBlocks = FormattingBasics_1.NewLine2;
            return standaloneBlock;
        case BlockRules_1.BlockRules.innerUsing:
            return TreeUtil_1.getNearestAncestor(node, BlockRules_1.BlockRules.usingDeclaration).countDescendants(BlockRules_1.BlockRules.innerUsing) < 2
                ? inlineBlock
                : standaloneBlock;
        case BlockRules_1.BlockRules.namedValue: {
            const valueParent = TreeUtil_1.getNearestAncestor(node, BlockRules_1.BlockRules.value, BlockRules_1.BlockRules.arrayValue);
            if (valueParent) {
                if (valueParent.countDescendants(BlockRules_1.BlockRules.namedValue) > 1) {
                    return standaloneBlock;
                }
            }
            return inlineBlock;
        }
        case BlockRules_1.BlockRules.namedValueInArray: {
            const valueParent = TreeUtil_1.getNearestAncestor(node, BlockRules_1.BlockRules.arrayValue);
            if (valueParent) {
                if (valueParent.countDescendants(BlockRules_1.BlockRules.namedValueInArray) > 1) {
                    return standaloneBlock;
                }
            }
            return inlineBlock;
        }
        case BlockRules_1.BlockRules.viewDef:
            standaloneBlock.afterBlock = FormattingBasics_1.NewLine;
            standaloneBlock.afterBlockGroup = FormattingBasics_1.NewLine2;
            standaloneBlock.betweenBlocks = FormattingBasics_1.NewLine2;
            return standaloneBlock;
    }
    return inlineBlock;
}
exports.getBlockRenderOptions = getBlockRenderOptions;
function getFormattingInstructions(trigger, formatOptions, tokenIndex, node) {
    const optionWhitespaceAroundBinaryOps = formatOptions.getOption('whitespaceAroundBinaryOps', tokenIndex);
    const blockRule = node.blockRule;
    const bracketWhitespacing = (map, trigger, ...directChildRules) => {
        if (trigger === 'before') {
            if (TreeUtil_1.countDirectChildren(node, ...directChildRules) < 2) {
                map['}'] = FormattingBasics_1.WhitespaceOptionalSimple;
                map[']'] = FormattingBasics_1.WhitespaceOptionalSimple;
            }
            else {
                map['}'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                map[']'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
            }
        }
        else {
            if (TreeUtil_1.countDirectChildren(node, ...directChildRules) < 2) {
                map['{'] = FormattingBasics_1.WhitespaceOptionalSimple;
                map['['] = FormattingBasics_1.WhitespaceOptionalSimple;
            }
            else {
                map['{'] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                map['['] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
            }
        }
    };
    let map;
    switch (trigger) {
        case 'before':
            map = {
                '#': FormattingBasics_1.WhitespaceAtLeast1,
                '.': FormattingBasics_1.WhitespaceAtLeastZero,
                ',': FormattingBasics_1.WhitespaceAtLeastZero,
                ';': FormattingBasics_1.WhitespaceAtLeastZero,
                '(': FormattingBasics_1.WhitespaceAtLeastZero,
                ')': FormattingBasics_1.WhitespaceOptionalSimple,
                '{': formatOptions.getOption('openingBraceInNewLine', tokenIndex) ? FormattingBasics_1.NewLine : FormattingBasics_1.WhitespaceOptionalSimple,
                '}': FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent,
                ':': formatOptions.getOption('whitespaceBeforeColon', tokenIndex) ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '::': FormattingBasics_1.WhitespaceAtLeastZero,
                '+': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '-': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '*': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '/': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '||': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '<': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '>': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '<=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '>=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '<>': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '!=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero
            };
            switch (blockRule) {
                case BlockRules_1.BlockRules.annotationAssignment_1:
                    if (node.children.length > 1) {
                        map[']'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    }
                    break;
                case BlockRules_1.BlockRules.annotationAssignment_paren:
                    if (TreeUtil_1.countDirectChildren(node, BlockRules_1.BlockRules.annotationAssignment_1) > 1) {
                        map[')'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    }
                    break;
                case BlockRules_1.BlockRules.artifactDef:
                    map.betweenBlocks = FormattingBasics_1.NewLine2;
                    break;
                case BlockRules_1.BlockRules.arrayValue:
                    bracketWhitespacing(map, trigger, BlockRules_1.BlockRules.namedValueInArray, BlockRules_1.BlockRules.arrayValue);
                    if (TreeUtil_1.countDirectChildren(node, BlockRules_1.BlockRules.namedValueInArray, BlockRules_1.BlockRules.arrayValue) < 2) {
                        map['}'] = FormattingBasics_1.WhitespaceOptionalSimple;
                        map[']'] = FormattingBasics_1.WhitespaceOptionalSimple;
                    }
                    else {
                        map['}'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                        map[']'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    }
                    break;
                case BlockRules_1.BlockRules.condition:
                    map.and = FormattingBasics_1.NewLine;
                    map.or = FormattingBasics_1.NewLine;
                    break;
                case BlockRules_1.BlockRules.expression:
                    map.then = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    map.else = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    map.end = '\n==';
                    break;
                case BlockRules_1.BlockRules.queryExpression:
                    map.order = FormattingBasics_1.NewLine;
                    map.limit = FormattingBasics_1.NewLine;
                    map.offset = FormattingBasics_1.NewLine;
                    map[')'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    break;
                case BlockRules_1.BlockRules.queryPrimary:
                    map.mixin = FormattingBasics_1.NewLine;
                    map.into = FormattingBasics_1.NewLine;
                    map.top = FormattingBasics_1.NewLine;
                    map.excluding = FormattingBasics_1.NewLine;
                    map.where = FormattingBasics_1.NewLine;
                    map.group = FormattingBasics_1.NewLine;
                    map.having = FormattingBasics_1.NewLine;
                    map[')'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    map['*'] = FormattingBasics_1.WhitespaceAtLeast1;
                    break;
                case BlockRules_1.BlockRules.tableExpression:
                    map['('] = FormattingBasics_1.WhitespaceAtLeast1;
                    map[')'] = FormattingBasics_1.NewLineAndIndentResetToOriginalBlockIndent;
                    map.on = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    break;
                case BlockRules_1.BlockRules.typeAssociationCont:
                case BlockRules_1.BlockRules.typeAssociationElementCont:
                    map.on = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    break;
                case BlockRules_1.BlockRules.usingDeclaration:
                    if (node.countDescendants(BlockRules_1.BlockRules.innerUsing) < 2) {
                        delete map['}'];
                    }
                    break;
                case BlockRules_1.BlockRules.value:
                    bracketWhitespacing(map, trigger, BlockRules_1.BlockRules.namedValue, BlockRules_1.BlockRules.value);
                    break;
                case BlockRules_1.BlockRules.viewDef:
                    map.order = FormattingBasics_1.NewLine;
                    break;
            }
            return map;
        case 'after':
            map = {
                '#': FormattingBasics_1.WhitespaceAtLeastZero,
                '.': FormattingBasics_1.WhitespaceAtLeastZero,
                ',': formatOptions.getOption('whitespaceAfterComma', tokenIndex) ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '(': FormattingBasics_1.WhitespaceOptionalSimple,
                ';': FormattingBasics_1.NewLine,
                '{': FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent,
                '@': FormattingBasics_1.WhitespaceAtLeastZero,
                ':': formatOptions.getOption('whitespaceAfterColon', tokenIndex) ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '::': FormattingBasics_1.WhitespaceAtLeastZero,
                '+': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '-': FormattingBasics_1.WhitespaceOptionalSimple,
                '*': optionWhitespaceAroundBinaryOps && blockRule !== BlockRules_1.BlockRules.queryPrimary ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceOptionalSimple,
                '/': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '||': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '<': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '>': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '<=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '>=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '<>': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero,
                '!=': optionWhitespaceAroundBinaryOps ? FormattingBasics_1.WhitespaceAtLeast1 : FormattingBasics_1.WhitespaceAtLeastZero
            };
            switch (blockRule) {
                case BlockRules_1.BlockRules.annotationAssignment_1:
                    if (node.children.length > 1) {
                        map['['] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    }
                    break;
                case BlockRules_1.BlockRules.annotationAssignment_paren:
                    if (TreeUtil_1.countDirectChildren(node, BlockRules_1.BlockRules.annotationAssignment_1) > 1) {
                        map['('] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    }
                    break;
                case BlockRules_1.BlockRules.artifactDef:
                    map.betweenBlocks = FormattingBasics_1.NewLine2;
                    break;
                case BlockRules_1.BlockRules.arrayValue:
                    bracketWhitespacing(map, trigger, BlockRules_1.BlockRules.namedValueInArray, BlockRules_1.BlockRules.arrayValue);
                    break;
                case BlockRules_1.BlockRules.expression:
                    map.when = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    map.then = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    map.else = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    break;
                case BlockRules_1.BlockRules.queryExpression:
                    map['('] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    break;
                case BlockRules_1.BlockRules.queryPrimary:
                    map['('] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    break;
                case BlockRules_1.BlockRules.selectItemDef:
                    map.key = FormattingBasics_1.WhitespaceAtLeast1;
                    break;
                case BlockRules_1.BlockRules.tableExpression:
                    map['('] = FormattingBasics_1.NewLineAndIndentBy1FromOriginalBlockIndent;
                    map[','] = FormattingBasics_1.NewLine;
                    break;
                case BlockRules_1.BlockRules.typeAssociationCont:
                case BlockRules_1.BlockRules.typeAssociationElementCont:
                    map.on = FormattingBasics_1.WhitespaceAtLeast1;
                    break;
                case BlockRules_1.BlockRules.usingDeclaration:
                    if (node.countDescendants(BlockRules_1.BlockRules.innerUsing) < 2) {
                        delete map['{'];
                    }
                    break;
                case BlockRules_1.BlockRules.value:
                    bracketWhitespacing(map, trigger, BlockRules_1.BlockRules.namedValue, BlockRules_1.BlockRules.value);
                    break;
            }
            return map;
        default:
            return undefined;
    }
}
exports.getFormattingInstructions = getFormattingInstructions;
//# sourceMappingURL=RenderOptions.js.map