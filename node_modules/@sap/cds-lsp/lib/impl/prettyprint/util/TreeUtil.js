"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FormattingInstructions_1 = require("../FormattingInstructions");
const PpRuleNode_1 = require("../PpRuleNode");
const PpRuleToken_1 = require("../PpRuleToken");
const AnnotationUtil_1 = require("./AnnotationUtil");
function getAnnotationNumberInLine(node) {
    return node._al_annoNumberInLine || 1;
}
exports.getAnnotationNumberInLine = getAnnotationNumberInLine;
function setAnnotationNumberInLine(node, n) {
    return node._al_annoNumberInLine = n;
}
exports.setAnnotationNumberInLine = setAnnotationNumberInLine;
function* getAncestors(node, predicate) {
    let cursor = node.parent;
    while (cursor) {
        if (!predicate || predicate(cursor)) {
            yield cursor;
        }
        cursor = cursor.parent;
    }
}
exports.getAncestors = getAncestors;
function getNearestAncestor(node, ...rules) {
    for (const ancestor of getAncestors(node)) {
        if (rules.includes(ancestor.ruleName)) {
            return ancestor;
        }
    }
    return null;
}
exports.getNearestAncestor = getNearestAncestor;
function getFarthestAncestor(node, ...rules) {
    let farthest;
    for (const ancestor of getAncestors(node)) {
        if (rules.includes(ancestor.ruleName)) {
            farthest = ancestor;
        }
    }
    return farthest;
}
exports.getFarthestAncestor = getFarthestAncestor;
function getPreviousSibling(child, predicate) {
    return getAdjacentSibling(child, -1, predicate);
}
exports.getPreviousSibling = getPreviousSibling;
function getNextSibling(child, predicate) {
    return getAdjacentSibling(child, +1, predicate);
}
exports.getNextSibling = getNextSibling;
function getAdjacentSibling(child, increment, predicate) {
    var _a;
    if (!child) {
        return null;
    }
    const siblings = (_a = child.parent) === null || _a === void 0 ? void 0 : _a.children;
    if (!siblings) {
        return null;
    }
    const childIndex = siblings.indexOf(child);
    for (let i = childIndex + increment; 0 <= i && i < siblings.length; i += increment) {
        const sibling = siblings[i];
        if (predicate(sibling)) {
            return sibling;
        }
    }
    return null;
}
function getFirstDescendant(node, predicate) {
    return getFirstOrLastDescendant(node, +1, predicate);
}
exports.getFirstDescendant = getFirstDescendant;
function getLastDescendant(node, predicate) {
    return getFirstOrLastDescendant(node, -1, predicate);
}
exports.getLastDescendant = getLastDescendant;
function getFirstOrLastDescendant(node, increment, predicate) {
    if (!node) {
        return null;
    }
    const childCount = node.children.length;
    if (childCount === 0 && (predicate(node))) {
        return node;
    }
    for (let i = increment > 0 ? 0 : childCount - 1; 0 <= i && i < childCount; i += increment) {
        const child = node.children[i];
        if (!predicate(child)) {
            continue;
        }
        if (child instanceof PpRuleToken_1.PpRuleToken) {
            return child;
        }
        const ancestor = getFirstOrLastDescendant(child, increment, predicate);
        if (ancestor) {
            return ancestor;
        }
    }
    return null;
}
function hasDescendant(node, potentialDescendant) {
    for (const ancestor of getAncestors(potentialDescendant)) {
        if (ancestor === node) {
            return true;
        }
    }
    return false;
}
exports.hasDescendant = hasDescendant;
function getPreviousToken(child, predicate) {
    return getAdjacentToken(child, -1, predicate);
}
exports.getPreviousToken = getPreviousToken;
function getNextToken(child, predicate) {
    return getAdjacentToken(child, +1, predicate);
}
exports.getNextToken = getNextToken;
function getAdjacentToken(child, increment, predicate) {
    var _a;
    if (!child) {
        return null;
    }
    const siblings = (_a = child.parent) === null || _a === void 0 ? void 0 : _a.children;
    if (siblings) {
        for (let i = siblings.indexOf(child) + increment; 0 <= i && i < siblings.length; i += increment) {
            const sibling = siblings[i];
            if (!predicate(sibling)) {
                continue;
            }
            if (sibling instanceof PpRuleToken_1.PpRuleToken) {
                return sibling;
            }
            const previousLastAncestor = getFirstOrLastDescendant(sibling, increment, predicate);
            if (!previousLastAncestor) {
                continue;
            }
            return previousLastAncestor instanceof PpRuleToken_1.PpRuleToken
                ? previousLastAncestor
                : getAdjacentToken(previousLastAncestor, increment, predicate);
        }
    }
    return getAdjacentToken(child.parent, increment, predicate);
}
exports.getAdjacentToken = getAdjacentToken;
function firstLineBreakBetween(index1, index2, formattingStream) {
    const stream = formattingStream.stream;
    for (let i = index1; i <= index2; i++) {
        if (stream[i] instanceof FormattingInstructions_1.LineBreak) {
            return stream[i];
        }
    }
    return undefined;
}
exports.firstLineBreakBetween = firstLineBreakBetween;
function nonComment(child) {
    return child instanceof PpRuleNode_1.PpRuleNode || !child.isComment();
}
exports.nonComment = nonComment;
function nonCommentNonAnnotation(child) {
    return child instanceof PpRuleToken_1.PpRuleToken && !child.isComment() ||
        child instanceof PpRuleNode_1.PpRuleNode && !AnnotationUtil_1.annotationRules.includes(child.ruleName);
}
exports.nonCommentNonAnnotation = nonCommentNonAnnotation;
function any(arg) {
    return true;
}
exports.any = any;
function countDirectChildren(node, ...ruleNames) {
    return node.children.filter(child => child instanceof PpRuleNode_1.PpRuleNode && ruleNames.includes(child.ruleName)).length;
}
exports.countDirectChildren = countDirectChildren;
function countDescendants(node, ...ruleNames) {
    function countRecursively(result, child) {
        return result + (child instanceof PpRuleNode_1.PpRuleNode
            ? ruleNames.includes(child.ruleName)
                ? 1
                : countDescendants(child, ...ruleNames)
            : 0);
    }
    return node.children.reduce(countRecursively, 0);
}
exports.countDescendants = countDescendants;
//# sourceMappingURL=TreeUtil.js.map