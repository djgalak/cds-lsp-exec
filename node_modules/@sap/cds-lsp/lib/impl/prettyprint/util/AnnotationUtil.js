"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("../BlockRules");
const FormattingBasics_1 = require("../formatters/FormattingBasics");
const PpRuleNode_1 = require("../PpRuleNode");
const PpRuleToken_1 = require("../PpRuleToken");
const TreeUtil_1 = require("./TreeUtil");
exports.annotationRules = [
    BlockRules_1.BlockRules.annotationAssignment_atn,
    BlockRules_1.BlockRules.annotationAssignment_fix,
    BlockRules_1.BlockRules.annotationAssignment_ll1,
    BlockRules_1.BlockRules.annotationAssignment_paren,
    BlockRules_1.BlockRules.annotationAssignment_1
];
function isAnnotation(child) {
    return child instanceof PpRuleNode_1.PpRuleNode && exports.annotationRules.includes(child.ruleName);
}
exports.isAnnotation = isAnnotation;
function getAndRememberAnnotationType(node, context) {
    let previousSibling;
    let previousAnnoType;
    let nextSibling;
    function setPreviousSibling() {
        if (previousSibling === undefined) {
            previousSibling = TreeUtil_1.getPreviousSibling(node, TreeUtil_1.nonComment);
            if (previousSibling) {
                previousAnnoType = context.annotationTypes[previousSibling.id];
            }
        }
    }
    function isPostAnnotation() {
        nextSibling = TreeUtil_1.getNextSibling(node, TreeUtil_1.nonComment);
        const isLastSibling = nextSibling === null;
        if (isLastSibling) {
            return true;
        }
        if (nextSibling instanceof PpRuleToken_1.PpRuleToken && [';', '}'].includes(FormattingBasics_1.lowerLexem(nextSibling))) {
            return true;
        }
        setPreviousSibling();
        return previousAnnoType === 'post' ||
            previousSibling instanceof PpRuleToken_1.PpRuleToken && (['with', ')'].includes(FormattingBasics_1.lowerLexem(previousSibling)) ||
                previousSibling.isIdentifier()) ||
            previousSibling instanceof PpRuleNode_1.PpRuleNode && previousSibling.ruleName === BlockRules_1.BlockRules.typeRefOptArgs;
    }
    function remember(annotationType) {
        context.annotationTypes[node.id] = annotationType;
        return annotationType;
    }
    if (!isAnnotation(node)) {
        return remember(undefined);
    }
    if (isPostAnnotation()) {
        return remember('post');
    }
    setPreviousSibling();
    const annoType = previousSibling === null ||
        previousAnnoType === 'pre' ||
        nextSibling instanceof PpRuleToken_1.PpRuleToken && (['{', 'key'].includes(FormattingBasics_1.lowerLexem(nextSibling)) ||
            nextSibling.isIdentifier())
        ? 'pre'
        : 'post';
    return remember(annoType);
}
exports.getAndRememberAnnotationType = getAndRememberAnnotationType;
//# sourceMappingURL=AnnotationUtil.js.map