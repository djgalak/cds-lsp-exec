"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function capitalize(s) {
    return s.length ? s[0].toUpperCase() + s.toLowerCase().slice(1) : '';
}
exports.capitalize = capitalize;
function toCamelCase(input) {
    if (input.includes('-') || input.includes('_')) {
        return input.split(/[_-]/).map((segment, i) => i ? capitalize(segment) : segment.toLowerCase()).join('');
    }
    return input;
}
exports.toCamelCase = toCamelCase;
class SplitLines {
    constructor() {
        this.lines = [];
        this.lineOffsets = [0];
        this.firstCharacterOffsets = [0];
        this.leftTrimmedLines = [];
        this.lineBreaks = [];
    }
    get lineCount() {
        return this.lines.length;
    }
}
exports.SplitLines = SplitLines;
exports.NEWLINE_REGEX = /\r?\n/g;
function splitLines(text) {
    if (text === undefined || text === null) {
        throw new Error('text must be defined');
    }
    const split = new SplitLines();
    text.split(exports.NEWLINE_REGEX).forEach((line, i) => {
        const trimmed = line.trimLeft();
        split.lines[i] = line;
        split.firstCharacterOffsets[i] = line.length - trimmed.length;
        split.leftTrimmedLines[i] = trimmed;
    });
    if (split.lines.length > 1) {
        split.lineBreaks = text.match(exports.NEWLINE_REGEX);
    }
    if (split.lineBreaks.length < split.lines.length) {
        split.lineBreaks.push('');
    }
    let cursor = 0;
    for (let i = 0; i < split.lines.length; i++) {
        split.lineOffsets[i] = cursor;
        cursor += split.lines[i].length + split.lineBreaks[i].length;
    }
    return split;
}
exports.splitLines = splitLines;
//# sourceMappingURL=StringUtil.js.map