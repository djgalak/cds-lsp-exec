"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FormattingInstructions_1 = require("./FormattingInstructions");
const PpRuleNode_1 = require("./PpRuleNode");
const PpRuleToken_1 = require("./PpRuleToken");
const TreeUtil_1 = require("./util/TreeUtil");
class FormattingProcessor {
    constructor(globalContext, blockAlignmentManager) {
        this.globalContext = globalContext;
        this.blockAlignmentManager = blockAlignmentManager;
    }
    appendToStream(x) {
        this.globalContext.formattingStream.append(x);
    }
    processFormatting(sFormat, formattedObject, trigger, ignoreCache = false) {
        if ([undefined, null].includes(sFormat)) {
            return;
        }
        if (this.globalContext.thingsDelayedTillToken.length && !ignoreCache) {
            this.globalContext.thingsDelayedTillToken.push({ trigger, formattedObject, instructionOrAlignment: sFormat });
            return;
        }
        if (['', '|'].includes(sFormat)) {
            this.logFormattingInstructions(sFormat, formattedObject, trigger);
            if (sFormat === '|') {
                this.appendToStream(whitespace());
            }
            else {
                this.appendToStream(whitespace(0));
            }
            return;
        }
        for (let i = 0; i < sFormat.length; i++) {
            const sFormatCurrent = sFormat[i];
            if (!['>', '+', '/', '-', ' ', '\n'].includes(sFormatCurrent)) {
                this.logFormattingInstructions(sFormatCurrent, formattedObject, trigger);
            }
            switch (sFormatCurrent) {
                case '>':
                case '+':
                case '/': {
                    const sOperator = sFormatCurrent;
                    const indentWidth = sOperator === '>' ? 1 : this.globalContext.formatOptions.getOption('tabSize', formattedObject.getStartTokenIndex());
                    const cacheInstruction = sOperator === '/';
                    const nodePlus = formattedObject.parent;
                    if (!nodePlus) {
                        throw new Error('Unsupported formatting instruction for ' + formattedObject + ': ' + sFormat);
                    }
                    let sIndentIncrement = '';
                    while (i + 1 < sFormat.length && sFormat[i + 1] >= '0' && sFormat[i + 1] <= '9') {
                        i++;
                        sIndentIncrement += sFormat[i];
                    }
                    const nIndentIncrement = parseInt(sIndentIncrement, 10) * indentWidth;
                    if (isEmptyPair(formattedObject)) {
                        break;
                    }
                    this.logFormattingInstructions(sOperator + nIndentIncrement, formattedObject, trigger);
                    if (cacheInstruction) {
                        const instructions = this.globalContext.instructionsDelayedTillNewline.get(formattedObject) || [];
                        instructions.push('+' + sIndentIncrement);
                        this.globalContext.instructionsDelayedTillNewline.set(formattedObject, instructions);
                    }
                    else {
                        this.blockAlignmentManager.newBlockAlignment(nodePlus.id + '+' + nIndentIncrement + '#' + this.globalContext.nextFreeBlockAlignmentId, nIndentIncrement, nodePlus);
                    }
                    break;
                }
                case '-': {
                    const nodeMinus = formattedObject.parent;
                    if (nodeMinus) {
                        let sIndentDecrement = '';
                        while (i + 1 < sFormat.length && sFormat[i + 1] >= '0' && sFormat[i + 1] <= '9') {
                            i++;
                            sIndentDecrement += sFormat[i];
                        }
                        const nIndentDecrement = parseInt(sIndentDecrement, 10) * this.globalContext.formatOptions.getOption('tabSize', formattedObject.getStartTokenIndex());
                        this.logFormattingInstructions('-' + nIndentDecrement, formattedObject, trigger);
                        this.blockAlignmentManager.newBlockAlignment(nodeMinus.id + '-' + nIndentDecrement + '#' + this.globalContext.nextFreeBlockAlignmentId, -nIndentDecrement, nodeMinus);
                        break;
                    }
                    throw new Error('Unsupported formatting instruction for ' + formattedObject + ': ' + sFormat);
                }
                case '=': {
                    const nodeEqu = formattedObject.parent;
                    if (nodeEqu) {
                        if (isEmptyPair(formattedObject)) {
                            break;
                        }
                        this.blockAlignmentManager.popBlockAlignment();
                        break;
                    }
                    throw new Error('Unsupported formatting instruction for ' + formattedObject + ': ' + sFormat);
                }
                case ' ': {
                    let nAtLeastBlanks = 1;
                    while (i + 1 < sFormat.length && sFormat[i + 1] === ' ') {
                        i++;
                        nAtLeastBlanks++;
                    }
                    this.logFormattingInstructions(' '.repeat(nAtLeastBlanks), formattedObject, trigger);
                    this.appendToStream(whitespace(nAtLeastBlanks));
                    break;
                }
                case '\n': {
                    if (this.nextRemovableNewline === this.globalContext.formattingStream.stream.length) {
                        this.globalContext.removableNewlines.set(this.nextRemovableNewline, formattedObject);
                    }
                    let nAtLeastEmptyLines = 0;
                    while (i + 1 < sFormat.length && sFormat[i + 1] === '\n') {
                        i++;
                        nAtLeastEmptyLines++;
                    }
                    this.logFormattingInstructions('\n≥' + nAtLeastEmptyLines, formattedObject, trigger);
                    this.appendToStream(new FormattingInstructions_1.LineBreak().atLeast(nAtLeastEmptyLines));
                    if (this.globalContext.instructionsDelayedTillNewline.size) {
                        for (const [formerItem, delayedInstructions] of this.globalContext.instructionsDelayedTillNewline) {
                            const formerNode = formerItem instanceof PpRuleNode_1.PpRuleNode ? formerItem : formerItem.parent;
                            if (formerNode.getFormatter(this.globalContext).isWithinFormattingScope(formattedObject, trigger)) {
                                delayedInstructions.forEach(instruction => this.processFormatting(instruction, formattedObject, trigger, ignoreCache));
                            }
                            this.globalContext.instructionsDelayedTillNewline.delete(formerItem);
                        }
                    }
                    break;
                }
                case '^':
                    this.nextRemovableNewline = this.globalContext.formattingStream.stream.length;
                    break;
                case '°':
                    break;
                default:
                    throw new Error('Unsupported formatting instruction: ' + sFormatCurrent);
            }
        }
    }
    logFormattingInstructions(format, formattedObject, trigger, instructionId) {
        if (!formattedObject) {
            return;
        }
        const logger = formattedObject.context.logger;
        const stringifiedFormat = JSON.stringify(format);
        const expectedMaxFormatLength = JSON.stringify('\n≥0').length;
        const spaces = () => ' '.repeat(Math.max(0, expectedMaxFormatLength - stringifiedFormat.length));
        const id = formattedObject instanceof PpRuleToken_1.PpRuleToken && formattedObject.isBlockComment() && !formattedObject.isInlineComment()
            ? JSON.stringify(formattedObject.id)
            : formattedObject.id;
        logger.logDebug(() => `format\t${stringifiedFormat}${spaces()}\t${trigger === 'before' ? '->' : '<-'}  ( ${id} )${instructionId ? ' [' + instructionId + ']' : ''}`);
    }
}
exports.FormattingProcessor = FormattingProcessor;
function whitespace(n) {
    return n === undefined
        ? new FormattingInstructions_1.Whitespace().optionalSimple()
        : new FormattingInstructions_1.Whitespace().atLeast(n);
}
function isEmptyPair(formattedObject) {
    if (!(formattedObject instanceof PpRuleToken_1.PpRuleToken)) {
        return false;
    }
    if (formattedObject) {
        switch (formattedObject.text) {
            case '{': {
                const nt = formattedObject.getNextToken(TreeUtil_1.any);
                return nt && nt.text === '}';
            }
            case '}': {
                const pt = formattedObject.getPreviousToken(TreeUtil_1.any);
                return pt && pt.text === '{';
            }
        }
    }
    return false;
}
//# sourceMappingURL=FormattingProcessor.js.map