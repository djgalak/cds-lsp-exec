"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("./BlockRules");
const PpRuleNode_1 = require("./PpRuleNode");
const PpRuleToken_1 = require("./PpRuleToken");
const Logger_1 = require("./util/Logger");
class PpParserContext {
    constructor() {
        this.logger = new Logger_1.Logger();
        this.allTokens = [];
        this.rawTokens = [];
    }
    getPreviousToken(token, predicate) {
        const tokens = this.allTokens;
        for (let index = token.tokenIndex - 1; index >= 0; index--) {
            if (predicate(tokens[index])) {
                return tokens[index];
            }
        }
        return null;
    }
    getNextToken(token, predicate) {
        const tokens = this.allTokens;
        for (let index = token.tokenIndex + 1; index < tokens.length; index++) {
            if (predicate(tokens[index])) {
                return tokens[index];
            }
        }
        return null;
    }
}
exports.PpParserContext = PpParserContext;
function getCategory(symbol) {
    const typ = symbol.type;
    const lexer = symbol.getTokenSource();
    const cat = lexer.literalNames[typ] ? 'Operator' : lexer.symbolicNames[typ];
    if (cat) {
        if (cat.toUpperCase() === cat) {
            if (symbol.isIdentifier) {
                return 'Identifier';
            }
            return 'Keyword';
        }
        return cat;
    }
    return '<EOF>';
}
exports.getCategory = getCategory;
function getTokens(allTokens, child) {
    if (child instanceof PpRuleToken_1.PpRuleToken) {
        allTokens.push(child);
    }
    else {
        allTokens = child.children.reduce(getTokens, allTokens);
    }
    return allTokens;
}
exports.getTokens = getTokens;
function getRuleName(ruleContext) {
    return !ruleContext ? '???' : ruleContext.parser.ruleNames[ruleContext.ruleIndex];
}
exports.getRuleName = getRuleName;
let blanks = '    ';
function indent(n) {
    while (n > blanks.length) {
        blanks = blanks + blanks;
    }
    return blanks.substr(0, n);
}
exports.indent = indent;
function isRequiredForFormatting(node) {
    const ruleName = getRuleName(node.ruleContext);
    return BlockRules_1.isBlockRule(ruleName);
}
function flattenIrrelevantRuleNodes(newChildren, child) {
    if (child instanceof PpRuleNode_1.PpRuleNode) {
        child.children = reduceChildren(child.children);
        if (!isRequiredForFormatting(child)) {
            newChildren.push(...child.children);
            return newChildren;
        }
    }
    newChildren.push(child);
    return newChildren;
}
function reduceChildren(children) {
    return children.reduce(flattenIrrelevantRuleNodes, []);
}
exports.reduceChildren = reduceChildren;
//# sourceMappingURL=PpBaseTypes.js.map