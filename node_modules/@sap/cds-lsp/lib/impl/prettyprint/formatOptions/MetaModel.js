"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FormatOptionSet_1 = require("./FormatOptionSet");
const SampleCode_1 = require("./SampleCode");
var AnnotationLines;
(function (AnnotationLines) {
    AnnotationLines["keepLine"] = "keepLine";
    AnnotationLines["separateLine"] = "separateLine";
})(AnnotationLines = exports.AnnotationLines || (exports.AnnotationLines = {}));
var KeywordCasing;
(function (KeywordCasing) {
    KeywordCasing["lower"] = "lower";
    KeywordCasing["upper"] = "upper";
    KeywordCasing["title"] = "title";
    KeywordCasing["as-is"] = "as-is";
})(KeywordCasing = exports.KeywordCasing || (exports.KeywordCasing = {}));
class MetaOption {
    constructor(defaultValue, label, description, sampleCode = SampleCode_1.cdsFormatOptionsSampleCode, parentDependency, isInternal = false) {
        this.defaultValue = defaultValue;
        this.label = label;
        this.description = description;
        this.sampleCode = sampleCode;
        this.parentDependency = parentDependency;
        this.isInternal = isInternal;
        if (typeof defaultValue === 'string') {
            const tryGetAllowedValues = (stringEnumClass) => {
                const enumValues = Object.values(stringEnumClass);
                return enumValues.includes(defaultValue) ? enumValues : undefined;
            };
            this.allowedEnumValues = tryGetAllowedValues(AnnotationLines) || tryGetAllowedValues(KeywordCasing);
        }
    }
    isValidValue(value) {
        const valType = typeof value;
        if (valType !== typeof this.defaultValue)
            return false;
        if (valType === 'string')
            return this.allowedEnumValues.includes(value);
        return true;
    }
}
exports.MetaOption = MetaOption;
class MetaOptionMap {
}
exports.MetaOptionMap = MetaOptionMap;
class MetaModel {
    constructor(metaOptions, logger) {
        this.metaOptions = metaOptions;
        this.logger = logger;
    }
    getMetaOption(name) {
        return this.metaOptions[name];
    }
    emptySet(sourceTag = 'empty') {
        return new FormatOptionSet_1.FormatOptionSet(this, {}, this.logger, sourceTag);
    }
    getOptionNames() {
        return Object.keys(this.metaOptions);
    }
    defaultSet(sourceTag = 'defaults') {
        const set = this.emptySet(sourceTag);
        this.getOptionNames()
            .forEach((key) => set.setOption(key, this.getMetaOption(key).defaultValue));
        return set;
    }
}
exports.MetaModel = MetaModel;
//# sourceMappingURL=MetaModel.js.map