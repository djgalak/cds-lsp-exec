"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class FormatOptionSet {
    constructor(metaModel, options, logger, sourceTag) {
        this.metaModel = metaModel;
        this.options = options;
        this.logger = logger;
        this.sourceTag = sourceTag;
        logger.logInfo(() => `-- formatting options from '${sourceTag}'`);
    }
    getOption(name) {
        const option = this.options[name];
        if (option === undefined) {
            return null;
        }
        const parentOn = (parentOptionName) => parentOptionName
            ? !!this.options[parentOptionName] && parentOn(this.metaModel.getMetaOption(parentOptionName).parentDependency)
            : true;
        const metaOption = this.metaModel.getMetaOption(name);
        return parentOn(metaOption.parentDependency)
            ? option
            : typeof metaOption.defaultValue === 'boolean' ? false : null;
    }
    setOption(name, value) {
        const metaOption = this.metaModel.getMetaOption(name);
        if (!metaOption) {
            this.logger.logWarn(() => `/ cannot set unknown option ${name} to value ${JSON.stringify(value)}`);
            return false;
        }
        if (!metaOption.isValidValue(value)) {
            this.logger.logWarn(() => `/ cannot set option ${name}: given value ${JSON.stringify(value)} has wrong type: expected type ${typeof metaOption.defaultValue}`);
            return false;
        }
        if (this.options[name] === undefined) {
            this.logger.logInfo(() => `+ ${(name + ':').padEnd(40)} ${JSON.stringify(value)}`);
        }
        else {
            this.logger.logInfo(() => `* changing option '${name}': ${JSON.stringify(this.options[name])} -> ${JSON.stringify(value)}`);
        }
        this.options[name] = value;
        return true;
    }
    overlayWith(other) {
        if (!other)
            return;
        this.logger.logInfo(() => `-- overlaying options from ${this.sourceTag} with those from ${other.sourceTag}`);
        Object.keys(other.options)
            .forEach(name => this.setOption(name, other.getOption(name)));
    }
    getOptionNames() {
        return Object.keys(this.options);
    }
}
exports.FormatOptionSet = FormatOptionSet;
FormatOptionSet.defaultsSymbol = Symbol('DefaultFormattingOptionsSymbol');
//# sourceMappingURL=FormatOptionSet.js.map