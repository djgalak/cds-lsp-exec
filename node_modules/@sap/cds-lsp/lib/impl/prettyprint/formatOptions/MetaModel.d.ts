import { Logger } from '../util/Logger';
import { FormatOptionSet } from './FormatOptionSet';
export declare enum AnnotationLines {
    keepLine = "keepLine",
    separateLine = "separateLine"
}
export declare enum KeywordCasing {
    lower = "lower",
    upper = "upper",
    title = "title",
    'as-is' = "as-is"
}
declare type CdsEnums = AnnotationLines | KeywordCasing;
export declare type FormatOptionValue = boolean | number | CdsEnums | string;
export declare type OptionName<MM> = keyof MM;
export declare class MetaOption<MM> {
    readonly defaultValue: FormatOptionValue;
    readonly label: string;
    readonly description: string;
    readonly sampleCode: string;
    readonly parentDependency?: OptionName<MM>;
    readonly isInternal: boolean;
    readonly allowedEnumValues: any[];
    constructor(defaultValue: FormatOptionValue, label: string, description: string, sampleCode?: string, parentDependency?: OptionName<MM>, isInternal?: boolean);
    isValidValue(value: FormatOptionValue): boolean;
}
export declare class MetaOptionMap<MM> {
    [key: string]: MetaOption<MM>;
}
export declare class MetaModel<MM extends MetaOptionMap<MM>> {
    private metaOptions;
    private logger;
    constructor(metaOptions: MM, logger: Logger);
    getMetaOption(name: OptionName<MM>): MM[keyof MM];
    emptySet(sourceTag?: string): FormatOptionSet<MM>;
    getOptionNames(): Array<OptionName<MM>>;
    defaultSet(sourceTag?: string): FormatOptionSet<MM>;
}
export interface SchemaOption {
    label: string;
    type: 'boolean' | 'number' | 'string';
    description: string;
    default: any;
    sample: string;
    category: 'Alignment' | 'Other' | 'Whitespace';
    parentOption?: string;
    subOptions?: string[];
    enum?: string[];
}
export {};
