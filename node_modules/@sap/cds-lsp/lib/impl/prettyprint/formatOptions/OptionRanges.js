"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLOBAL = -1;
class OptionRanges {
    constructor(globalOptions, logger) {
        this.globalOptions = globalOptions;
        this.logger = logger;
        this.areasByOption = {};
        globalOptions.metaModel.getOptionNames().forEach(option => this.areasByOption[option] = []);
    }
    setLocallyFromString(option, valueString, startOffset) {
        var _a;
        let value;
        switch (valueString.toLowerCase()) {
            case 'true':
                value = true;
                break;
            case 'false':
                value = false;
                break;
            default:
                value = Number(valueString);
                if (isNaN(value)) {
                    value = valueString;
                }
        }
        const correctType = typeof this.globalOptions.metaModel.getMetaOption(option).defaultValue;
        const actualType = typeof value;
        if (actualType !== correctType) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.logError(`failed to set option ${option} = ${value} from offset ${startOffset}: invalid type ${actualType}: expected ${correctType}`);
            return;
        }
        this.setLocally(option, value, startOffset);
    }
    setLocally(option, value, startOffset) {
        var _a, _b;
        const areas = this.areasByOption[option];
        if (!areas) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.logError(`failed to set invalid option ${option} = ${value} from offset ${startOffset}`);
            return;
        }
        areas[startOffset] = value;
        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.logDebug(`set option ${option} = ${value} from offset ${startOffset}`);
    }
    resetLocally(option, startOffset) {
        var _a, _b;
        const areas = this.areasByOption[option];
        if (!areas) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.logError(`failed to reset invalid option ${option} from offset ${startOffset}`);
            return;
        }
        areas[startOffset] = null;
        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.logDebug(`reset option ${option} from offset ${startOffset}`);
    }
    setGlobally(option, value) {
        var _a;
        const result = this.globalOptions.setOption(option, value);
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.logDebug(`set option ${option} = ${value} globally`);
        return result;
    }
    getOption(option, offset) {
        var _a;
        function lastRelevant(result, value, start) {
            return start <= offset
                ? value
                : result;
        }
        return offset === exports.GLOBAL
            ? this.globalOptions.getOption(option)
            : (_a = this.areasByOption[option].reduce(lastRelevant, undefined)) !== null && _a !== void 0 ? _a : this.globalOptions.getOption(option);
    }
}
exports.OptionRanges = OptionRanges;
//# sourceMappingURL=OptionRanges.js.map