"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const OptionRanges_1 = require("./formatOptions/OptionRanges");
const Logger_1 = require("./util/Logger");
const StringUtil_1 = require("./util/StringUtil");
class GlobalContext {
    constructor(originalSource, globalFormatOptions, logger = new Logger_1.Logger()) {
        this.originalSource = originalSource;
        this.globalFormatOptions = globalFormatOptions;
        this.logger = logger;
        this.formattingStream = null;
        this.outputLines = [[]];
        this.lineNumbersForAlignmentId = new Map();
        this.lastProcessedToken = null;
        this.blockAlignmentStack = [];
        this._nextFreeBlockAlignmentId = 1;
        this._nextFreeAlignmentId = 1;
        this._knownAlignmentsById = {};
        this.formattingEnablements = [];
        this.instructionsDelayedTillNewline = new Map();
        this.removableNewlines = new Map();
        this.thingsDelayedTillToken = [];
        this.annotationTypes = {};
        this.alignmentIdAliases = {};
        this.alignmentIdAliasesSet = false;
        this.originalSourceLines = StringUtil_1.splitLines(originalSource).lines;
        this.formatOptions = new OptionRanges_1.OptionRanges(globalFormatOptions, logger);
    }
    get nextFreeAlignmentId() {
        return this._nextFreeAlignmentId++;
    }
    get nextFreeBlockAlignmentId() {
        return this._nextFreeBlockAlignmentId++;
    }
    lastBlockAlignment() {
        return this.blockAlignmentStack[this.blockAlignmentStack.length - 1];
    }
}
exports.GlobalContext = GlobalContext;
function calculateExclusionRanges(tokens, formattingEnablements) {
    const exclusionRanges = [];
    let currentExclusionRange;
    let formattingEnabled = true;
    formattingEnablements.forEach(fe => {
        if (!fe.enabled) {
            if (formattingEnabled) {
                formattingEnabled = false;
                currentExclusionRange = {
                    startToken: fe.token,
                    endToken: undefined,
                    includingWhitespaceBefore: false,
                    includingWhitespaceAfter: false
                };
                exclusionRanges.push(currentExclusionRange);
            }
        }
        else {
            if (!formattingEnabled && currentExclusionRange) {
                currentExclusionRange.endToken = fe.token;
                formattingEnabled = true;
            }
        }
    });
    if (currentExclusionRange && !currentExclusionRange.endToken) {
        currentExclusionRange.endToken = tokens[tokens.length - 1];
    }
    return exclusionRanges;
}
exports.calculateExclusionRanges = calculateExclusionRanges;
function calculateInclusionRanges(tokens, exclusionRanges, inclusionRange) {
    if (tokens.length === 0) {
        return [];
    }
    inclusionRange = inclusionRange || {
        startToken: tokens[0],
        endToken: tokens[tokens.length - 1],
        includingWhitespaceBefore: true,
        includingWhitespaceAfter: true
    };
    const included = Array(tokens.length).fill(true, inclusionRange.startToken.tokenIndex, inclusionRange.endToken.tokenIndex + 1);
    exclusionRanges.forEach(er => {
        included.fill(false, er.startToken.tokenIndex, er.endToken.tokenIndex + 1);
    });
    const inclusionRanges = [];
    for (let i = 0; i < included.length; i++) {
        const includedElement = included[i];
        if (includedElement) {
            const inclusionStart = i;
            while (included[i]) {
                i++;
            }
            const inclusionEnd = i - 1;
            inclusionRanges.push({
                startToken: tokens[inclusionStart],
                endToken: tokens[inclusionEnd],
                includingWhitespaceBefore: inclusionStart === inclusionRange.startToken.tokenIndex ? inclusionRange.includingWhitespaceBefore : true,
                includingWhitespaceAfter: inclusionEnd === inclusionRange.endToken.tokenIndex ? inclusionRange.includingWhitespaceAfter : true
            });
        }
    }
    return inclusionRanges;
}
exports.calculateInclusionRanges = calculateInclusionRanges;
//# sourceMappingURL=GlobalContext.js.map