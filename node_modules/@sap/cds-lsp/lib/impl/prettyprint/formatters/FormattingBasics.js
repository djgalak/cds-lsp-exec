"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockAlignment_1 = require("../BlockAlignment");
const BlockRules_1 = require("../BlockRules");
const CustomAlignment_1 = require("../CustomAlignment");
const PpRuleNode_1 = require("../PpRuleNode");
const PpRuleToken_1 = require("../PpRuleToken");
const TreeUtil_1 = require("../util/TreeUtil");
exports.WhitespaceAtLeastZero = '';
exports.WhitespaceAtLeast1 = ' ';
exports.WhitespaceAtLeast2 = '  ';
exports.WhitespaceOptionalSimple = '|';
exports.NewLine = '\n';
exports.IndentBy1FromOriginalBlockIndent = '+1';
exports.UnindentBy1FromOriginalBlockIndent = '-1';
exports.IndentResetToOriginalBlockIndent = '=';
exports.NewLineAndIndentBy1FromOriginalBlockIndent = '\n+1';
exports.NewLineAndIndentResetToOriginalBlockIndent = '\n=';
exports.NewLine2 = '\n\n';
class NodeFormatter {
    constructor(ruleNode, context) {
        this.ruleNode = ruleNode;
        this.context = context;
        this.enablementSwitch = undefined;
        this.ignoreComments = true;
        this.ignoreAnnotations = true;
        this.onlyTokenChildren = false;
        this.children = [];
        this.ruleName = undefined;
        this.applyAfterCurrentChild = [];
        this.applyBeforeNextChild = [];
        this.applyAfterNode = [];
        this.alignmentIdAliases = new Map();
        this.ruleName = ruleNode.ruleName;
        this.formattingRelevantRuleName = this.ruleName;
        this.firstTokenIndex = ruleNode.getStartTokenIndex();
        const parent = ruleNode.parent;
        if (parent) {
            this.parent = parent.getFormatter(context);
            if (this.parent && !this.parent.children.includes(this)) {
                this.parent.children.push(this);
            }
        }
        if (!context.alignmentIdAliasesSet) {
            context.alignmentIdAliasesSet = true;
            context.alignmentIdAliases.elementKey = (options, tokenIndex) => options.getOption('alignAfterKey', tokenIndex) ? undefined : 'elementName';
            context.alignmentIdAliases.exprL = (options, tokenIndex) => options.getOption('alignExpressionsAndConditions', tokenIndex) ? undefined : null;
            context.alignmentIdAliases.op = (options, tokenIndex) => options.getOption('alignExpressionsAndConditions', tokenIndex) ? undefined : null;
            context.alignmentIdAliases.exprR = (options, tokenIndex) => options.getOption('alignExpressionsAndConditions', tokenIndex) ? undefined : null;
            context.alignmentIdAliases.type = (options, tokenIndex) => options.getOption('alignTypes', tokenIndex) ? undefined : null;
            context.alignmentIdAliases[BlockRules_1.BlockRules.mixinElementDef + '.type'] = (options, tokenIndex) => options.getOption('alignTypesWithinBlock', tokenIndex) ? undefined : 'type';
            context.alignmentIdAliases[BlockRules_1.BlockRules.elementDefInner + '.type'] = (options, tokenIndex) => options.getOption('alignTypesWithinBlock', tokenIndex) ? undefined : 'type';
            context.alignmentIdAliases[BlockRules_1.BlockRules.selectItemDef + '.type'] = (options, tokenIndex) => options.getOption('alignTypesWithinBlock', tokenIndex) ? undefined : 'type';
            context.alignmentIdAliases[BlockRules_1.BlockRules.mixinElementDef + '.typeColon'] = (options, tokenIndex) => options.getOption('alignTypesWithinBlock', tokenIndex) ? undefined : 'type';
            context.alignmentIdAliases[BlockRules_1.BlockRules.elementDefInner + '.typeColon'] = (options, tokenIndex) => options.getOption('alignTypesWithinBlock', tokenIndex) ? undefined : 'type';
            context.alignmentIdAliases[BlockRules_1.BlockRules.selectItemDef + '.typeColon'] = (options, tokenIndex) => options.getOption('alignTypesWithinBlock', tokenIndex) ? undefined : 'type';
            context.alignmentIdAliases.elementAS = (options, tokenIndex) => options.getOption('alignAsInElements', tokenIndex) ? undefined : null;
            context.alignmentIdAliases.selectItemAS = (options, tokenIndex) => options.getOption('alignAsInSelectItems', tokenIndex) ? undefined : null;
            context.alignmentIdAliases.selectItemEffectiveName = (options, tokenIndex) => options.getOption('alignAsInSelectItems', tokenIndex) ? undefined : null;
        }
    }
    get id() {
        return this.ruleNode.id;
    }
    beforeNode(node) {
        try {
            return this.beforeNodeNoCache(node);
        }
        catch (error) {
            this.context.logger.logError(`formatting failed before node ${node.id}: ${error}`);
            return [];
        }
    }
    beforeNodeNoCache(node) {
        return [];
    }
    afterNode(node) {
        if (this.applyAfterNode.length) {
            const instructions = this.applyAfterNode;
            this.applyAfterNode = [];
            return instructions;
        }
        else {
            try {
                return this.afterNodeNoCache(node);
            }
            catch (error) {
                this.context.logger.logError(`formatting failed after node ${node.id}: ${error}`);
                return [];
            }
        }
    }
    afterNodeNoCache(node) {
        return [];
    }
    beforeChild(node, child, children) {
        if (this.applyBeforeNextChild.length) {
            const instructions = this.applyBeforeNextChild;
            this.applyBeforeNextChild = [];
            return instructions;
        }
        else {
            try {
                return this.beforeChildNoCache(node, child, children);
            }
            catch (error) {
                this.context.logger.logError(`formatting failed before child ${child.id}: ${error}`);
                return [];
            }
        }
    }
    beforeChildNoCache(node, child, children) {
        return [];
    }
    afterChild(node, child, children) {
        if (this.applyAfterCurrentChild.length) {
            const instructions = this.applyAfterCurrentChild;
            this.applyAfterCurrentChild = [];
            return instructions;
        }
        else {
            try {
                return this.afterChildNoCache(node, child, children);
            }
            catch (error) {
                this.context.logger.logError(`formatting failed after child ${child.id}: ${error}`);
                return [];
            }
        }
    }
    afterChildNoCache(node, child, children) {
        return [];
    }
    destroy() {
        if (this.parent) {
            const siblingIndex = this.parent.children.indexOf(this);
            if (siblingIndex > -1) {
                this.parent.children.splice(siblingIndex, 1);
            }
            this.parent = undefined;
        }
        this.children = [];
        if (this.ruleNode) {
            this.ruleNode.discardFormatter();
            this.ruleNode = undefined;
        }
    }
    startsWith(lowercaseLexem) {
        if (!this.ruleNode) {
            return false;
        }
        const firstToken = this.ruleNode.getFirstToken(TreeUtil_1.nonCommentNonAnnotation);
        if (!firstToken) {
            return false;
        }
        return lowerLexem(firstToken) === lowercaseLexem;
    }
    resolveGlobalAlignmentIdAliases(alignmentId, tokenIndex) {
        while (alignmentId && alignmentId in this.context.alignmentIdAliases) {
            const alias = this.context.alignmentIdAliases[alignmentId](this.context.formatOptions, tokenIndex);
            if (alias === undefined) {
                break;
            }
            alignmentId = alias;
        }
        return alignmentId;
    }
    resolveLocalAlignmentIdAliases(alignmentId) {
        while (alignmentId && this.alignmentIdAliases.has(alignmentId)) {
            alignmentId = this.alignmentIdAliases.get(alignmentId);
        }
        return alignmentId;
    }
    resolveAlignmentIdAliases(alignmentId, tokenIndex) {
        const localAlias = this.resolveLocalAlignmentIdAliases(alignmentId);
        return localAlias !== alignmentId
            ? localAlias
            : this.resolveGlobalAlignmentIdAliases(alignmentId, tokenIndex);
    }
    resolveAlignmentId(alignmentId, tokenIndex, generalize = false) {
        alignmentId = this.resolveAlignmentIdAliases(alignmentId, tokenIndex);
        if (!alignmentId) {
            return undefined;
        }
        return `${this.id}/${alignmentId}`;
    }
    getAlignment(alignmentId, tokenIndex, generalize) {
        const resolvedId = this.resolveAlignmentId(alignmentId, tokenIndex, generalize);
        if (!resolvedId) {
            return undefined;
        }
        return CustomAlignment_1.CustomAlignment.forId(this.context, resolvedId);
    }
    getBlockAlignment(alignmentId, tokenIndex) {
        const resolvedId = this.resolveAlignmentId(alignmentId, tokenIndex);
        if (!resolvedId) {
            return undefined;
        }
        return BlockAlignment_1.BlockAlignment.forId(this.context, resolvedId);
    }
    getAnnotationAlignment(token) {
        return undefined;
    }
    get formattingRelevantNode() {
        if (this._formattingRelevantNode === undefined) {
            if (this.ruleName === this.formattingRelevantRuleName) {
                this._formattingRelevantNode = this.ruleNode;
            }
            else {
                const ancestor = TreeUtil_1.getNearestAncestor(this, this.formattingRelevantRuleName);
                this._formattingRelevantNode = ancestor.ruleNode || null;
            }
        }
        return this._formattingRelevantNode;
    }
    isWithinFormattingScope(item, trigger) {
        const relevantNode = this.formattingRelevantNode;
        if (!relevantNode || !TreeUtil_1.hasDescendant(relevantNode, item)) {
            return false;
        }
        if (trigger !== 'after') {
            return true;
        }
        const token = item instanceof PpRuleToken_1.PpRuleToken ? item : item.getLastToken(TreeUtil_1.any);
        return token !== relevantNode.getLastToken(TreeUtil_1.any);
    }
}
exports.NodeFormatter = NodeFormatter;
function lowerLexem(child) {
    return child instanceof PpRuleToken_1.PpRuleToken && (child.isKeyword() || child.isOperator())
        ? child.getLowerLexem()
        : undefined;
}
exports.lowerLexem = lowerLexem;
function ruleName(child) {
    return child instanceof PpRuleNode_1.PpRuleNode
        ? child.ruleName
        : undefined;
}
exports.ruleName = ruleName;
//# sourceMappingURL=FormattingBasics.js.map