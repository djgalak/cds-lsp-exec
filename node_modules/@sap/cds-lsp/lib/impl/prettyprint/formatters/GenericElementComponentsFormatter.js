"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const BlockRules_1 = require("../BlockRules");
const PpRuleNode_1 = require("../PpRuleNode");
const TreeUtil_1 = require("../util/TreeUtil");
const FormattingBasics_1 = require("./FormattingBasics");
class GenericElementComponentsFormatter extends FormattingBasics_1.NodeFormatter {
    beforeChildNoCache(node, child, children) {
        const paddingIfAligned = (token) => this.context.formatOptions.getOption('whitespaceAroundAlignedOps', token.tokenIndex) ? ' ' : '';
        let alignmentKind;
        let padding;
        if (child instanceof PpRuleNode_1.PpRuleNode) {
            return [];
        }
        switch (FormattingBasics_1.lowerLexem(child)) {
            case ':':
                if (!this.context.formatOptions.getOption('alignColonsBeforeTypes', child.tokenIndex)) {
                    return [];
                }
                alignmentKind = 'typeColon';
                padding = paddingIfAligned(child);
                break;
            case 'array':
            case 'localized':
                if (!this.context.formatOptions.getOption('alignTypes', child.tokenIndex)) {
                    return [];
                }
                alignmentKind = 'type';
                break;
            case '=':
                if (!this.context.formatOptions.getOption('alignEqualsAfterTypes', child.tokenIndex)) {
                    return [];
                }
                alignmentKind = 'typeEquals';
                padding = paddingIfAligned(child);
                break;
            default:
                return [];
        }
        const statementAncestor = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.artifactDef, BlockRules_1.BlockRules.typeSpecSemi);
        assert(statementAncestor, 'missing statement ancestor');
        this.applyAfterCurrentChild.push(padding);
        const alignmentId = this.context.formatOptions.getOption('alignTypesWithinBlock', child.tokenIndex) &&
            [BlockRules_1.BlockRules.mixinElementDef, BlockRules_1.BlockRules.elementDefInner, BlockRules_1.BlockRules.selectItemDef].includes(this.ruleName)
            ? this.ruleName + '.' + alignmentKind
            : alignmentKind;
        return [
            padding,
            statementAncestor.getAlignment(alignmentId, child.tokenIndex)
        ];
    }
}
exports.GenericElementComponentsFormatter = GenericElementComponentsFormatter;
//# sourceMappingURL=GenericElementComponentsFormatter.js.map