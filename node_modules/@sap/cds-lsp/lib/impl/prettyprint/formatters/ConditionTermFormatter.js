"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("../BlockRules");
const PpRuleNode_1 = require("../PpRuleNode");
const TreeUtil_1 = require("../util/TreeUtil");
const FormattingBasics_1 = require("./FormattingBasics");
class ConditionTermFormatter extends FormattingBasics_1.NodeFormatter {
    constructor() {
        super(...arguments);
        this.startsWithExpr = false;
        this.startsWithBracket = false;
        this.hasFoundExprL = false;
        this.hasAlignedOp = false;
        this.alignWithinBlock = this.context.formatOptions.getOption('alignExprAndCondWithinBlock', this.firstTokenIndex);
    }
    get ancestor() {
        if (this._ancestor === undefined) {
            if (this.alignWithinBlock) {
                this._ancestor = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.condition);
                return this._ancestor;
            }
            this._ancestor = (TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.queryPrimary) || TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.queryExpression));
            if (this._ancestor) {
                return this._ancestor;
            }
            this._ancestor = (TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.entityDef));
        }
        return this._ancestor;
    }
    get expressionAncestor() {
        if (this._expressionAncestor === undefined) {
            this._expressionAncestor = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.expression);
        }
        return this._expressionAncestor;
    }
    beforeNodeNoCache(node) {
        let skip = false;
        const firstChild = node.children[0];
        if (firstChild instanceof PpRuleNode_1.PpRuleNode) {
            this.startsWithExpr = firstChild.ruleName === BlockRules_1.BlockRules.expression;
            this.startsWithBracket = this.startsWithExpr && firstChild.getFirstToken(TreeUtil_1.nonCommentNonAnnotation).getLowerLexem() === '(';
            skip = !this.startsWithExpr || this.startsWithBracket;
        }
        return skip || !this.ancestor
            ? ['°']
            : [];
    }
    beforeChildNoCache(node, child, children) {
        var _a, _b, _c;
        if (!this.hasFoundExprL) {
            this.hasFoundExprL = true;
            if (this.expressionAncestor && this.expressionAncestor.insideCase) {
                return [];
            }
            return [(_a = this.ancestor) === null || _a === void 0 ? void 0 : _a.getAlignment('exprL', child.getStartTokenIndex(), !this.alignWithinBlock)];
        }
        if (!this.hasAlignedOp) {
            this.hasAlignedOp = true;
            return [(_b = this.ancestor) === null || _b === void 0 ? void 0 : _b.getAlignment('op', child.getStartTokenIndex(), !this.alignWithinBlock)];
        }
        const lexem = FormattingBasics_1.lowerLexem(child);
        if (FormattingBasics_1.ruleName(child) === BlockRules_1.BlockRules.expression || (lexem === 'null' ||
            lexem === 'all' ||
            lexem === 'some' ||
            lexem === 'any')) {
            return [
                (_c = this.ancestor) === null || _c === void 0 ? void 0 : _c.getAlignment('exprR', child.getStartTokenIndex(), !this.alignWithinBlock),
                '°'
            ];
        }
        return [];
    }
}
exports.ConditionTermFormatter = ConditionTermFormatter;
//# sourceMappingURL=ConditionTermFormatter.js.map