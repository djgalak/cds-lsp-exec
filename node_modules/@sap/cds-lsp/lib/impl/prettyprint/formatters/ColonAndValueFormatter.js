"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AnnotationUtil_1 = require("../util/AnnotationUtil");
const TreeUtil_1 = require("../util/TreeUtil");
const FormattingBasics_1 = require("./FormattingBasics");
class ColonAndValueFormatter extends FormattingBasics_1.NodeFormatter {
    constructor(ruleNode, context, isAnnotation = false) {
        super(ruleNode, context);
        this.isAnnotation = isAnnotation;
    }
    get withinAnnotation() {
        if (this._withinAnnotation === undefined) {
            this._withinAnnotation = !!TreeUtil_1.getNearestAncestor(this, ...AnnotationUtil_1.annotationRules);
        }
        return this._withinAnnotation;
    }
    beforeColon(node, colonToken, scopeAncestor) {
        const alignColon = this.context.formatOptions.getOption('alignColonsInAnnotations', colonToken.tokenIndex) && (this.isAnnotation || this.withinAnnotation);
        const alignColonWithWhitespace = alignColon && this.context.formatOptions.getOption('whitespaceAroundAlignedOps', colonToken.tokenIndex);
        const prependBlank = alignColonWithWhitespace || this.context.formatOptions.getOption('whitespaceBeforeColon', colonToken.tokenIndex);
        const appendBlank = alignColonWithWhitespace;
        const instructions = [];
        if (prependBlank) {
            instructions.push(' ');
        }
        if (alignColon) {
            const annotationType = AnnotationUtil_1.getAndRememberAnnotationType(node, this.context);
            instructions.push(scopeAncestor === null || scopeAncestor === void 0 ? void 0 : scopeAncestor.getAlignment(`colon-${annotationType}-${TreeUtil_1.getAnnotationNumberInLine(node)}`, colonToken.tokenIndex));
        }
        if (appendBlank) {
            this.applyAfterCurrentChild.push(' ');
        }
        if (!scopeAncestor) {
            return instructions;
        }
        if (this.context.formatOptions.getOption('alignValuesInAnnotations', colonToken.tokenIndex)) {
            this.applyBeforeNextChild.push(scopeAncestor.getAlignment('value', colonToken.tokenIndex));
        }
        this.applyBeforeNextChild.push('Â°');
        return instructions;
    }
}
exports.ColonAndValueFormatter = ColonAndValueFormatter;
//# sourceMappingURL=ColonAndValueFormatter.js.map