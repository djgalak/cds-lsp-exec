import { Alignment } from '../Alignment';
import { BlockRule } from '../BlockRules';
import { CdsFormatOptions } from '../formatOptions/CdsFormatOptions';
import { OptionRanges } from '../formatOptions/OptionRanges';
import { FormattingTrigger } from '../GenericRuleRenderer';
import { GlobalContext } from '../GlobalContext';
import { PpChild } from '../PpBaseTypes';
import { PpRuleNode } from '../PpRuleNode';
import { PpRuleToken } from '../PpRuleToken';
declare type TWhitespaceAtLeastZero = '';
declare type TWhitespaceAtLeast1 = ' ';
declare type TWhitespaceAtLeast2 = '  ';
declare type TWhitespaceOptionalSimple = '|';
declare type TNewLine = '\n';
declare type TIndentBy1FromOriginalBlockIndent = '+1';
declare type TIndentBy2FromOriginalBlockIndent = '+2';
declare type TIndentBy1FromOriginalBlockIndentOnNextNewline = '/1';
declare type TIndentBy2FromOriginalBlockIndentOnNextNewline = '/2';
declare type TUnindentBy1FromOriginalBlockIndent = '-1';
declare type TIndentResetToOriginalBlockIndent = '=';
declare type TNewLineAndIndentBy1FromOriginalBlockIndent = '\n+1';
declare type TNewLineAndUnindentBy1FromOriginalBlockIndent = '\n-1';
declare type TNewLineAndIndentResetToOriginalBlockIndent = '\n=';
declare type TNewLine2 = '\n\n';
declare type TNextReversible = '^';
export declare type FormattingInstruction = TWhitespaceAtLeastZero | TWhitespaceAtLeast1 | TWhitespaceAtLeast2 | TWhitespaceOptionalSimple | TNewLine | TIndentBy1FromOriginalBlockIndent | TIndentBy2FromOriginalBlockIndent | TIndentBy1FromOriginalBlockIndentOnNextNewline | TIndentBy2FromOriginalBlockIndentOnNextNewline | TUnindentBy1FromOriginalBlockIndent | TIndentResetToOriginalBlockIndent | TNewLineAndIndentBy1FromOriginalBlockIndent | TNewLineAndUnindentBy1FromOriginalBlockIndent | TNewLineAndIndentResetToOriginalBlockIndent | TNewLine2 | TNextReversible;
export declare const WhitespaceAtLeastZero: TWhitespaceAtLeastZero;
export declare const WhitespaceAtLeast1: TWhitespaceAtLeast1;
export declare const WhitespaceAtLeast2: TWhitespaceAtLeast2;
export declare const WhitespaceOptionalSimple: TWhitespaceOptionalSimple;
export declare const NewLine: TNewLine;
export declare const IndentBy1FromOriginalBlockIndent = "+1";
export declare const UnindentBy1FromOriginalBlockIndent = "-1";
export declare const IndentResetToOriginalBlockIndent = "=";
export declare const NewLineAndIndentBy1FromOriginalBlockIndent: TNewLineAndIndentBy1FromOriginalBlockIndent;
export declare const NewLineAndIndentResetToOriginalBlockIndent: TNewLineAndIndentResetToOriginalBlockIndent;
export declare const NewLine2: TNewLine2;
export interface QueryState {
    selectFound: boolean;
    selectItemsFinished: boolean;
    groupBy: boolean;
    newlineBeforeChild: PpChild;
    lateFromMultipleSelectItems: boolean;
}
export interface QueryParseResult {
    fromInline: boolean;
    lateFrom: boolean;
    lateFromInline: boolean;
    lateFromNewLine: boolean;
    hasSelectItemWithKey: boolean;
    selectItemsAndAsterisks: number;
    openingBraceForSelectItemsInFirstLine: boolean;
    lastSelectItem: PpChild;
}
export declare type FormattingFinished = 'Â°';
export declare type FormattingInstructionOrAlignment = FormattingInstruction | Alignment | FormattingFinished;
export declare type AlignmentIdAliases = {
    [alignmentId: string]: (options: OptionRanges<CdsFormatOptions>, tokenIndex: number) => string;
};
export interface IFormatter {
    id: string;
    enablementSwitch: keyof CdsFormatOptions;
    ignoreComments: boolean;
    ignoreAnnotations: boolean;
    onlyTokenChildren: boolean;
    readonly firstTokenIndex: number;
    applyAfterCurrentChild: FormattingInstructionOrAlignment[];
    applyBeforeNextChild: FormattingInstructionOrAlignment[];
    applyAfterNode: FormattingInstructionOrAlignment[];
    beforeNode(node: PpRuleNode): FormattingInstructionOrAlignment[];
    afterNode(node: PpRuleNode): FormattingInstructionOrAlignment[];
    beforeChild(node: PpRuleNode, child: PpChild, children: PpChild[]): FormattingInstructionOrAlignment[];
    afterChild(node: PpRuleNode, child: PpChild, children: PpChild[]): FormattingInstructionOrAlignment[];
    parent: IFormatter;
    children: IFormatter[];
    ruleNode: PpRuleNode;
    ruleName: string;
    destroy(): void;
    startsWith(lowercaseLexem: string): boolean;
    getAlignment(alignmentId: string, tokenIndex: number, generalize?: boolean): Alignment;
    getBlockAlignment(alignmentId: string, tokenIndex: number): Alignment;
    getAnnotationAlignment(token: PpRuleToken): Alignment;
    isWithinFormattingScope(item: PpChild, trigger: FormattingTrigger): boolean;
}
export declare abstract class NodeFormatter implements IFormatter {
    ruleNode: PpRuleNode;
    protected context: GlobalContext;
    enablementSwitch: keyof CdsFormatOptions;
    ignoreComments: boolean;
    ignoreAnnotations: boolean;
    onlyTokenChildren: boolean;
    readonly firstTokenIndex: number;
    parent: IFormatter;
    children: IFormatter[];
    ruleName: string;
    protected formattingRelevantRuleName: string;
    private _formattingRelevantNode;
    applyAfterCurrentChild: FormattingInstructionOrAlignment[];
    applyBeforeNextChild: FormattingInstructionOrAlignment[];
    applyAfterNode: FormattingInstructionOrAlignment[];
    protected alignmentIdAliases: Map<string, string>;
    constructor(ruleNode: PpRuleNode, context: GlobalContext);
    get id(): string;
    beforeNode(node: PpRuleNode): FormattingInstructionOrAlignment[];
    protected beforeNodeNoCache(node: PpRuleNode): FormattingInstructionOrAlignment[];
    afterNode(node: PpRuleNode): FormattingInstructionOrAlignment[];
    protected afterNodeNoCache(node: PpRuleNode): FormattingInstructionOrAlignment[];
    beforeChild(node: PpRuleNode, child: PpChild, children: PpChild[]): FormattingInstructionOrAlignment[];
    protected beforeChildNoCache(node: PpRuleNode, child: PpChild, children: PpChild[]): FormattingInstructionOrAlignment[];
    afterChild(node: PpRuleNode, child: PpChild, children: PpChild[]): FormattingInstructionOrAlignment[];
    protected afterChildNoCache(node: PpRuleNode, child: PpChild, children: PpChild[]): FormattingInstructionOrAlignment[];
    destroy(): void;
    startsWith(lowercaseLexem: string): boolean;
    private resolveGlobalAlignmentIdAliases;
    protected resolveLocalAlignmentIdAliases(alignmentId: string): string;
    protected resolveAlignmentIdAliases(alignmentId: string, tokenIndex: number): string;
    protected resolveAlignmentId(alignmentId: string, tokenIndex: number, generalize?: boolean): string;
    getAlignment(alignmentId: string, tokenIndex: number, generalize?: boolean): Alignment;
    getBlockAlignment(alignmentId: string, tokenIndex: number): Alignment;
    getAnnotationAlignment(token: PpRuleToken): Alignment;
    private get formattingRelevantNode();
    isWithinFormattingScope(item: PpChild, trigger: FormattingTrigger): boolean;
}
export declare function lowerLexem(child: PpChild): string;
export declare function ruleName(child: PpChild): BlockRule;
export {};
