"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("../BlockRules");
const PpRuleNode_1 = require("../PpRuleNode");
const PpRuleToken_1 = require("../PpRuleToken");
const AnnotationUtil_1 = require("../util/AnnotationUtil");
const FormattingBasics_1 = require("./FormattingBasics");
class QueryParser {
    static hasKeyElement(node) {
        return node.children.reduce((result, child) => result || FormattingBasics_1.lowerLexem(child) === 'key', false);
    }
    static parseQuery(node) {
        let lateFrom;
        let hasMultiLineTableExpression = false;
        function complete(parseResult) {
            if (parseResult.openingBraceForSelectItemsInFirstLine !== false) {
                parseResult.openingBraceForSelectItemsInFirstLine = !lateFrom && !hasMultiLineTableExpression && parseResult.selectItemsAndAsterisks > 0;
            }
            return parseResult;
        }
        const result = {
            fromInline: undefined,
            lateFrom: undefined,
            lateFromInline: undefined,
            lateFromNewLine: undefined,
            hasSelectItemWithKey: false,
            selectItemsAndAsterisks: 0,
            openingBraceForSelectItemsInFirstLine: undefined,
            lastSelectItem: undefined
        };
        let selectItems = 0;
        let previousChild;
        let lexem;
        let previousLexem;
        for (const child of node.children) {
            previousChild = child;
            if (child instanceof PpRuleToken_1.PpRuleToken && child.isComment() || AnnotationUtil_1.isAnnotation(child)) {
                continue;
            }
            previousLexem = lexem;
            lexem = FormattingBasics_1.lowerLexem(child);
            switch (lexem) {
                case '*':
                    result.selectItemsAndAsterisks++;
                    continue;
                case '}':
                    if (result.selectItemsAndAsterisks) {
                        result.lastSelectItem = previousChild;
                        return complete(result);
                    }
                    continue;
                case 'from': {
                    lateFrom = previousLexem !== 'select';
                    result.lateFrom = lateFrom;
                    const singleItem = result.selectItemsAndAsterisks < 2 && selectItems < 2;
                    result.fromInline = !lateFrom || singleItem;
                    result.lateFromInline = lateFrom && singleItem;
                    result.lateFromNewLine = lateFrom && !singleItem;
                    if (lateFrom) {
                        result.openingBraceForSelectItemsInFirstLine = false;
                        result.lastSelectItem = previousChild;
                        return complete(result);
                    }
                    continue;
                }
                case 'mixin':
                case 'top':
                case 'all':
                case 'distinct':
                    result.openingBraceForSelectItemsInFirstLine = false;
            }
            if (child instanceof PpRuleNode_1.PpRuleNode) {
                switch (child.ruleName) {
                    case BlockRules_1.BlockRules.selectItemDef:
                        selectItems++;
                        result.selectItemsAndAsterisks++;
                        if (QueryParser.hasKeyElement(child)) {
                            result.hasSelectItemWithKey = true;
                        }
                        break;
                    case BlockRules_1.BlockRules.tableExpression:
                        hasMultiLineTableExpression = child.getTokens().some(token => ['join', '('].includes(FormattingBasics_1.lowerLexem(token)));
                }
            }
        }
        return complete(result);
    }
}
exports.QueryParser = QueryParser;
//# sourceMappingURL=QueryParser.js.map