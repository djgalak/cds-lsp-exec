"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const BlockRules_1 = require("../BlockRules");
const GenericRuleRenderer_1 = require("../GenericRuleRenderer");
const PpRuleNode_1 = require("../PpRuleNode");
const PpRuleToken_1 = require("../PpRuleToken");
const TreeUtil_1 = require("../util/TreeUtil");
const FormattingBasics_1 = require("./FormattingBasics");
const QueryParser_1 = require("./QueryParser");
class QueryFormatter extends FormattingBasics_1.NodeFormatter {
    constructor(node, context, topLevelQuery) {
        super(node, context);
        this.topLevelQuery = topLevelQuery;
        this.state = {
            selectFound: false,
            selectItemsFinished: false,
            groupBy: undefined,
            newlineBeforeChild: undefined,
            lateFromMultipleSelectItems: undefined
        };
        this.topLevelQuery = topLevelQuery || TreeUtil_1.getFarthestAncestor(this, BlockRules_1.BlockRules.queryExpression) || this;
        this.startsWithBracket = this.startsWith('(');
        this.formattingRelevantRuleName = BlockRules_1.BlockRules.queryExpression;
    }
    get hasUnindent() {
        if (this._hasUnindent === undefined) {
            const expression = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.queryExpression);
            this._hasUnindent = expression.ruleNode.getTokens().some(startsSetOperation);
        }
        return this._hasUnindent;
    }
    get firstIndentWidth() {
        if (!this._firstIndentWidth) {
            this._firstIndentWidth = this.hasUnindent ? 2 : 1;
        }
        return this._firstIndentWidth;
    }
    resolveLocalAlignmentIdAliases(alignmentId) {
        while (alignmentId && this.topLevelQuery.alignmentIdAliases.has(alignmentId)) {
            alignmentId = this.topLevelQuery.alignmentIdAliases.get(alignmentId);
        }
        return alignmentId;
    }
    resolveAlignmentId(alignmentId, tokenIndex, generalize = false) {
        alignmentId = this.resolveAlignmentIdAliases(alignmentId, tokenIndex);
        if (!alignmentId) {
            return undefined;
        }
        let prefix = this.id;
        if (generalize) {
            prefix = prefix.replace(/^[^@]+/, 'query');
        }
        return `${prefix}/${alignmentId}`;
    }
    beforeNodeNoCache(node) {
        const result = QueryParser_1.QueryParser.parseQuery(node);
        this.fromInline = result.fromInline;
        this.lateFrom = result.lateFrom;
        this.lateFromInline = result.lateFromInline;
        this.lateFromNewLine = result.lateFromNewLine;
        this.openingBraceForSelectItemsInFirstLine = result.openingBraceForSelectItemsInFirstLine;
        this.lastSelectItem = result.lastSelectItem;
        if (!this.lastSelectItem) {
            this.state.selectItemsFinished = true;
        }
        if (this.ruleName === BlockRules_1.BlockRules.queryPrimary && !result.hasSelectItemWithKey) {
            this.alignmentIdAliases.set('selectItemKey', undefined);
        }
        return [];
    }
    afterNodeNoCache(node) {
        if (this.firstSelectToken && !TreeUtil_1.firstLineBreakBetween(node.streamIndexFrom, node.streamIndexTo, this.context.formattingStream)) {
            const newlines = this.context.removableNewlines;
            for (const entry of newlines.entries()) {
                if (entry[1] === this.firstSelectToken) {
                    GenericRuleRenderer_1.GenericRuleRenderer.replaceNewlineWithWhitespace(entry[0], this.context);
                    break;
                }
            }
        }
        return [];
    }
    beforeChildNoCache(node, child, children) {
        if (child === this.lastSelectItem) {
            this.state.selectItemsFinished = true;
        }
        if (child instanceof PpRuleNode_1.PpRuleNode) {
            return [];
        }
        const lexem = FormattingBasics_1.lowerLexem(child);
        if (lexem === '*') {
            if (this.lateFrom) {
                if (this.lateFromInline) {
                    return [];
                }
                this.state.lateFromMultipleSelectItems = true;
                this.applyAfterCurrentChild.push('=');
                return [
                    '\n+1',
                    this.getBlockAlignment('selectItem', child.tokenIndex)
                ];
            }
            this.applyAfterCurrentChild.push('=');
            return [this.getBlockAlignment('selectItem', child.tokenIndex)];
        }
        if (!child.isKeyword()) {
            return [];
        }
        if (this.state.groupBy) {
            this.state.groupBy = false;
        }
        if (lexem === 'top') {
            this.state.newlineBeforeChild = TreeUtil_1.getNextSibling(TreeUtil_1.getNextSibling(child, TreeUtil_1.nonCommentNonAnnotation), TreeUtil_1.nonCommentNonAnnotation);
            return [];
        }
        if (child === this.state.newlineBeforeChild) {
            this.state.newlineBeforeChild = undefined;
            return ['\n'];
        }
        if (startsSetOperation(child)) {
            return ['\n-1'];
        }
        switch (lexem) {
            case 'select': {
                const isFirst = !this.topLevelQuery.state.selectFound;
                this.topLevelQuery.state.selectFound = true;
                const encompassingPrimary = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.queryPrimary);
                if (isFirst) {
                    if (encompassingPrimary && encompassingPrimary.startsWithBracket) {
                        return ['\n'];
                    }
                    if (this.context.formatOptions.getOption('selectInNewLine', child.tokenIndex)) {
                        this.topLevelQuery.firstSelectToken = child;
                        return [
                            '^',
                            '\n',
                            '+' + this.firstIndentWidth
                        ];
                    }
                    return this.openingBraceForSelectItemsInFirstLine && !this.hasUnindent
                        ? []
                        : [
                            '/' + this.firstIndentWidth
                        ];
                }
                break;
            }
            case 'from':
                if (this.fromInline) {
                    return [];
                }
                assert(this.state.lateFromMultipleSelectItems, 'unexpected state: FROM in new line with single SELECT item');
                return ['\n='];
            case 'into':
                this.state.newlineBeforeChild = TreeUtil_1.getNextSibling(child, TreeUtil_1.nonCommentNonAnnotation);
                break;
        }
        return [];
    }
    afterChildNoCache(node, child, children) {
        const instructions = [];
        if (child instanceof PpRuleNode_1.PpRuleNode) {
            return instructions;
        }
        const successor = child.getNextToken(TreeUtil_1.any);
        const lexem = FormattingBasics_1.lowerLexem(child);
        if (child.isKeyword()) {
            const predecessor = TreeUtil_1.getPreviousToken(child, TreeUtil_1.nonCommentNonAnnotation);
            if (lexem === 'by') {
                const preLex = FormattingBasics_1.lowerLexem(predecessor);
                this.state.groupBy = preLex === 'group';
                return instructions;
            }
            if (startsSetOperation(child) && !finishesSetOperation(successor) ||
                finishesSetOperation(child) && startsSetOperation(predecessor)) {
                if (this.context.formatOptions.getOption('selectInNewLine', child.tokenIndex)) {
                    instructions.push('\n');
                }
                instructions.push('=');
            }
        }
        else if (lexem === '*' && successor instanceof PpRuleToken_1.PpRuleToken && !successor.isOperator()) {
            instructions.push(' ');
        }
        return instructions;
    }
}
exports.QueryFormatter = QueryFormatter;
class QueryExpressionFormatter extends QueryFormatter {
}
exports.QueryExpressionFormatter = QueryExpressionFormatter;
class QueryTermFormatter extends QueryFormatter {
}
exports.QueryTermFormatter = QueryTermFormatter;
class QueryPrimaryFormatter extends QueryFormatter {
}
exports.QueryPrimaryFormatter = QueryPrimaryFormatter;
function startsSetOperation(thing) {
    if (!(thing instanceof PpRuleToken_1.PpRuleToken && thing.isKeyword())) {
        return false;
    }
    return [
        'union',
        'except',
        'minus',
        'intersect'
    ].includes(FormattingBasics_1.lowerLexem(thing));
}
function finishesSetOperation(thing) {
    if (!(thing instanceof PpRuleToken_1.PpRuleToken && thing.isKeyword())) {
        return false;
    }
    return [
        'distinct',
        'all'
    ].includes(FormattingBasics_1.lowerLexem(thing));
}
//# sourceMappingURL=QueryFormatter.js.map