"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const BlockRules_1 = require("../BlockRules");
const PpRuleNode_1 = require("../PpRuleNode");
const TreeUtil_1 = require("../util/TreeUtil");
const FormattingBasics_1 = require("./FormattingBasics");
class OrderBySpecFormatter extends FormattingBasics_1.NodeFormatter {
    get queryAncestor() {
        if (this._queryAncestor === undefined) {
            this._queryAncestor = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.queryExpression);
        }
        return this._queryAncestor;
    }
    beforeChildNoCache(node, child, children) {
        if (child instanceof PpRuleNode_1.PpRuleNode) {
            const childRule = child.ruleName;
            assert(childRule === BlockRules_1.BlockRules.expression, `unexpected child rule: ${childRule}`);
            const alignWithinBlock = this.context.formatOptions.getOption('alignExprAndCondWithinBlock', child.getStartTokenIndex());
            return [
                '\n',
                this.queryAncestor.getAlignment('exprL', child.getStartTokenIndex(), !alignWithinBlock)
            ];
        }
        const lexem = child.getLowerLexem();
        if (lexem === 'asc' || lexem === 'desc') {
            return [this.queryAncestor.getAlignment('sortOrder', child.tokenIndex)];
        }
        assert(lexem === 'nulls', `unexpected lexem: ${lexem}`);
        return [
            this.queryAncestor.getAlignment('nulls', child.tokenIndex),
            'Â°'
        ];
    }
}
exports.OrderBySpecFormatter = OrderBySpecFormatter;
//# sourceMappingURL=OrderBySpecFormatter.js.map