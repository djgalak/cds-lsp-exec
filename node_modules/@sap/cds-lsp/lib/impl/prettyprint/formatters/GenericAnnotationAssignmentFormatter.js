"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const BlockRules_1 = require("../BlockRules");
const AnnotationUtil_1 = require("../util/AnnotationUtil");
const TreeUtil_1 = require("../util/TreeUtil");
const ColonAndValueFormatter_1 = require("./ColonAndValueFormatter");
const FormattingBasics_1 = require("./FormattingBasics");
class GenericAnnotationAssignmentFormatter extends ColonAndValueFormatter_1.ColonAndValueFormatter {
    constructor(ruleNode, context) {
        super(ruleNode, context, true);
        this.alignmentScopes = [BlockRules_1.BlockRules.annotationAssignment_paren, BlockRules_1.BlockRules.entityDef, BlockRules_1.BlockRules.viewDef, BlockRules_1.BlockRules.typeDef, BlockRules_1.BlockRules.artifactDef];
    }
    get scopeAncestor() {
        if (this._scopeAncestor === undefined) {
            this._scopeAncestor = TreeUtil_1.getNearestAncestor(this, ...this.alignmentScopes);
        }
        return this._scopeAncestor;
    }
    beforeNodeNoCache(node) {
        var _a;
        if (node.ruleName === BlockRules_1.BlockRules.annotationAssignment_1) {
            return [];
        }
        assert(this.scopeAncestor, 'missing scope ancestor');
        if (AnnotationUtil_1.getAndRememberAnnotationType(node, this.context) === 'pre') {
            if (this.context.formatOptions.getOption('alignPreAnnotations', this.firstTokenIndex)) {
                return [this.scopeAncestor.getAlignment('annoAt-' + TreeUtil_1.getAnnotationNumberInLine(node), this.firstTokenIndex)];
            }
        }
        else if (this.context.formatOptions.getOption('alignPostAnnotations', node.getStartTokenIndex())) {
            const id = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.ruleName) === BlockRules_1.BlockRules.artifactDef
                ? 'annoAt-artif'
                : 'annoAt';
            return [this.scopeAncestor.getAlignment(id, this.firstTokenIndex)];
        }
        return [];
    }
    beforeChildNoCache(node, child, children) {
        if (FormattingBasics_1.lowerLexem(child) !== ':') {
            return [];
        }
        return this.beforeColon(node, child, this.scopeAncestor);
    }
}
exports.GenericAnnotationAssignmentFormatter = GenericAnnotationAssignmentFormatter;
//# sourceMappingURL=GenericAnnotationAssignmentFormatter.js.map