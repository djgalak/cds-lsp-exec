"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("../BlockRules");
const PpRuleToken_1 = require("../PpRuleToken");
const TreeUtil_1 = require("../util/TreeUtil");
const FormattingBasics_1 = require("./FormattingBasics");
class ExpressionFormatter extends FormattingBasics_1.NodeFormatter {
    constructor() {
        super(...arguments);
        this.insideCase = false;
        this.conditionAncestor = TreeUtil_1.getFarthestAncestor(this, BlockRules_1.BlockRules.condition);
        this.partOfCondition = this.parent.ruleName === BlockRules_1.BlockRules.conditionTerm;
        this.whenThenIndented = false;
    }
    get queryAncestor() {
        if (this._queryAncestor === undefined) {
            this._queryAncestor = TreeUtil_1.getNearestAncestor(this, BlockRules_1.BlockRules.queryPrimary);
        }
        return this._queryAncestor;
    }
    get skipNodeAlignment() {
        if (this._skipNodeAlignment === undefined) {
            this._skipNodeAlignment = this.partOfCondition || !(this.queryAncestor || this.conditionAncestor) || this.queryAncestor && !this.queryAncestor.state.groupBy;
        }
        return this._skipNodeAlignment;
    }
    beforeNodeNoCache(node) {
        const firstLexem = FormattingBasics_1.lowerLexem(node.getFirstToken(TreeUtil_1.nonCommentNonAnnotation));
        this.startsWithBracket = firstLexem === '(';
        this.startsWithCase = firstLexem === 'case';
        this.insideCase = this.insideCase || this.startsWithCase;
        if (!this.insideCase) {
            const firstAncestors = [this];
            for (const ancestor of TreeUtil_1.getAncestors(this, formatter => formatter.ruleNode.ruleName === BlockRules_1.BlockRules.expression)) {
                firstAncestors.push(ancestor);
                if (ancestor.startsWithCase) {
                    firstAncestors.forEach(ancestor => ancestor.insideCase = true);
                    break;
                }
            }
        }
        if (this.startsWithCase) {
            return [this.getBlockAlignment('case', this.firstTokenIndex)];
        }
        if (this.startsWithBracket && this.conditionAncestor) {
            const predecessor = TreeUtil_1.getPreviousToken(this.ruleNode, TreeUtil_1.nonCommentNonAnnotation);
            if ([
                'when',
                'and',
                'or',
                'in'
            ].includes(FormattingBasics_1.lowerLexem(predecessor))) {
                return [' '];
            }
            return [];
        }
        if (this.skipNodeAlignment || !this.queryAncestor) {
            return [];
        }
        const alignWithinBlock = this.context.formatOptions.getOption('alignExprAndCondWithinBlock', this.firstTokenIndex);
        return ['\n+1', this.queryAncestor.getAlignment('exprL', this.firstTokenIndex, !alignWithinBlock)];
    }
    afterNodeNoCache(node) {
        if (this.skipNodeAlignment) {
            return [];
        }
        if (this.queryAncestor) {
            return ['\n='];
        }
        return [];
    }
    beforeChildNoCache(node, child, children) {
        const lexem = FormattingBasics_1.lowerLexem(child);
        if (lexem === 'when') {
            if (this.whenThenIndented) {
                return ['\n='];
            }
            this.whenThenIndented = true;
            return ['\n+1'];
        }
        if (lexem === ')') {
            if (FormattingBasics_1.ruleName(TreeUtil_1.getPreviousSibling(child, TreeUtil_1.nonCommentNonAnnotation)) === BlockRules_1.BlockRules.queryExpression) {
                return [];
            }
            return [
                '\n',
                '='
            ];
        }
        return [];
    }
    afterChildNoCache(node, child, children) {
        if (FormattingBasics_1.lowerLexem(child) === '(') {
            if (FormattingBasics_1.ruleName(TreeUtil_1.getNextSibling(child, TreeUtil_1.nonCommentNonAnnotation)) === BlockRules_1.BlockRules.queryExpression) {
                const selectItemAlignment = !this.queryAncestor || this.queryAncestor.state.selectItemsFinished
                    ? undefined
                    : this.queryAncestor.getBlockAlignment('selectItem', child.getStartTokenIndex());
                return [
                    '\n',
                    selectItemAlignment,
                    '+1'
                ];
            }
            return [
                '\n',
                '+1'
            ];
        }
        if (FormattingBasics_1.ruleName(child) === BlockRules_1.BlockRules.queryExpression) {
            return ['\n='];
        }
        if (child instanceof PpRuleToken_1.PpRuleToken) {
            switch (FormattingBasics_1.lowerLexem(child)) {
                case '-':
                    if (child.isOperator() && child !== node.getFirstToken(TreeUtil_1.nonCommentNonAnnotation)) {
                        return [' '];
                    }
                    break;
                case 'end':
                    return ['='];
            }
        }
        return [];
    }
}
exports.ExpressionFormatter = ExpressionFormatter;
//# sourceMappingURL=ExpressionFormatter.js.map