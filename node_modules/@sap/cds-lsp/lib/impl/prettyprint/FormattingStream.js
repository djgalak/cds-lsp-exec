"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Alignment_1 = require("./Alignment");
const BlockAlignment_1 = require("./BlockAlignment");
const FormattingInstructions_1 = require("./FormattingInstructions");
const PpRuleToken_1 = require("./PpRuleToken");
const Ansi_1 = require("./util/Ansi");
const WhitespaceOrLinebreak = FormattingInstructions_1.FormatBase;
class FormattingStream {
    constructor(globalContext) {
        this.globalContext = globalContext;
        this.stream = [];
        this.lineNumber = 0;
        this.currentLineStartsAtIndex = 0;
        this.alignments = {};
        this.allAlignments = {};
    }
    append(x) {
        if (!x) {
            return;
        }
        const stream = this.stream;
        const aBlockAlignmentStack = this.globalContext.blockAlignmentStack;
        const line = this;
        const { logger } = this.globalContext;
        function mergedPush(thingToMerge) {
            function push(renderThing) {
                if (!line.hasTokens && (typeof renderThing === 'string' || renderThing instanceof PpRuleToken_1.PpRuleToken)) {
                    line.hasTokens = true;
                }
                try {
                    if (renderThing instanceof Alignment_1.Alignment) {
                        if (line.alignments[renderThing.id]) {
                            const tokens = stream.slice(line.currentLineStartsAtIndex);
                            const printedContext = context(tokens);
                            if (logger.isTracing('pp')) {
                                logger.logWarn(() => `Push: Same alignment twice in line ${line.lineNumber}', ignoring last one: ${renderThing}${printedContext}`);
                            }
                            return;
                        }
                        line.alignments[renderThing.id] = renderThing;
                        let cursor = renderThing;
                        while (cursor instanceof BlockAlignment_1.BlockAlignment) {
                            line.alignments[cursor.id] = cursor;
                            cursor = cursor.relativeAlignment;
                        }
                        line.hasAlignments = true;
                        let obscuringIds = line.allAlignments[renderThing.id];
                        if (!obscuringIds) {
                            obscuringIds = line.allAlignments[renderThing.id] = {};
                        }
                        const obscuringAlignments = Object.keys(line.alignments).map(key => line.alignments[key]);
                        for (const obscuringAlignment of obscuringAlignments) {
                            if (obscuringAlignment === renderThing) {
                                continue;
                            }
                            const obs2 = line.allAlignments[obscuringAlignment.id];
                            if (obs2 && obs2[renderThing.id]) {
                                const tokens = stream.slice(line.currentLineStartsAtIndex);
                                const printedContext = context(tokens);
                                if (logger.isTracing('pp')) {
                                    logger.logError(() => `Push: Deadlock in line ${line.lineNumber}', for prevention ignoring last one: ${renderThing}${printedContext}`);
                                }
                                return;
                            }
                            obscuringIds[obscuringAlignment.id] = obscuringAlignment;
                        }
                    }
                }
                catch (e) {
                    logger.logError(e);
                }
                if (renderThing instanceof PpRuleToken_1.PpRuleToken) {
                    const parent = renderThing.parent;
                    if (parent.streamIndexFrom === -1) {
                        parent.streamIndexFrom = stream.length;
                    }
                    parent.streamIndexTo = Math.max(parent.streamIndexTo, stream.length);
                }
                stream.push(renderThing);
                if (renderThing instanceof FormattingInstructions_1.LineBreak) {
                    line.hasTokens = false;
                    line.hasAlignments = false;
                    line.alignments = {};
                    line.lineNumber++;
                    line.currentLineStartsAtIndex = stream.length;
                }
            }
            function preventAlignmentConflicts() {
                let index = stream.length - 1;
                while (index > 0) {
                    const item = stream[index];
                    const before = index > 0 ? stream[index - 1] : null;
                    const visited = {};
                    if (before instanceof Alignment_1.Alignment) {
                        let swap = false;
                        let cursor = before.relativeAlignment;
                        while (cursor) {
                            visited[cursor.id] = true;
                            if (cursor === item) {
                                swap = true;
                                break;
                            }
                            cursor = cursor.relativeAlignment;
                            if (cursor && visited[cursor.id]) {
                                throw new Error('cycle in: ' + cursor.id + ' at ~' + (index - 1));
                            }
                        }
                        if (swap) {
                            logger.trace('pp', 'swapping: ', item.id, ' with: ', before.id, ' at ', index);
                            stream[index] = before;
                            stream[index - 1] = item;
                            if (--index > 0) {
                                continue;
                            }
                        }
                    }
                    break;
                }
            }
            const previousItem = stream[stream.length - 1];
            if (previousItem instanceof WhitespaceOrLinebreak && previousItem.constructor === thingToMerge.constructor) {
                if (thingToMerge instanceof FormattingInstructions_1.FormatBase && previousItem.merge(thingToMerge)) {
                    return;
                }
            }
            if (previousItem instanceof Alignment_1.Alignment) {
                if (thingToMerge === previousItem) {
                    if (logger.isTracing('pp')) {
                        logger.logInfo(() => `Line ${line.lineNumber}: ignoring duplicate (directly) previous alignment: ${thingToMerge}`);
                    }
                    return;
                }
                if (thingToMerge instanceof WhitespaceOrLinebreak) {
                    let beforeAlignment = null;
                    for (let i = 2; i < stream.length; i++) {
                        const previousI = stream[stream.length - i];
                        if (!(previousI instanceof Alignment_1.Alignment)) {
                            beforeAlignment = previousI;
                            break;
                        }
                    }
                    if (beforeAlignment && beforeAlignment instanceof WhitespaceOrLinebreak && beforeAlignment.constructor === thingToMerge.constructor) {
                        if (thingToMerge instanceof FormattingInstructions_1.LineBreak) {
                            if (logger.isTracing('pp')) {
                                logger.logWarn(() => `Line ${line.lineNumber}: merging '${thingToMerge}' over alignment: ${previousItem}`);
                            }
                        }
                        beforeAlignment.merge(thingToMerge);
                        return;
                    }
                    else if (thingToMerge instanceof FormattingInstructions_1.Whitespace) {
                        logger.logDebug(() => `Line ${line.lineNumber}: swapping ${JSON.stringify(previousItem)} and ${JSON.stringify(thingToMerge)}`);
                        stream.splice(stream.length - 1, 1, thingToMerge, previousItem);
                        return;
                    }
                }
            }
            if (!line.hasTokens && !line.hasAlignments && (typeof thingToMerge === 'string' || thingToMerge instanceof Alignment_1.Alignment || thingToMerge instanceof PpRuleToken_1.PpRuleToken)) {
                const currentBlockAlignment = aBlockAlignmentStack[aBlockAlignmentStack.length - 1];
                if (currentBlockAlignment) {
                    push(currentBlockAlignment);
                }
            }
            push(thingToMerge);
            if (thingToMerge instanceof Alignment_1.Alignment) {
                if (previousItem instanceof Alignment_1.Alignment) {
                    preventAlignmentConflicts();
                }
            }
        }
        if (x instanceof FormattingInstructions_1.Whitespace) {
            if (!line.hasTokens) {
                return;
            }
        }
        mergedPush(x);
    }
    trace() {
        const { logger } = this.globalContext;
        logger.trace('pp_stream', '~~~~~~~~~~ FormattingStream ~~~~~~~~~~');
        let s = '';
        this.stream.forEach(function (item) {
            if (item === '\n' || item instanceof FormattingInstructions_1.LineBreak) {
                if (item === '\n') {
                    s += Ansi_1.Ansi.CATEGORY + '\\n' + Ansi_1.Ansi.RESET;
                }
                else {
                    s += Ansi_1.Ansi.CATEGORY + item + Ansi_1.Ansi.RESET;
                }
                s += '\n';
            }
            else if (item instanceof BlockAlignment_1.BlockAlignment) {
                s += Ansi_1.Ansi_Foreground.GREEN + item + Ansi_1.Ansi.RESET;
            }
            else if (item instanceof Alignment_1.Alignment) {
                s += Ansi_1.Ansi_Foreground.DARKCYAN + item + Ansi_1.Ansi.RESET;
            }
            else if (item instanceof FormattingInstructions_1.Whitespace) {
                s += Ansi_1.Ansi.CATEGORY + item + Ansi_1.Ansi.RESET;
            }
            else if (item instanceof PpRuleToken_1.PpRuleToken && item.isComment()) {
                s += Ansi_1.Ansi.COMMENT_TOKEN + item + Ansi_1.Ansi.RESET;
            }
            else {
                s += Ansi_1.Ansi.TOKEN + item + Ansi_1.Ansi.RESET;
            }
        });
        logger.trace('pp_stream', s);
    }
}
exports.FormattingStream = FormattingStream;
function context(tokens) {
    const start = 0;
    const end = tokens.length;
    let result = '\n' + Ansi_1.Ansi.RESET;
    for (let i = start; i < end; i++) {
        result += ' ';
        let token = tokens[i];
        if (token instanceof Alignment_1.Alignment) {
            token = Ansi_1.Ansi.RULE + token + Ansi_1.Ansi.RESET;
        }
        else if (token instanceof FormattingInstructions_1.FormatBase) {
            token = Ansi_1.Ansi.CATEGORY + token + Ansi_1.Ansi.RESET;
        }
        else {
            token = Ansi_1.Ansi.TOKEN + token + Ansi_1.Ansi.RESET;
        }
        result += token;
    }
    return result;
}
//# sourceMappingURL=FormattingStream.js.map