import { Alignment } from './Alignment';
import { BlockAlignmentManager } from './BlockAlignmentManager';
import { FormattingInstructionOrAlignment } from './formatters/FormattingBasics';
import { FormatBase, LineBreak } from './FormattingInstructions';
import { GlobalContext } from './GlobalContext';
import { PpChild } from './PpBaseTypes';
import { PpRuleNode } from './PpRuleNode';
import { PpRuleToken } from './PpRuleToken';
import { IBlockRenderOptions } from './RenderOptions';
export declare type RenderThing = Alignment | PpRuleToken | FormatBase | string;
export declare type FormattingTrigger = 'before' | 'after' | 'between';
export declare class GenericRuleRenderer {
    blockRenderOptions: IBlockRenderOptions;
    private readonly globalContext;
    private _formattingProcessor;
    readonly blockAlignmentManager: BlockAlignmentManager;
    constructor(blockRenderOptions: IBlockRenderOptions, globalContext: GlobalContext);
    processInstructions(things: FormattingInstructionOrAlignment[], formattedObject: PpChild, trigger: FormattingTrigger, ignoreCache: boolean): void;
    private appendAlignments;
    processFormatting(sFormat: string, formattedObject: PpChild, trigger: FormattingTrigger, ignoreCache?: boolean): void;
    appendToStream(thing: RenderThing): void;
    ejectToken(tok: PpRuleToken, ignoreCache?: boolean): void;
    private prependDelayedThingsOnToken;
    onCommentToken(token: PpRuleToken): void;
    renderTokensAsIs(tokens: PpRuleToken[]): void;
    private formatAroundChild;
    renderNode(node: PpRuleNode, ignoreCache?: boolean): void;
    onToken(token: PpRuleToken, ignoreCache?: boolean): void;
    onBlock(node: PpRuleNode, ignoreCache?: boolean): void;
    beginBlock(blockTreeNode: PpRuleNode, ignoreCache?: boolean): LineBreakAtIndex;
    endBlock(blockTreeNode: PpRuleNode, originalLineBreak: LineBreakAtIndex, ignoreCache?: boolean): void;
    private isSingleLined;
    static replaceNewlineWithWhitespace(streamIndex: number, globalContext: GlobalContext): void;
}
declare class LineBreakAtIndex {
    lineBreak: LineBreak;
    index: number;
    constructor(lineBreak: LineBreak, index: number);
}
export {};
