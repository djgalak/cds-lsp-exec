"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BlockRules_1 = require("./BlockRules");
const FormattingBasics_1 = require("./formatters/FormattingBasics");
const NodeFormatters_1 = require("./formatters/NodeFormatters");
const GenericRuleRenderer_1 = require("./GenericRuleRenderer");
const PpBaseTypes_1 = require("./PpBaseTypes");
const PpRuleToken_1 = require("./PpRuleToken");
const RenderOptions_1 = require("./RenderOptions");
const Logger_1 = require("./util/Logger");
const TreeUtil_1 = require("./util/TreeUtil");
class PpRuleNode {
    constructor(context, ruleContext, parent) {
        this.context = context;
        this.ruleContext = ruleContext;
        this.parent = parent;
        this.children = [];
        this._descendantCounts = {};
        this._nTokens = 0;
        this.streamIndexFrom = -1;
        this.streamIndexTo = -1;
        this.ruleName = PpBaseTypes_1.getRuleName(ruleContext);
        this.blockRule = BlockRules_1.isBlockRule(this.ruleName) ? this.ruleName : undefined;
        this.id = `${this.ruleName}@${ruleContext.start.tokenIndex}`;
    }
    addToken(token) {
        this._nTokens++;
        if (token.isComment()) {
            for (let i = this.children.length - 1; i >= 0; i--) {
                const child = this.children[i];
                if (token.tokenIndex >= child.getStartTokenIndex()) {
                    this.children.splice(i + 1, 0, token);
                    return;
                }
            }
        }
        this.children.push(token);
    }
    addChild(child) {
        if (child instanceof PpRuleToken_1.PpRuleToken) {
            this.addToken(child);
        }
        else {
            this.children.push(child);
        }
    }
    reduceTree() {
        this.fixTree();
        this.children = PpBaseTypes_1.reduceChildren(this.children);
        this.ensureCorrectParent();
    }
    ensureCorrectParent() {
        this.children.forEach(child => {
            if (child instanceof PpRuleNode) {
                child.parent = this;
                child.ensureCorrectParent();
            }
            else {
                child.parent = this;
            }
        });
    }
    fixTree() {
        const indexOfParent = (ppToken) => ppToken.parent.children.findIndex(c => c === ppToken);
        const removeItem = (ppToken) => {
            const index = indexOfParent(ppToken);
            ppToken.parent.children.splice(index, 1);
        };
        const fixes = [];
        for (const child of this.children) {
            if (child instanceof PpRuleNode) {
                child.fixTree();
            }
            if (child instanceof PpRuleToken_1.PpRuleToken) {
                switch (FormattingBasics_1.lowerLexem(child)) {
                    case 'define': {
                        const nextRealToken = TreeUtil_1.getNextToken(child, TreeUtil_1.nonComment);
                        fixes.push(() => {
                            if (nextRealToken) {
                                const tokensToMove = this.context.allTokens.slice(child.tokenIndex, nextRealToken.tokenIndex);
                                tokensToMove.forEach(t => removeItem(t));
                                const index = indexOfParent(nextRealToken);
                                nextRealToken.parent.children.splice(index, 0, ...tokensToMove);
                            }
                        });
                        break;
                    }
                    case ',':
                    case ';': {
                        const previousRegularToken = TreeUtil_1.getPreviousToken(child, TreeUtil_1.nonComment);
                        fixes.push(() => {
                            if (previousRegularToken) {
                                const lastTokenToMove = child.followUpLineEndCommentToken || child;
                                const tokensToMove = this.context.allTokens.slice(previousRegularToken.tokenIndex + 1, lastTokenToMove.tokenIndex + 1);
                                tokensToMove.forEach(t => removeItem(t));
                                tokensToMove.forEach(t => t.parent = previousRegularToken.parent);
                                const index = indexOfParent(previousRegularToken);
                                previousRegularToken.parent.children.splice(index + 1, 0, ...tokensToMove);
                            }
                        });
                        break;
                    }
                }
            }
        }
        fixes.forEach(f => f());
    }
    toString() {
        if (!this.ruleContext) {
            return this.id;
        }
        const { start, stop } = this.ruleContext.getSourceInterval();
        const fixedStart = this.getStartTokenIndex();
        const fixedEnd = this.getEndTokenIndex();
        let fixedRange = '';
        if (fixedStart !== start || fixedEnd !== stop) {
            if (fixedEnd === -1) {
                fixedRange = ' [/]';
            }
            else {
                fixedRange = ' [' + fixedStart + '..' + fixedEnd + ']';
            }
        }
        return this.id + '..' + stop + fixedRange;
    }
    debugPrint(indentLevel = 0, colorProvider) {
        let output = PpBaseTypes_1.indent(3 * indentLevel);
        output += colorProvider.get(Logger_1.Color.BLOCK) + colorProvider.get(Logger_1.Color.RULE) + this.toString() + colorProvider.get(Logger_1.Color.RESET) + '\n';
        indentLevel++;
        let bIndent = true;
        for (const child of this.children) {
            if (child instanceof PpRuleToken_1.PpRuleToken) {
                const isComment = child.isComment();
                if (isComment) {
                    if (output.slice(-1) !== '\n') {
                        output += '\n';
                    }
                    output += PpBaseTypes_1.indent(3 * indentLevel);
                }
                else {
                    output += bIndent ? PpBaseTypes_1.indent(3 * indentLevel) : ' ';
                }
                output += child.debugPrint(colorProvider);
                if (isComment) {
                    output += '\n';
                }
                bIndent = isComment;
            }
            else {
                if (output.slice(-1) !== '\n') {
                    output += '\n';
                }
                output += child.debugPrint(indentLevel, colorProvider);
                bIndent = true;
            }
        }
        if (output.slice(-1) !== '\n') {
            output += '\n';
        }
        return output;
    }
    getFirstToken(predicate) {
        return TreeUtil_1.getFirstDescendant(this, child => (child instanceof PpRuleToken_1.PpRuleToken && predicate(child)
            || child instanceof PpRuleNode && child.children.length > 0));
    }
    getLastToken(predicate) {
        return TreeUtil_1.getLastDescendant(this, child => (child instanceof PpRuleToken_1.PpRuleToken && predicate(child)
            || child instanceof PpRuleNode && child.children.length > 0));
    }
    getStartTokenIndex() {
        const ruleToken = this.getFirstToken(TreeUtil_1.any);
        if (ruleToken) {
            return ruleToken.tokenIndex;
        }
        return this.ruleContext.start.tokenIndex;
    }
    getEndTokenIndex() {
        const ruleToken = this.getLastToken(TreeUtil_1.any);
        if (ruleToken) {
            return ruleToken.tokenIndex;
        }
        return -1;
    }
    getTokens() {
        return this.children.reduce(PpBaseTypes_1.getTokens, []);
    }
    getTokenList() {
        return this.context.allTokens;
    }
    countDescendants(ruleName) {
        let count = this._descendantCounts[ruleName];
        if (count === undefined) {
            count = TreeUtil_1.countDescendants(this, ruleName);
            this._descendantCounts[ruleName] = count;
        }
        return count;
    }
    getRuleRenderer(globalContext) {
        if (!this._ruleRenderer) {
            const renderOptions = RenderOptions_1.getBlockRenderOptions(globalContext.formatOptions, this);
            this._ruleRenderer = new GenericRuleRenderer_1.GenericRuleRenderer(renderOptions, globalContext);
        }
        return this._ruleRenderer;
    }
    getFormatter(globalContext) {
        if (!this._formatter) {
            this._formatter = NodeFormatters_1.NodeFormatterFactory.createFormatter(this, globalContext);
        }
        return this._formatter;
    }
    discardFormatter() {
        if (!this._formatter) {
            return;
        }
        this._formatter = undefined;
    }
    format(globalContext, ignoreCache = false) {
        const ruleRenderer = this.getRuleRenderer(globalContext);
        const blockAlignment = ruleRenderer.blockRenderOptions.blockAlignment;
        const originalLineBreak = ruleRenderer.beginBlock(this, ignoreCache);
        if (blockAlignment) {
            ruleRenderer.blockAlignmentManager.newBlockAlignment(this.id, 0, this);
        }
        ruleRenderer.renderNode(this, ignoreCache);
        if (blockAlignment) {
            ruleRenderer.blockAlignmentManager.popBlockAlignment(this.id);
        }
        ruleRenderer.endBlock(this, originalLineBreak, ignoreCache);
    }
}
exports.PpRuleNode = PpRuleNode;
//# sourceMappingURL=PpRuleNode.js.map