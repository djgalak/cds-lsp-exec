"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LspCls_1 = require("./LspCls");
const TracingInterfaces_1 = require("./TracingInterfaces");
const MB = 1024 * 1024;
const NS_PER_MS = 1000 * 1000;
function renderElapsed(ns) {
    const scales = [
        { unit: 'ns', factor: 1 },
        { unit: 'us', factor: 1e3 },
        { unit: 'ms', factor: 1e6 },
        { unit: 's', factor: 1e9 },
        { unit: 'min', factor: 6e10 },
    ];
    let uncolored;
    for (let i = 0; i < scales.length - 1; i++) {
        const scale = scales[i];
        const nextScale = scales[i + 1];
        if (ns < 2 * nextScale.factor) {
            uncolored = `${Math.round(ns / scale.factor)}~${scale.unit}`;
            break;
        }
    }
    if (!uncolored) {
        const lastScale = scales[scales.length - 1];
        const secondLastScale = scales[scales.length - 2];
        uncolored = `${Math.round(ns / lastScale.factor)}~${lastScale.unit} ${Math.round((ns % lastScale.factor) / secondLastScale.factor)}~${secondLastScale.unit}`;
    }
    return TracingInterfaces_1.highlight(uncolored, { errorPredicate: ns > 1000 * NS_PER_MS, warnPredicate: ns > 200 * NS_PER_MS, successPredicate: ns < 0 });
}
exports.renderElapsed = renderElapsed;
class Stopwatch {
    constructor(trackMemory = false) {
        this.trackMemory = trackMemory;
        this.startTime = process.hrtime();
        this.startCpu = process.cpuUsage();
        if (trackMemory) {
            this.garbageCollect();
            this.startMemory = process.memoryUsage();
        }
    }
    garbageCollect() {
        if (global.gc) {
            LspCls_1.currentTrace().tracer(TracingInterfaces_1.LspTraceComponent.UTIL).verbose('%%%% Triggering Garbage Collect %%%%');
            global.gc.call(global, true);
        }
    }
    get cpuUsage() {
        return process.cpuUsage(this.startCpu);
    }
    get elapsedNanos() {
        const NS_PER_SEC = 1e9;
        const elapsedNanos = process.hrtime(this.startTime);
        return elapsedNanos[0] * NS_PER_SEC + elapsedNanos[1];
    }
    get elapsed() {
        let memory = '';
        if (this.trackMemory) {
            this.garbageCollect();
            const stopMemory = process.memoryUsage();
            const unit = (x) => Math.abs(x) >= MB ? `${Math.round(x / MB)}~M` : `${Math.round(x / 1024)}~K`;
            const diff = (prop, onlyAbsolute = true) => {
                const stop = stopMemory[prop];
                let dif = 0;
                let difColored = '';
                if (!onlyAbsolute) {
                    dif = stop - this.startMemory[prop];
                    if (dif !== 0) {
                        const difUnit = unit(dif);
                        difColored = TracingInterfaces_1.highlight((dif > 0 ? '+' : '') + difUnit, { errorPredicate: dif > 20 * MB, successPredicate: dif < 0 });
                    }
                }
                const absColored = TracingInterfaces_1.highlight(unit(stop), { errorPredicate: stop > 200 * MB, warnPredicate: stop > 100 * MB });
                return `${prop}${difColored}=${absColored} `;
            };
            memory = `${diff('rss')}${diff('external')}${diff('heapUsed', false)}`;
        }
        return memory + renderElapsed(this.elapsedNanos);
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=Stopwatch.js.map