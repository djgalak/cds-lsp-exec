export declare enum ErrorKind {
    Thrown = "THROWN",
    Rejected = "REJECTED"
}
export declare enum LspTraceLevel {
    invalid = 0,
    OFF = 1,
    INFRASTRUCTURE = 2,
    ERROR = 3,
    WARNING = 4,
    INFO = 5,
    VERBOSE = 6,
    DEBUG = 7
}
export declare enum LspTraceComponent {
    ALL = "*",
    ADAPTER = "adapter",
    COMPLETION = "completion",
    DOCUMENTATION = "docs",
    FORMATTING = "format",
    MODEL = "model",
    REFACTOR = "refactor",
    REQUESTS = "requests",
    UTIL = "util",
    WORKSPACE = "workspace",
    FILES = "files"
}
export declare const MESSAGE_INCOMING = "---> ";
export declare const MESSAGE_OUTGOING = "<--- ";
export declare function highlight(s: string, { errorPredicate, warnPredicate, infoPredicate, successPredicate, debugPredicate }: {
    errorPredicate?: boolean;
    warnPredicate?: boolean;
    infoPredicate?: boolean;
    successPredicate?: boolean;
    debugPredicate?: boolean;
}): string;
export interface TracerAdapter {
    conditionalTrace(component: LspTraceComponent, level: LspTraceLevel, message: TraceMessage, x?: any): void;
    traceLevel(component: LspTraceComponent): LspTraceLevel;
    increaseIndent(): void;
    decreaseIndent(): void;
}
export interface FootprintCustomizer<T, R> {
    traceLevel?: LspTraceLevel;
    scope?: string;
    startScope?: string;
    endScope?: string;
    errorHandler?: (errorKind: ErrorKind, e: any, prefix: string, tracer: ITracer, thisArg: T) => any;
    argumentsRenderer?: (args: any[]) => string;
    resultRenderer?: (res: R, args: any[], thisArg: T) => any;
    trackMemory?: boolean;
    onlyTraceEnd?: boolean;
    finallyDo?: () => void;
}
export declare type ConfigLevel = 'off' | 'error' | 'warning' | 'info' | 'verbose' | 'debug';
export interface TraceComponent {
    name: LspTraceComponent;
    level: ConfigLevel;
}
export interface ITraceConfiguration {
    name?: string;
    folder?: string;
    components?: TraceComponent[];
    logfileCount?: number;
    logfileSize?: number;
}
export interface ITrace {
    configure(config: ITraceConfiguration): void;
    tracer(component: LspTraceComponent): ITracer;
    conditionalTrace(component: LspTraceComponent, level: LspTraceLevel, message: string, x?: any): void;
    doTraceToFile(message: string): void;
    renderMessage(level: LspTraceLevel, component: LspTraceComponent, message?: string, x?: any): string;
    addTelemetry(data: any): void;
}
export declare type TraceMessage = string | (() => string);
export interface ITracer {
    isTracing(level: LspTraceLevel): boolean;
    debug(m: TraceMessage, x?: any): void;
    verbose(m: TraceMessage, x?: any): void;
    info(m: TraceMessage, x?: any): void;
    warn(m: TraceMessage, x?: any): void;
    error(m: TraceMessage, x?: any): void;
    customizedFootprint<T, R>(action: Callback<R>, args: any[] | IArguments, customizer: FootprintCustomizer<T, R>, thisArg?: T): R;
    footprint<T, R>(scope: string, action: Callback<R>, args?: any[] | IArguments): R;
    tryCatch<R>(cb: () => R, traceLevel: LspTraceLevel, traceTitle: string, fallbackResult?: R): R | undefined;
}
export declare class NoTracer implements ITracer {
    private warnPrinted;
    private printWarning;
    isTracing(level: LspTraceLevel): boolean;
    private log;
    error(m: TraceMessage, x?: any): void;
    warn(m: TraceMessage, x?: any): void;
    info(m: TraceMessage, x?: any): void;
    verbose(m: TraceMessage, x?: any): void;
    debug(m: TraceMessage, x?: any): void;
    customizedFootprint<T, R>(action: Callback<R>, args: any[] | IArguments, customizer: FootprintCustomizer<T, R>, thisArg?: T): R;
    footprint<T, R>(scope: string, action: Callback<R>, args?: any[] | IArguments): R;
    tryCatch<R>(cb: () => R, traceLevel: LspTraceLevel, traceTitle: string, fallbackResult?: R): R | undefined;
}
export declare type Callback<U> = (...args: any[]) => U;
