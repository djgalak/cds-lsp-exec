"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Ansi_1 = require("./Ansi");
const LogFile_1 = require("./LogFile");
const LspCls_1 = require("./LspCls");
const Stringify_1 = require("./Stringify");
const Tracer_1 = require("./Tracer");
const TracingInterfaces_1 = require("./TracingInterfaces");
exports.LSP_TRACE_COMPONENT_MAX_LENGTH = Object.keys(TracingInterfaces_1.LspTraceComponent).reduce((max, curr) => Math.max(max, curr.length), 0);
class LspTrace {
    constructor() {
        this.logFile = new LogFile_1.LogFile();
        this.traceComponents = { '*': TracingInterfaces_1.LspTraceLevel.VERBOSE };
        this.tracers = new Map();
        this.lastTimeTraced = new Date().getTime();
    }
    get indentLevel() {
        return LspCls_1.currentFrame().frameScope.indentLevel;
    }
    increaseIndent() {
        LspCls_1.currentFrame().frameScope.indentLevel += 1;
    }
    decreaseIndent() {
        const frame = LspCls_1.currentFrame();
        frame.frameScope.indentLevel -= 1;
        if (frame.frameScope.indentLevel < 0) {
            frame.frameScope.indentLevel = 0;
            this.doTraceToFile('!!! Indent underflow');
        }
    }
    traceLevel(component) {
        return this.traceComponents[component] || this.traceComponents[TracingInterfaces_1.LspTraceComponent.ALL] || TracingInterfaces_1.LspTraceLevel.OFF;
    }
    get logfilename() {
        return this.logFile.logfilename;
    }
    configure(config) {
        if (config.name || config.folder) {
            if (config.folder) {
                this.logFile.folder = config.folder;
            }
            this.logFile.rename(config.name);
        }
        if (config.components) {
            let trace = Object.create(null);
            if (Array.isArray(config.components)) {
                config.components.forEach(cat => {
                    const component = cat.name;
                    if (component === TracingInterfaces_1.LspTraceComponent.ALL) {
                        trace = Object.create(null);
                    }
                    trace[component] = LspTrace.toTraceLevel(cat.level);
                });
            }
            const previousLevel = this.traceLevel(TracingInterfaces_1.LspTraceComponent.UTIL);
            this.traceComponents = trace;
            const effectiveLevel = Math.max(previousLevel, this.traceLevel(TracingInterfaces_1.LspTraceComponent.UTIL));
            if (effectiveLevel >= TracingInterfaces_1.LspTraceLevel.INFRASTRUCTURE) {
                this.doTrace(TracingInterfaces_1.LspTraceLevel.INFRASTRUCTURE, TracingInterfaces_1.LspTraceComponent.UTIL, 'New trace configuration: ');
                for (const key of Object.keys(trace)) {
                    this.doTrace(TracingInterfaces_1.LspTraceLevel.INFRASTRUCTURE, TracingInterfaces_1.LspTraceComponent.UTIL, `   ${key} = ${TracingInterfaces_1.LspTraceLevel[trace[key]]}`);
                }
            }
            this.logFile.maxFileSize = config.logfileSize || LogFile_1.LogFile.DEFAULT_MAX_FILE_SIZE;
            this.logFile.numberOfFiles = config.logfileCount || LogFile_1.LogFile.DEFAULT_NUMBER_OF_FILES;
            this.conditionalTrace(TracingInterfaces_1.LspTraceComponent.UTIL, TracingInterfaces_1.LspTraceLevel.INFRASTRUCTURE, `(current logs in ${this.logFile.logfilename})`);
        }
        return this;
    }
    setConnection(connection) {
        this._connection = connection;
    }
    tracer(component) {
        let tracer = this.tracers.get(component);
        if (!tracer) {
            tracer = new Tracer_1.Tracer(component, {
                conditionalTrace: (comp, level, message, x) => this.conditionalTrace(comp, level, message, x),
                traceLevel: (comp) => this.traceLevel(comp),
                decreaseIndent: () => this.decreaseIndent(),
                increaseIndent: () => this.increaseIndent()
            });
            this.tracers.set(component, tracer);
        }
        return tracer;
    }
    conditionalTrace(component, level, message, x) {
        if (this.traceLevel(component) >= level) {
            this.doTrace(level, component, message, x);
        }
    }
    doTrace(level, component, message, x) {
        this.doTraceMessage(this.renderMessage(level, component, message, x));
    }
    renderMessage(level, component, traceMessage = '', x) {
        const message = typeof traceMessage === 'function' ? traceMessage() : traceMessage;
        const colorize = (s, color) => {
            if (!color || !color.length) {
                return s;
            }
            return `${color}${s}${Ansi_1.Ansi.RESET}`;
        };
        const colorizedTime = () => {
            const date = new Date();
            const currentTime = date.getTime();
            const between = currentTime - this.lastTimeTraced;
            this.lastTimeTraced = currentTime;
            const time = date.toISOString();
            if (component === TracingInterfaces_1.LspTraceComponent.REQUESTS) {
                if (message.startsWith(TracingInterfaces_1.MESSAGE_INCOMING)) {
                    return colorize(time, Ansi_1.Ansi.REQUEST_FROM_SERVER);
                }
                else if (message.includes(TracingInterfaces_1.MESSAGE_OUTGOING)) {
                    return colorize(time, Ansi_1.Ansi.RESPONSE_TO_CLIENT);
                }
            }
            return TracingInterfaces_1.highlight(time, { errorPredicate: between > 5000 });
        };
        const colorizedLevel = () => {
            switch (level) {
                case TracingInterfaces_1.LspTraceLevel.OFF: return '[/]';
                case TracingInterfaces_1.LspTraceLevel.INFRASTRUCTURE: return colorize('[:]', Ansi_1.Ansi.Foreground.MAGENTA);
                case TracingInterfaces_1.LspTraceLevel.ERROR: return colorize('[E]', Ansi_1.Ansi.ERROR);
                case TracingInterfaces_1.LspTraceLevel.WARNING: return colorize('[w]', Ansi_1.Ansi.WARN);
                case TracingInterfaces_1.LspTraceLevel.INFO: return colorize('[_]', Ansi_1.Ansi.INFO);
                case TracingInterfaces_1.LspTraceLevel.VERBOSE: return '   ';
                case TracingInterfaces_1.LspTraceLevel.DEBUG: return colorize(' \xb7 ', Ansi_1.Ansi.Foreground.DARKGREY);
                default: return '???';
            }
        };
        const colorizedContext = () => {
            const renderedComponent = `{${component}}`.padEnd(exports.LSP_TRACE_COMPONENT_MAX_LENGTH + 2);
            const maxRequestName = 31;
            const { name, requestNumber = -1 } = LspCls_1.currentFrame().requestScope;
            const reqName = TracingInterfaces_1.highlight(name.padEnd(maxRequestName), { warnPredicate: name.startsWith('@') });
            return `${requestNumber.toString().padStart(5)}:${reqName} ${colorizedLevel()} ${renderedComponent}`;
        };
        const indent = ''.padEnd(this.indentLevel * 3);
        const prefix = `${colorizedTime()} ${colorizedContext()} ${indent}`;
        const colorizedMessage = () => {
            let suffix = `${message} ${typeof x === 'string' ? x : Stringify_1.stringifyJson(x, '')}`;
            if (suffix.includes('\n')) {
                const prefixIndent = ' '.repeat(prefix.length);
                const appendIndented = (sum, line, i) => `${sum}${i > 0 ? prefixIndent : ''}${line}\n`;
                suffix = suffix.split(/\r?\n/g).reduce(appendIndented, '');
            }
            return TracingInterfaces_1.highlight(suffix, { errorPredicate: level === TracingInterfaces_1.LspTraceLevel.ERROR, warnPredicate: level === TracingInterfaces_1.LspTraceLevel.WARNING, infoPredicate: level === TracingInterfaces_1.LspTraceLevel.INFO, debugPredicate: level === TracingInterfaces_1.LspTraceLevel.DEBUG });
        };
        return `${prefix}${colorizedMessage()}`;
    }
    doTraceMessage(msg) {
        this.doTraceToFile(msg);
    }
    doTraceToFile(message) {
        if (this.logFile) {
            this.logFile.append(message);
        }
    }
    addTelemetry(data) {
        if (this._connection) {
            this._connection.telemetry.logEvent(data);
        }
    }
    static toTraceLevel(configLevel) {
        switch (configLevel) {
            case 'off': return TracingInterfaces_1.LspTraceLevel.OFF;
            case 'error': return TracingInterfaces_1.LspTraceLevel.ERROR;
            case 'warning': return TracingInterfaces_1.LspTraceLevel.WARNING;
            case 'info': return TracingInterfaces_1.LspTraceLevel.INFO;
            case 'verbose': return TracingInterfaces_1.LspTraceLevel.VERBOSE;
            case 'debug': return TracingInterfaces_1.LspTraceLevel.DEBUG;
            default: return TracingInterfaces_1.LspTraceLevel.OFF;
        }
    }
}
exports.LspTrace = LspTrace;
//# sourceMappingURL=LspTrace.js.map