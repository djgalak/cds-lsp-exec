"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const cds_compiler_1 = require("@sap/cds-compiler");
const MEMORY_SIZES = ['bytes', 'KB', 'MB', 'GB', 'TB'];
class LspStats {
    healthStats() {
        const cpuUsage = process.cpuUsage();
        const memoryUsage = process.memoryUsage();
        const uptimeSeconds = process.uptime();
        const lastComp = this.lastUsedCompiler
            ? {
                'cds-compiler': this.lastUsedCompiler.version(),
                'compiler-location': this.lastUsedCompiler.__logicalLocation,
            }
            : {};
        return {
            health: {
                'ls-uptime': `${Math.trunc(uptimeSeconds / 3600)}h ${Math.trunc(uptimeSeconds / 60 % 60)}m ${Math.trunc(uptimeSeconds % 60)}s`,
                'cpu.usage.user': `${cpuUsage.user / 1000000}s`,
                'cpu.usage.system': `${cpuUsage.system / 1000000}s`,
                'memory.occupied': `${formatSize(memoryUsage.rss, MEMORY_SIZES, 1024)}`,
                'memory.heap.used': `${formatSize(memoryUsage.heapUsed, MEMORY_SIZES, 1024)}`,
                'memory.heap.total': `${formatSize(memoryUsage.heapTotal, MEMORY_SIZES, 1024)}`,
                'avg.machine.load': `${os.loadavg()} (1, 5, 15min)`
            },
            version: {
                'cds-lsp': cdsLspVersion(),
                'built': builtTime(),
                ...lastComp
            }
        };
    }
    static processStats() {
        const ppid = process.ppid;
        return {
            statName: 'process',
            stats: {
                'pid': `${process.pid}   ${ppid ? '(ppid: ' + ppid + ')' : ''}`,
                'args': process.argv,
                'cds-lsp': cdsLspVersion(),
                'built': builtTime(),
                'cwd': process.cwd(),
                'argv0': process.argv0,
                'execPath': process.execPath,
                'execArgv': process.execArgv,
                'title': process.title
            }
        };
    }
    static nodeStats() {
        return {
            statName: 'node',
            stats: {
                'node ver': process.version,
                'source': (process.release || Object.create(null)).sourceUrl,
                'procarch': `${process.platform} ${process.arch}`
            }
        };
    }
    static compilerStats() {
        return {
            statName: 'compiler',
            stats: {
                'cds-compiler': cds_compiler_1.version()
            }
        };
    }
    static platformStats() {
        const eol = os.EOL;
        let eolhex = '';
        for (let i = 0; i < eol.length; i++) {
            eolhex += `x0${eol.charCodeAt(i).toString(16)} `;
        }
        return {
            statName: 'platform',
            stats: {
                'os': `${os.type()} ${os.release()} ${os.platform()} ${os.arch()} ${os.endianness()}`,
                'host': os.hostname(),
                'user': os.userInfo().username,
                'home': os.homedir(),
                'tmp': os.tmpdir(),
                'eol': eolhex,
                'path sep': path.sep
            }
        };
    }
    static machineStats() {
        const cpus = os.cpus();
        return {
            statName: 'machine',
            stats: {
                'CPU(s)': `${cpus.length}x ${cpus[0].model} @${cpus[0].speed}`,
                'memory': `${formatSize(os.freemem(), MEMORY_SIZES, 1024)} free / ${formatSize(os.totalmem(), MEMORY_SIZES, 1024)} total`,
                'up since': `${new Date(Date.now() - os.uptime() * 1000)}`,
                'avg load': `${os.loadavg()} (1, 5, 15min)`
            }
        };
    }
    static processEnvironmentStats() {
        const collator = new Intl.Collator('en');
        return {
            statName: 'process environment',
            stats: Object.keys(process.env)
                .sort(collator.compare)
                .reduce((res, k) => { var _a; res[k] = (_a = process.env[k]) !== null && _a !== void 0 ? _a : ''; return res; }, {})
        };
    }
}
exports.LspStats = LspStats;
function traceStats(stats) {
    let s = '\n\t';
    s += `--- ${stats.statName}\n\t`;
    const indentSize = Object.keys(stats.stats).reduce((indent, stat) => Math.max(indent, stat.length), 0);
    const pad = new Array(1 + indentSize).join(' ');
    entries(stats.stats).forEach(([prop, value]) => {
        if (Array.isArray(value)) {
            s += `          ${prop}:\n\t`;
            value.forEach(val => {
                s += `          ${pad}  ${val}\n\t`;
            });
        }
        else {
            s += `          ${prop}:${pad.slice(prop.length)} ${value}\n\t`;
        }
    });
    return s;
}
exports.traceStats = traceStats;
function formatSize(n, units = [], divider = 1000) {
    let unitIndex;
    if (units.length === 0) {
        units = [''];
    }
    for (unitIndex = 0; n > 2000 && units.length > unitIndex + 1; unitIndex++) {
        n /= divider;
    }
    return n.toFixed(1) + units[unitIndex];
}
function builtTime() {
    try {
        return fs.lstatSync(__filename).mtime.toUTCString();
    }
    catch (e) {
        return `Failed to determine (${e})`;
    }
}
function cdsLspVersion() {
    try {
        return require('../../../../package.json').version;
    }
    catch (e) {
        return `Failed to determine (${e})`;
    }
}
function entries(obj) {
    if (!obj) {
        return [];
    }
    return Object.keys(obj).map(key => [key, obj[key]]);
}
exports.entries = entries;
//# sourceMappingURL=LspStats.js.map