"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stopwatch_1 = require("./Stopwatch");
const Stringify_1 = require("./Stringify");
const TracingInterfaces_1 = require("./TracingInterfaces");
class Tracer {
    constructor(component, tracerAdapter) {
        this.component = component;
        this.tracerAdapter = tracerAdapter;
    }
    isTracing(level) {
        return this.tracerAdapter.traceLevel(this.component) >= level;
    }
    debug(m, x) {
        this.tracerAdapter.conditionalTrace(this.component, TracingInterfaces_1.LspTraceLevel.DEBUG, m, x);
    }
    verbose(m, x) {
        this.tracerAdapter.conditionalTrace(this.component, TracingInterfaces_1.LspTraceLevel.VERBOSE, m, x);
    }
    info(m, x) {
        this.tracerAdapter.conditionalTrace(this.component, TracingInterfaces_1.LspTraceLevel.INFO, m, x);
    }
    warn(m, x) {
        this.tracerAdapter.conditionalTrace(this.component, TracingInterfaces_1.LspTraceLevel.WARNING, m, x);
    }
    error(m, x) {
        this.tracerAdapter.conditionalTrace(this.component, TracingInterfaces_1.LspTraceLevel.ERROR, m, x);
    }
    footprint(scope, action, args) {
        return this.customizedFootprint(action, args, { scope, onlyTraceEnd: true });
    }
    customizedFootprint(action, args = [], customizerOrScope = {}, target) {
        const customizer = (typeof customizerOrScope === 'string')
            ? { scope: customizerOrScope }
            : customizerOrScope;
        const UNKNOWN = '<unknown>';
        const beginScope = customizer.startScope || customizer.scope || UNKNOWN;
        const endScope = customizer.endScope || customizer.scope || UNKNOWN;
        const traceLevel = customizer.traceLevel !== undefined
            ? customizer.traceLevel
            : this.tracerAdapter.traceLevel(this.component);
        const doTrace = traceLevel >= TracingInterfaces_1.LspTraceLevel.INFO;
        const verbose = traceLevel >= TracingInterfaces_1.LspTraceLevel.VERBOSE;
        const resultRenderer = customizer.resultRenderer || ((res) => res);
        const argsRenderer = customizer.argumentsRenderer || function renderArgs(_args) {
            if (verbose) {
                const stringifiedArgs = [];
                for (const arg of _args) {
                    stringifiedArgs.push(Stringify_1.stringifyJson(arg));
                }
                const longResult = stringifiedArgs.reduce((sum, curr) => sum + curr.length, 0) > 200;
                return stringifiedArgs.join(longResult ? ',\n' : ', ');
            }
            return '';
        };
        const finallyDo = customizer.finallyDo || (() => { });
        const stopwatch = new Stopwatch_1.Stopwatch(customizer.trackMemory);
        try {
            if (doTrace && !customizer.onlyTraceEnd) {
                this.info(() => `${beginScope} ${verbose ? '(' + argsRenderer(args) + ')' : ''} {`);
            }
            this.tracerAdapter.increaseIndent();
            const result = action(...args);
            const anyRes = result;
            if (anyRes && anyRes.then) {
                this.tracerAdapter.decreaseIndent();
                return anyRes.then((res) => {
                    this.tracerAdapter.decreaseIndent();
                    if (doTrace) {
                        this.info(() => `}_${endScope} [${stopwatch.elapsed}] ${verbose ? ' => ' : ''}`, resultRenderer(res, args, target));
                    }
                    finallyDo();
                    return res;
                }).catch((e) => {
                    this.tracerAdapter.decreaseIndent();
                    const errorKind = TracingInterfaces_1.ErrorKind.Rejected;
                    const prefix = `} ${errorKind} ${endScope} [${stopwatch.elapsed}]`;
                    const errorHandler = customizer.errorHandler || ((kind, err, pref) => {
                        this.error(`${pref} => ${err && err.stack || err}`);
                        throw e;
                    });
                    try {
                        return errorHandler(errorKind, e, prefix, this, target);
                    }
                    finally {
                        finallyDo();
                    }
                });
            }
            else {
                this.tracerAdapter.decreaseIndent();
                if (doTrace) {
                    this.info(() => `} ${endScope} [${stopwatch.elapsed}] ${verbose ? ' => ' : ''}`, resultRenderer(result, args, target));
                }
            }
            return result;
        }
        catch (e) {
            this.tracerAdapter.decreaseIndent();
            const errorKind = TracingInterfaces_1.ErrorKind.Thrown;
            const prefix = `} ${errorKind} ${endScope} [${stopwatch.elapsed}]`;
            const errorHandler = customizer.errorHandler || ((kind, err, pref) => {
                this.error(`${pref} => ${err.stack || err}`);
                throw e;
            });
            return errorHandler(errorKind, e, prefix, this, target);
        }
        finally {
            finallyDo();
        }
    }
    conditionalTrace(component, level, message, x) {
        this.tracerAdapter.conditionalTrace(component, level, message, x);
    }
    tryCatch(cb, traceLevel, traceTitle, fallbackResult) {
        try {
            return cb();
        }
        catch (e) {
            traceTitle = typeof traceTitle === 'string' ? traceTitle : traceTitle();
            this.conditionalTrace(this.component, traceLevel, `Failed: ${traceTitle}:
${e.stack || e}`);
        }
        return fallbackResult;
    }
}
exports.Tracer = Tracer;
//# sourceMappingURL=Tracer.js.map