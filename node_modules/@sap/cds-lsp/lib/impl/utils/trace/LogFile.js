"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const Ansi_1 = require("./Ansi");
const LspStats_1 = require("./LspStats");
let nextFreeLogFileNumber = 1;
class LogFile {
    constructor(logId = `${process.pid}_${nextFreeLogFileNumber++}`) {
        this.fileDescriptor = 0;
        this.currentFileNumber = 0;
        this._maxFileSize = LogFile.DEFAULT_MAX_FILE_SIZE;
        this._numberOfFiles = LogFile.DEFAULT_NUMBER_OF_FILES;
        this.onceRenamed = false;
        this.currentFileCount = 0;
        this.init(logId);
    }
    get numberOfFiles() {
        return this._numberOfFiles;
    }
    set numberOfFiles(value) {
        if (value !== undefined) {
            this._numberOfFiles = Math.max(2, value);
        }
    }
    get maxFileSize() {
        return this._maxFileSize;
    }
    set maxFileSize(value) {
        if (value !== undefined) {
            this._maxFileSize = Math.max(1000, value);
        }
    }
    get folder() {
        if (!this._folder) {
            this._folder = path.join(os.tmpdir(), 'cdxlsp');
        }
        return LogFile.ensureFolderExists(this._folder);
    }
    set folder(newLogFolderpath) {
        this._folder = newLogFolderpath;
    }
    static ensureFolderExists(folder) {
        if (!fs.existsSync(folder)) {
            fs.mkdirSync(folder, { recursive: true });
        }
        return folder;
    }
    get logfilename() {
        return this.filename;
    }
    init(logId = ('' + process.pid)) {
        this.logId = logId;
        this.filename = this.logFilePath(logId, this.currentFileNumber);
        try {
            this.fileDescriptor = fs.openSync(this.filename, 'w+');
            this.appendRaw(Ansi_1.Ansi.RESET);
            this.appendRaw('---------- opened trace file\n');
            this.appendRaw(`${new Date().toISOString()}\n`);
            this.appendRaw(LspStats_1.traceStats(LspStats_1.LspStats.processStats()));
            this.appendRaw(LspStats_1.traceStats(LspStats_1.LspStats.nodeStats()));
            this.appendRaw(LspStats_1.traceStats(LspStats_1.LspStats.compilerStats()));
            this.appendRaw(LspStats_1.traceStats(LspStats_1.LspStats.platformStats()));
            this.appendRaw(LspStats_1.traceStats(LspStats_1.LspStats.machineStats()));
            this.appendRaw(LspStats_1.traceStats(LspStats_1.LspStats.processEnvironmentStats()));
            this.appendRaw('\n\n---------- tracing...\n\n');
        }
        catch (e) {
            this.logError(e);
        }
    }
    logError(e) {
        console.error(e.stack || e);
    }
    rename(workspaceRoot) {
        if (this.onceRenamed) {
            this.append(`[w] LogFile.rename(${this.logId} => ${workspaceRoot}) ignored`);
            return;
        }
        this.onceRenamed = true;
        this.append(`LogFile.rename(${this.logId} => ${workspaceRoot})`);
        this.logId = workspaceRoot;
        try {
            const finalInitFilename = this.logFilePath(this.logId, this.currentFileNumber);
            if (this.filename !== finalInitFilename) {
                fs.closeSync(this.fileDescriptor);
                this.deleteOrphanedLogFiles();
                fs.renameSync(this.filename, finalInitFilename);
                this.filename = finalInitFilename;
                this.fileDescriptor = fs.openSync(this.filename, 'a+');
            }
        }
        catch (e) {
            this.logError(e);
        }
    }
    logFilePath(workspaceRoot, rotateNumber) {
        const filename = workspaceRoot.replace(/[:/\\]/g, '_') + '.' + rotateNumber + '.log';
        try {
            return path.join(this.folder, filename);
        }
        catch (e) {
            return path.join(os.tmpdir(), 'cdxlsp_' + filename);
        }
    }
    append(message) {
        this.appendRaw(`${message}\n`);
    }
    appendRaw(message) {
        if (this.fileDescriptor) {
            try {
                fs.appendFileSync(this.fileDescriptor, message);
                this.currentFileCount += message.length;
                if (this.currentFileCount >= this.maxFileSize) {
                    this.rotateFile();
                }
            }
            catch (e) {
            }
        }
    }
    bumpFileNumber() {
        const newNumber = (this.currentFileNumber + 1) % (this.numberOfFiles + 1);
        this.currentFileNumber = newNumber || 1;
    }
    close() {
        fs.closeSync(this.fileDescriptor);
        this.fileDescriptor = 0;
    }
    rotateFile() {
        try {
            const previousFilename = this.filename;
            this.bumpFileNumber();
            this.filename = this.logFilePath(this.logId, this.currentFileNumber);
            this.currentFileCount = 0;
            this.appendRaw('\n----- continued in ' + this.filename);
            fs.closeSync(this.fileDescriptor);
            this.fileDescriptor = fs.openSync(this.filename, 'w+');
            this.currentFileCount = 0;
            this.appendRaw('----- continued from ' + previousFilename + '\n\n');
        }
        catch (e) {
            this.logError(e);
        }
    }
    deleteOrphanedLogFiles() {
        try {
            const pattern = path.basename(this.logFilePath(this.logId, '[0-9]+'));
            const dir = path.dirname(this.logFilePath(this.logId, 0));
            fs.readdirSync(dir).forEach(filename => {
                if (filename.match(pattern)) {
                    try {
                        const filePath = path.join(dir, filename);
                        const isFile = fs.lstatSync(filePath).isFile();
                        if (isFile) {
                            const orphanedFileName = path.join(dir, 'orphaned-' + Math.floor(Math.random() * 10000));
                            fs.renameSync(filePath, orphanedFileName);
                            fs.unlinkSync(orphanedFileName);
                        }
                        else {
                            this.appendRaw('Orphaned but not a file: ' + filePath);
                        }
                    }
                    catch (e) {
                        this.appendRaw(e.stack || e);
                    }
                }
            });
        }
        catch (e) {
            this.logError(e);
        }
    }
}
exports.LogFile = LogFile;
LogFile.DEFAULT_MAX_FILE_SIZE = 2000000;
LogFile.DEFAULT_NUMBER_OF_FILES = 5;
//# sourceMappingURL=LogFile.js.map