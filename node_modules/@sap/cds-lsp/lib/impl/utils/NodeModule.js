"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const PathResolver_1 = require("./cdsenv/PathResolver");
const FileTypesUtil_1 = require("./FileTypesUtil");
const FsUtils_1 = require("./FsUtils");
const trace_1 = require("./trace");
class NodeModule {
    constructor(folder, loopDetector, adapter, fetchCdsEnv) {
        this.folder = folder;
        this.loopDetector = loopDetector;
        this.adapter = adapter;
        this.fetchCdsEnv = fetchCdsEnv;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.FILES);
        this.pathResolver = new PathResolver_1.PathResolver();
    }
    async scanFiles(workspaceDocuments) {
        const cdsEnv = await this.fetchCdsEnv();
        return FsUtils_1.scanForFiles(this.tracer, this.folder, filepath => FileTypesUtil_1.isCdsFile(filepath, workspaceDocuments[this.adapter.toUri(filepath)])
            || FileTypesUtil_1.isTranslationFile(cdsEnv, filepath)
            || FileTypesUtil_1.isPackageJsonFile(filepath), this.loopDetector);
    }
    async fetchDependencies() {
        const pkg = FsUtils_1.readPackageJson(this.folder);
        const deps = [];
        if (pkg.dependencies) {
            const checkDependency = (name, version) => () => {
                const pathOrModule = version.startsWith('.') ? version : name;
                const resolvedPackageJson = this.pathResolver.resolveId(`${pathOrModule}/${FileTypesUtil_1.PACKAGE_JSON}`, this.folder);
                if (resolvedPackageJson) {
                    const localPath = path.dirname(resolvedPackageJson);
                    deps.push({ name, localPath });
                }
            };
            for (const [name, version] of Object.entries(pkg.dependencies)) {
                this.tracer.tryCatch(checkDependency(name, version), trace_1.LspTraceLevel.WARNING, `Could not resolve dependency ${name} from folder ${this.folder}`);
            }
        }
        return deps;
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE)
], NodeModule.prototype, "fetchDependencies", null);
exports.NodeModule = NodeModule;
//# sourceMappingURL=NodeModule.js.map