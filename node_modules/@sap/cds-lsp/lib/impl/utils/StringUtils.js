"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const StringUtil_1 = require("../prettyprint/util/StringUtil");
function calculateHashDigest(data) {
    return hash(data);
}
exports.calculateHashDigest = calculateHashDigest;
function hash(str) {
    let hash1 = 5381;
    let hash2 = 2166136261;
    let i = str.length;
    while (i) {
        const char = str.charCodeAt(--i);
        hash1 = (hash1 * 33) ^ char;
        hash2 = (hash2 ^ char) * 16777619;
    }
    return `${hash1 >>> 0}/${hash2 >>> 0}`;
}
function replaceAll(str, find, replace) {
    return str.replace(new RegExp(find, 'g'), replace);
}
exports.replaceAll = replaceAll;
class TextLines {
    constructor(content = '') {
        this._splitLines = StringUtil_1.splitLines(content);
    }
    insert(insertText, atPosition) {
        let line = this._splitLines.lines[atPosition.line];
        line = line.substring(0, atPosition.character) + insertText + line.substring(atPosition.character);
        this._splitLines.lines[atPosition.line] = line;
        return this;
    }
    clone() {
        const newLines = new TextLines('');
        newLines._splitLines.lineBreaks = this._splitLines.lineBreaks.slice(0);
        newLines._splitLines.lines = this._splitLines.lines.slice(0);
        return newLines;
    }
    getLines() {
        return this._splitLines.lines;
    }
    restoreLines(startLine = 0, endLine = this._splitLines.lines.length - 1) {
        var _a;
        const x = this._splitLines;
        let restored = '';
        for (let i = startLine; i <= endLine; i++) {
            restored += x.lines[i] + ((_a = x.lineBreaks[i]) !== null && _a !== void 0 ? _a : '');
        }
        return restored;
    }
    getText(range) {
        if (!range) {
            return this.restoreLines();
        }
        else {
            const firstLine = range.start.line;
            const lastLine = range.end.line;
            if (firstLine === lastLine) {
                return this._splitLines.lines[firstLine].slice(range.start.character, range.end.character);
            }
            else {
                return this._splitLines.lines[firstLine].slice(range.start.character) + this._splitLines.lineBreaks[firstLine]
                    + this.restoreLines(firstLine + 1, lastLine - 1)
                    + this._splitLines.lines[lastLine].slice(0, range.end.character);
            }
        }
    }
}
exports.TextLines = TextLines;
function markdownTranslation(s, isTranslated = true, isTitle = false) {
    if (isTranslated) {
        s = markdownItalics(s);
    }
    if (isTitle) {
        s = markdownBold(s);
    }
    return s;
}
exports.markdownTranslation = markdownTranslation;
function markdownBold(s) {
    return `**${s}**`;
}
exports.markdownBold = markdownBold;
function markdownItalics(s) {
    return `_${s}_`;
}
exports.markdownItalics = markdownItalics;
function parseJson(content) {
    return JSON.parse(content);
}
exports.parseJson = parseJson;
function applyTextEdits(text, textEdits) {
    return LSP.TextDocument.applyEdits(LSP.TextDocument.create('dummyUri', 'dummyLang', 0, text), textEdits);
}
exports.applyTextEdits = applyTextEdits;
//# sourceMappingURL=StringUtils.js.map