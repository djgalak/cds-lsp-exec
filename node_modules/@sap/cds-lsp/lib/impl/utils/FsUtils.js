"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
const ignore_1 = require("ignore");
const StringUtil_1 = require("../prettyprint/util/StringUtil");
const FileTypesUtil_1 = require("./FileTypesUtil");
const trace_1 = require("./trace");
const realpath = util_1.promisify(fs.realpath);
exports.readFile = util_1.promisify(fs.readFile);
exports.readdir = util_1.promisify(fs.readdir);
const lstat = util_1.promisify(fs.lstat);
function canonicalDriveLetter(filepath, referencePath) {
    if (PlatformTester.isWindows()) {
        if (filepath && !filepath.startsWith(referencePath)) {
            return referencePath[0] + filepath.slice(1);
        }
    }
    return filepath;
}
exports.canonicalDriveLetter = canonicalDriveLetter;
class PlatformTester {
    static isWindows() {
        return /^win/.test(process.platform);
    }
}
exports.PlatformTester = PlatformTester;
function isUrl(uriOrPath) {
    return uriOrPath && (uriOrPath.startsWith('file:/') || uriOrPath.startsWith('untitled:'));
}
exports.isUrl = isUrl;
class LoopDetector {
    constructor(referencePath) {
        this.referencePath = referencePath;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.FILES);
        this.canonicalFoldersVisited = new Set();
    }
    async visitFolder(absoluteFolder) {
        const canonicalFolder = canonicalDriveLetter(await realpath(absoluteFolder), this.referencePath);
        this.tracer.verbose(() => `|Scanning folder: ${absoluteFolder} ${canonicalFolder === absoluteFolder ? '' : ' canonical: ' + canonicalFolder}`);
        if (this.canonicalFoldersVisited.has(canonicalFolder)) {
            this.tracer.warn(() => `Loop found when scanning folder: ${absoluteFolder} canonical: ${canonicalFolder}`);
            return false;
        }
        this.canonicalFoldersVisited.add(canonicalFolder);
        return true;
    }
}
exports.LoopDetector = LoopDetector;
async function scanForFiles(tracer, rootPath, isRelevant, loopDetector) {
    const handleFolder = async function (dir) {
        dir = canonicalDriveLetter(dir, rootPath);
        try {
            if (!await loopDetector.visitFolder(dir)) {
                return [];
            }
            const filenames = await exports.readdir(dir);
            const thisIgnorePatterns = await fetchIgnorePatternsFor(dir, tracer);
            thisIgnorePatterns.push(...['.git', 'node_modules']);
            const ignorer = ignorerFor(thisIgnorePatterns);
            const files = [];
            for (const file of filenames) {
                const childpath = path.join(dir, file);
                try {
                    if (ignorer.ignores(file)) {
                        tracer.verbose(`-### IGNORING ### ${childpath}`);
                        continue;
                    }
                    const isFolder = (await lstat(childpath)).isDirectory();
                    if (isFolder) {
                        const filesFromSubfolder = await handleFolder(childpath);
                        files.push(...(filesFromSubfolder.filter(fileFromFolder => {
                            const relativePath = fileFromFolder.slice(dir.length + 1);
                            if (ignorer.ignores(relativePath)) {
                                tracer.verbose(`-### IGNORING #/# ${childpath}`);
                                return false;
                            }
                            return true;
                        })));
                    }
                    else if (isRelevant(childpath)) {
                        files.push(childpath);
                    }
                }
                catch (e) {
                    tracer.verbose(() => `Ignoring ${childpath}: ${e}`);
                }
            }
            return files;
        }
        catch (e) {
            tracer.error(e.stack || e);
            return [];
        }
    };
    const sourceFiles = await tracer.footprint('Scanning workspace for files', () => handleFolder(rootPath));
    tracer.verbose(() => `${sourceFiles.length} files found`);
    return sourceFiles;
}
exports.scanForFiles = scanForFiles;
async function existsFile(filePath) {
    try {
        if (fs.existsSync(filePath)) {
            return (await lstat(filePath)).isFile();
        }
    }
    catch (e) {
    }
    return false;
}
async function fetchIgnoreFilePathFor(folderPath) {
    let ignorefile = path.join(folderPath, '.cdsignore');
    if (await existsFile(ignorefile)) {
        return ignorefile;
    }
    ignorefile = path.join(folderPath, '.gitignore');
    if (await existsFile(ignorefile)) {
        return ignorefile;
    }
    return null;
}
async function fetchIgnorePatternsFor(folderPath, tracer) {
    const ignoreFile = await fetchIgnoreFilePathFor(folderPath);
    if (ignoreFile) {
        try {
            const items = fs.readFileSync(ignoreFile).toString();
            tracer.verbose(() => `Found ${path.basename(ignoreFile)} in ${folderPath} with rules: \n`, items);
            return items.split(StringUtil_1.NEWLINE_REGEX);
        }
        catch (e) {
            tracer.error(() => `Could not read file ${ignoreFile}: \n${e.stack || e}`);
        }
    }
    return [];
}
function ignorerFor(ignorePatterns) {
    const ignorer = ignore_1.default();
    ignorer.add(ignorePatterns);
    return ignorer;
}
function toUnixPath(aPath) {
    return aPath.replace(/\\/g, '/');
}
exports.toUnixPath = toUnixPath;
function toPlatformPath(aPath) {
    return aPath.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
function readPackageJson(folderPath) {
    try {
        const filePath = path.join(folderPath, FileTypesUtil_1.PACKAGE_JSON);
        if (fs.existsSync(filePath)) {
            const content = fs.readFileSync(filePath, 'utf8').toString();
            return JSON.parse(content);
        }
    }
    catch (e) {
    }
    return {};
}
exports.readPackageJson = readPackageJson;
//# sourceMappingURL=FsUtils.js.map