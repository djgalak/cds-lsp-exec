"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const CdxTextDocument_1 = require("./CdxTextDocument");
const trace_1 = require("./trace");
class CdxTextDocuments {
    constructor() {
        this._documents = Object.create(null);
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.WORKSPACE);
    }
    get syncKind() {
        return LSP.TextDocumentSyncKind.Full;
    }
    get(uri) {
        return this._documents[uri];
    }
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    keys() {
        return Object.keys(this._documents);
    }
    onDidChangeTextDocument(params) {
        this.tracer.verbose(() => `** edited editor file ${params.textDocument.uri} #${params.textDocument.version}`);
        const td = params.textDocument;
        const changes = params.contentChanges;
        const last = changes.length > 0 ? changes[changes.length - 1] : undefined;
        if (last) {
            const document = this._documents[td.uri];
            if (document) {
                document.update(last, td.version);
            }
        }
    }
    onDidCloseTextDocument(params) {
        this.tracer.info(() => `** closed editor file ${params.textDocument.uri}`);
        const document = this._documents[params.textDocument.uri];
        if (document) {
            delete this._documents[params.textDocument.uri];
        }
    }
    onDidOpenTextDocument(params) {
        this.tracer.info(() => `** opened editor file ${params.textDocument.uri} #${params.textDocument.version}`);
        const td = params.textDocument;
        this._documents[td.uri] = new CdxTextDocument_1.CdxTextDocument(td.uri, td.languageId, td.version, td.text);
    }
}
exports.CdxTextDocuments = CdxTextDocuments;
//# sourceMappingURL=CdxTextDocuments.js.map