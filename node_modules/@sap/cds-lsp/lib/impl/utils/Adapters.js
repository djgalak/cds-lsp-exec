"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const trace_1 = require("./trace");
const UrlConversion_1 = require("./UrlConversion");
class PositionAdapter {
    static adapt(cdsvPosition) {
        return {
            line: cdsvPosition.line - 1,
            character: cdsvPosition.column - 1
        };
    }
}
exports.PositionAdapter = PositionAdapter;
class RangeAdapter {
    static adapt(cdsvLocation) {
        return {
            start: PositionAdapter.adapt(cdsvLocation.start),
            end: cdsvLocation.end ? PositionAdapter.adapt(cdsvLocation.end) : { line: 64000, character: 0 }
        };
    }
}
exports.RangeAdapter = RangeAdapter;
function adaptRange(cdsvLocation) {
    return RangeAdapter.adapt(cdsvLocation);
}
exports.adaptRange = adaptRange;
function adaptCompletionKind(cdsvKind) {
    return CompletionKindAdapter.adapt(cdsvKind);
}
exports.adaptCompletionKind = adaptCompletionKind;
class CompletionKindAdapter {
    static adapt(cdsvKind) {
        switch (cdsvKind) {
            case 'context': return LSP.CompletionItemKind.Module;
            case 'element': return LSP.CompletionItemKind.Field;
            case 'entity': return LSP.CompletionItemKind.Class;
            case 'namespace': return LSP.CompletionItemKind.Unit;
            case 'source': return LSP.CompletionItemKind.File;
            case 'type': return LSP.CompletionItemKind.Interface;
            default: return LSP.CompletionItemKind.Variable;
        }
    }
}
exports.handle = (prom) => prom.then((res) => [null, res]).catch((err) => [err, null]);
class SeverityAdapter {
    static adapt(severity) {
        switch (severity) {
            case 'Error': return LSP.DiagnosticSeverity.Error;
            case 'Warning': return LSP.DiagnosticSeverity.Warning;
            case 'Info': return LSP.DiagnosticSeverity.Information;
            case 'Debug':
            default: return LSP.DiagnosticSeverity.Hint;
        }
    }
}
exports.SeverityAdapter = SeverityAdapter;
function entries(obj) {
    if (!obj) {
        return [];
    }
    return Object.keys(obj).map(key => [key, obj[key]]);
}
exports.entries = entries;
function toLocalPath(uri) {
    if (Untitled.isUntitledFile(uri)) {
        let fsPath = UrlConversion_1.fileURLToPath(Untitled.toDiskUri(uri));
        if (!fsPath.endsWith('.cds')) {
            fsPath += '.cds';
        }
        return fsPath;
    }
    return noTrailingSeparator(UrlConversion_1.fileURLToPath(uri));
}
exports.toLocalPath = toLocalPath;
function noTrailingSeparator(localPath) {
    return localPath.endsWith(path.sep)
        ? localPath.slice(0, -1)
        : localPath;
}
class Untitled {
    static isUntitledFile(uri) {
        return uri.startsWith(this.UNTITLED_ROOT_URI);
    }
    static toDiskUri(untitledUri) {
        return untitledUri.startsWith(Untitled.UNTITLED_ROOT_URI)
            ? untitledUri.replace(Untitled.UNTITLED_ROOT_URI, Untitled.UNTITLED_ROOT_URI_ONDISK)
            : untitledUri;
    }
}
exports.Untitled = Untitled;
Untitled.UNTITLED_ROOT = path.join(os.tmpdir(), 'cds_lsp_untitled_files') + path.sep;
Untitled.UNTITLED_ROOT_URI_ONDISK = UrlConversion_1.pathToFileURL(Untitled.UNTITLED_ROOT).toString();
Untitled.UNTITLED_ROOT_URI = 'untitled:';
function toSimpleUri(filename) {
    return filename.startsWith('file:')
        ? filename
        : UrlConversion_1.pathToFileURL(filename).toString();
}
exports.toSimpleUri = toSimpleUri;
function toCollectionString(collection, separator = '\n   ') {
    let s = '';
    for (const item of collection) {
        s += separator;
        s += item;
    }
    return s;
}
exports.toCollectionString = toCollectionString;
function empty() {
    return Object.create(null);
}
exports.empty = empty;
class Adapter {
    constructor(clientRootUri, localRoot = toLocalPath(clientRootUri)) {
        if (clientRootUri === undefined) {
            throw new Error('setWorkspaceRootUri called with undefined');
        }
        this.clientRootUri = clientRootUri;
        this.localRoot = localRoot;
    }
    toAbsoluteLocalPath(localPath) {
        return path.isAbsolute(localPath)
            ? localPath
            : path.join(this.localRoot, localPath);
    }
    toUri(filename) {
        let uri = UrlConversion_1.pathToFileURL(filename).toString();
        if (uri.startsWith(Untitled.UNTITLED_ROOT_URI_ONDISK)) {
            if (uri.endsWith('.cds')) {
                uri = uri.slice(0, -4);
            }
            return uri.replace(Untitled.UNTITLED_ROOT_URI_ONDISK, Untitled.UNTITLED_ROOT_URI);
        }
        return uri;
    }
}
exports.Adapter = Adapter;
const symbolKindMap = new Map([
    ['action', LSP.SymbolKind.Function],
    ['context', LSP.SymbolKind.Package],
    ['element', LSP.SymbolKind.Field],
    ['entity', LSP.SymbolKind.Class],
    ['enum', LSP.SymbolKind.EnumMember],
    ['event', LSP.SymbolKind.Event],
    ['function', LSP.SymbolKind.Function],
    ['namespace', LSP.SymbolKind.Namespace],
    ['param', LSP.SymbolKind.TypeParameter],
    ['type', LSP.SymbolKind.Interface],
    ['using', LSP.SymbolKind.Module],
    ['service', LSP.SymbolKind.Object],
    ['view', LSP.SymbolKind.Class]
]);
function adaptSymbolKind(cdsvKind, expectedKind) {
    cdsvKind = expectedKind || cdsvKind;
    const symbolKind = symbolKindMap.get(cdsvKind);
    if (!symbolKind) {
        trace_1.currentTrace().tracer(trace_1.LspTraceComponent.ADAPTER).verbose(`default adaptSymbolKind(${cdsvKind})`);
    }
    return symbolKind || LSP.SymbolKind.String;
}
exports.adaptSymbolKind = adaptSymbolKind;
//# sourceMappingURL=Adapters.js.map