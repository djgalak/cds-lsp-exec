"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const trace_1 = require("./trace");
class Task {
    constructor(tracer, resourceId, version, asyncTask, previousResult) {
        this.tracer = tracer;
        this.resourceId = resourceId;
        this.asyncTask = asyncTask;
        this.previousResult = previousResult;
        this.state = 'queued';
        this.versions = [];
        this.versions.push(version);
        tracer.verbose(() => `Task ${this}`);
        this.asyncResult = new Promise((outerResolve, outerReject) => {
            const startThis = async () => {
                try {
                    this.state = 'started';
                    tracer.verbose(() => `Task ${this}`);
                    const res = await this.asyncTask();
                    this.state = 'completed';
                    tracer.verbose(() => `Task ${this} => ${util_1.inspect(res)}`);
                    outerResolve(res);
                }
                catch (e) {
                    this.state = 'completed';
                    tracer.error(() => `Rejected: Task ${this} => ${e}`);
                    outerReject(e);
                }
            };
            if (previousResult) {
                tracer.verbose(() => `Chaining ${this} after previous`);
                previousResult.catch(nop).then(startThis);
            }
            else {
                startThis();
            }
        });
    }
    rebase(newVersion, asyncTask) {
        if (this.state !== 'queued') {
            throw new Error(`Rebase not possible, task is in '${this.state}' state`);
        }
        this.versions.push(newVersion);
        this.asyncTask = asyncTask;
        this.tracer.verbose(() => `Rebased task ${this}`);
    }
    isResponsibleFor(version) {
        return this.versions.includes(version);
    }
    toString() {
        return `(${this.state}) ${this.resourceId}#${this.versions.join(',')}`;
    }
}
exports.Task = Task;
class TaskManager {
    constructor() {
        this._idToTasks = new Map();
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.UTIL);
    }
    async enqueue(resourceId, version, asyncTask) {
        let tasksForResource = this._idToTasks.get(resourceId);
        if (!tasksForResource) {
            tasksForResource = [];
            this._idToTasks.set(resourceId, tasksForResource);
        }
        const taskForVersion = tasksForResource.find(t => t.isResponsibleFor(version));
        if (taskForVersion) {
            this.tracer.verbose(() => `Reusing pending task ${taskForVersion}`);
            return taskForVersion.asyncResult;
        }
        const createTask = (previousTask) => {
            const task = new Task(this.tracer, resourceId, version, asyncTask, previousTask ? previousTask.asyncResult : undefined);
            task.asyncResult.catch(nop).then(() => {
                const shifted = tasksForResource.shift();
                this.tracer.verbose(() => `Garbage collected task ${shifted}`);
                if (shifted !== task) {
                    this.tracer.error(() => `Garbage collection failed for task ${task}, collected ${shifted}`);
                    this._idToTasks.set(resourceId, []);
                }
            });
            tasksForResource.push(task);
            return task.asyncResult;
        };
        if (tasksForResource.length === 0) {
            return createTask();
        }
        else {
            const lastTask = tasksForResource[tasksForResource.length - 1];
            if (lastTask.state === 'queued') {
                lastTask.rebase(version, asyncTask);
                return lastTask.asyncResult;
            }
            else {
                return createTask(lastTask);
            }
        }
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE, {
        traceLevel: trace_1.LspTraceLevel.VERBOSE,
        argumentsRenderer: args => `${args[0]}#${args[1]}`,
        resultRenderer: (res, args) => `${args[0]}#${args[1]}`
    })
], TaskManager.prototype, "enqueue", null);
exports.TaskManager = TaskManager;
function nop() { }
//# sourceMappingURL=TaskManager.js.map