"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const index_1 = require("../index");
const trace_1 = require("../trace");
var Tool;
(function (Tool) {
    Tool["DevKit"] = "@sap/cds-dk/package.json";
    Tool["Umbrella"] = "@sap/cds";
    Tool["Compiler"] = "@sap/cds-compiler";
})(Tool = exports.Tool || (exports.Tool = {}));
var LogicalCompilerLocation;
(function (LogicalCompilerLocation) {
    LogicalCompilerLocation["builtin"] = "included in Language Server";
    LogicalCompilerLocation["project"] = "from project";
    LogicalCompilerLocation["global"] = "globally installed";
})(LogicalCompilerLocation = exports.LogicalCompilerLocation || (exports.LogicalCompilerLocation = {}));
const Location = LogicalCompilerLocation;
class UnsupportedValue extends Error {
    constructor(x) {
        super();
    }
}
exports.UnsupportedValue = UnsupportedValue;
class ModuleLoader {
    constructor() {
        this.resolver = new index_1.PathResolver();
    }
    loadCds(fromFolder = process.cwd()) {
        let resolved = this.resolveUmbrella(Location.project, fromFolder);
        if (!(resolved === null || resolved === void 0 ? void 0 : resolved.resolvedPath)) {
            resolved = this.resolveUmbrella(Location.global);
        }
        const umbrella = require(resolved.resolvedPath);
        umbrella.__loadedFrom = resolved.resolvedPath;
        umbrella.__logicalLocation = resolved.logicalLocation;
        return umbrella;
    }
    loadCompiler(projectRoot) {
        const loader = this;
        function* resolvedPaths() {
            yield loader.resolveCompiler(Location.project, projectRoot);
            yield loader.resolveCompiler(Location.global);
            yield loader.resolveCompiler(Location.builtin);
        }
        for (const resolved of resolvedPaths()) {
            try {
                if (resolved.resolvedPath) {
                    const compiler = this.requireModule(resolved.resolvedPath);
                    compiler.__loadedFrom = resolved.resolvedPath;
                    compiler.__logicalLocation = resolved.logicalLocation;
                    return compiler;
                }
            }
            catch (e) {
                trace_1.currentTrace().tracer(trace_1.LspTraceComponent.WORKSPACE).warn(`Unable to load compiler from resolved i.e. existing path ${resolved.resolvedPath}: ${trace_1.errorStack(e)}`);
            }
        }
        throw new Error('No compiler installed');
    }
    requireModule(resolvedPath) {
        return require(resolvedPath);
    }
    startFolders(atLocation, projectRoot) {
        switch (atLocation) {
            case Location.builtin: return [this.resolver.getLspFolder()];
            case Location.project: return [projectRoot];
            case Location.global: return this.resolver.getGlobalNodeModulesFolders();
            default: throw new UnsupportedValue(atLocation);
        }
    }
    compilerChain(atLocation, projectRoot) {
        switch (atLocation) {
            case Location.builtin: return [Tool.Compiler];
            case Location.project:
            case Location.global: return this.umbrellaChain(atLocation).concat(Tool.Compiler);
            default: throw new UnsupportedValue(atLocation);
        }
    }
    umbrellaChain(atLocation, projectRoot) {
        switch (atLocation) {
            case Location.project: return [Tool.Umbrella];
            case Location.global: return [Tool.DevKit, Tool.Umbrella];
            default: throw new Error(`Unsupported value ${atLocation}`);
        }
    }
    resolveCompiler(logicalLocation, projectRoot) {
        return {
            resolvedPath: this.resolver.resolveModule(this.compilerChain(logicalLocation), this.startFolders(logicalLocation, projectRoot)),
            logicalLocation
        };
    }
    resolveUmbrella(logicalLocation, projectRoot) {
        return {
            resolvedPath: this.resolver.resolveModule(this.umbrellaChain(logicalLocation), this.startFolders(logicalLocation, projectRoot)),
            logicalLocation
        };
    }
    resolveGlobalSapCds() {
        const resolvedUmbrellaMain = this.resolveUmbrella(LogicalCompilerLocation.global);
        if (resolvedUmbrellaMain.resolvedPath) {
            const sapCds = `@sap${path.sep}cds`;
            resolvedUmbrellaMain.resolvedPath = resolvedUmbrellaMain.resolvedPath.slice(0, resolvedUmbrellaMain.resolvedPath.lastIndexOf(sapCds) + sapCds.length);
        }
        return resolvedUmbrellaMain;
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.UTIL)
], ModuleLoader.prototype, "resolveUmbrella", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.UTIL)
], ModuleLoader.prototype, "resolveGlobalSapCds", null);
exports.ModuleLoader = ModuleLoader;
//# sourceMappingURL=ModuleLoader.js.map