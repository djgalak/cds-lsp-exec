"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const util = require("util");
const ExtractedCdsEnv_1 = require("./ExtractedCdsEnv");
const ModuleLoader_1 = require("./ModuleLoader");
const ANSI_ERROR = '\x1b[0m\x1b[41m\x1b[1;33m';
const ANSI_RESET = '\x1b[0m';
const inspect = (o) => util.inspect(o, false, null, true);
const log = (o) => console.error(o);
const error = (o) => log(ANSI_ERROR + o + ANSI_RESET);
exports.loadCds = (fromFolder = process.cwd()) => new ModuleLoader_1.ModuleLoader().loadCds(fromFolder);
exports.loadEnv = async () => {
    try {
        const cds = exports.loadCds();
        log(cds.build);
        log(`-- CDS ENV:\n${inspect(cds.env)}`);
        return new CdsEnvConverter({ log, error, inspect }).convert(cds);
    }
    catch (e) {
        error(`-- Failed to extract cds.env\n${inspect(e)}`);
    }
    return ExtractedCdsEnv_1.defaultEnv();
};
class CdsEnvConverter {
    constructor(logger) {
        this.logger = logger;
    }
    async convert(cds) {
        var _a, _b;
        const result = ExtractedCdsEnv_1.defaultEnv();
        try {
            result.i18n = this.extractI18n((_a = cds === null || cds === void 0 ? void 0 : cds.env) === null || _a === void 0 ? void 0 : _a.i18n);
            result.compilerOptions = (_b = cds === null || cds === void 0 ? void 0 : cds.env) === null || _b === void 0 ? void 0 : _b.cdsc;
            await this.extractEntryModels(cds, result.rootModels);
        }
        catch (e) {
            this.logger.error(`-- Failed to convert env\n${this.logger.inspect(e)}`);
        }
        return result;
    }
    async extractBuildTasks(cds) {
        var _a, _b, _c;
        try {
            const { BuildTaskFactory } = cds.build;
            if (BuildTaskFactory) {
                this.logger.log('-- Extracting build tasks via BuildTaskFactory');
                return new BuildTaskFactory(this.logger, cds)
                    .getTasks({ root: process.cwd() });
            }
        }
        catch (e) {
            this.logger.error(`-- Failed to extract build tasks via BuildTaskFactory\n${this.logger.inspect(e)}`);
        }
        return (_c = (_b = (_a = cds === null || cds === void 0 ? void 0 : cds.env) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.tasks) !== null && _c !== void 0 ? _c : [];
    }
    async extractEntryModels(cds, rootModels) {
        const roots = {};
        const cdsResolve = cds && cds.resolve.bind(cds) || (a => [a]);
        const add = (relativePath, kind) => {
            const kindModels = roots[kind] || (roots[kind] = new Set());
            this.logger.log(`Resolving ${relativePath}`);
            (cdsResolve(relativePath) || []).forEach(absolutePath => kindModels.add(absolutePath));
        };
        const folders = cds.env.folders || {};
        const dispatch = (relativePath) => {
            for (const kind of ExtractedCdsEnv_1.kinds) {
                if (folders[kind]) {
                    const rel = path.relative(folders[kind], relativePath);
                    if (rel === '' || !rel.startsWith('..')) {
                        add(relativePath, kind);
                        return;
                    }
                }
            }
        };
        (await this.extractBuildTasks(cds))
            .reduce((allModels, task) => allModels.concat(((task.options || {}).model || [])), [])
            .forEach(dispatch);
        Object.entries(roots)
            .forEach(([kind, set]) => rootModels[kind] = [...set]);
    }
    extractI18n(i18n = ExtractedCdsEnv_1.defaultI18n()) {
        const defaults = ExtractedCdsEnv_1.defaultI18n();
        const def = ((prop) => {
            if (i18n[prop] === undefined || (Array.isArray(defaults[prop]) && !i18n[prop].length)) {
                i18n[prop] = defaults[prop];
            }
        });
        Object.keys(defaults).forEach(def);
        return i18n;
    }
}
exports.CdsEnvConverter = CdsEnvConverter;
//# sourceMappingURL=CdsEnvConverter.js.map