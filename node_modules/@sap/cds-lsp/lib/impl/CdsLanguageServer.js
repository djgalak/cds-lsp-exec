"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const Compiler_1 = require("./model/Compiler");
const completion_1 = require("./services/completion");
const FormattingService_1 = require("./services/FormattingService");
const quickFixes_1 = require("./services/quickFixes");
const RefactoringService_1 = require("./services/refactor/RefactoringService");
const WhereUsedService_1 = require("./services/WhereUsedService");
const WorkspaceFolder_1 = require("./services/WorkspaceFolder");
const WorkspaceService_1 = require("./services/WorkspaceService");
const utils_1 = require("./utils");
const trace_1 = require("./utils/trace");
class CdsLanguageServer {
    constructor(telemetry) {
        this.telemetry = telemetry;
        this.options = new utils_1.LspOptions();
        this.compiler = new Compiler_1.Compiler(this.options);
        this.trace = trace_1.currentTrace();
        this.registrations = new Map();
        this.workspaceService = new WorkspaceService_1.WorkspaceService(this, this.options);
        this.whereUsedService = new WhereUsedService_1.WhereUsedService(this.options, this.workspaceService);
        this.completionService = new completion_1.CompletionService(this.options, this.workspaceService, this.compiler);
        this.refactoringService = new RefactoringService_1.RefactoringService();
        this.formattingService = new FormattingService_1.FormattingService(this.compiler, this.workspaceService);
        this.requestTracer = this.trace.tracer(trace_1.LspTraceComponent.REQUESTS);
    }
    listen(connection) {
        this.connection = connection;
        function bound(service, k) {
            return (...args) => service[k].bind(service)(...args);
        }
        try {
            connection.onCodeAction(bound(this.workspaceService, 'onCodeAction'));
            connection.onCompletion(bound(this.completionService, 'onCompletion'));
            connection.onCompletionResolve(bound(this.completionService, 'onCompletionResolve'));
            connection.onDefinition(bound(this.whereUsedService, 'onDefinition'));
            connection.onDidChangeConfiguration(bound(this, 'onDidChangeConfiguration'));
            connection.onDidChangeTextDocument(bound(this.workspaceService, 'onDidChangeTextDocument'));
            connection.onDidChangeWatchedFiles(bound(this.workspaceService, 'onDidChangeWatchedFiles'));
            connection.onDidCloseTextDocument(bound(this.workspaceService, 'onDidCloseTextDocument'));
            connection.onDidOpenTextDocument(bound(this.workspaceService, 'onDidOpenTextDocument'));
            connection.onDidSaveTextDocument(bound(this.workspaceService, 'onDidSaveTextDocument'));
            connection.onDocumentFormatting(bound(this.formattingService, 'onDocumentFormatting'));
            connection.onDocumentHighlight(bound(this.whereUsedService, 'onDocumentHighlight'));
            connection.onDocumentLinks(bound(this.whereUsedService, 'onDocumentLinks'));
            connection.onDocumentLinkResolve(bound(this.whereUsedService, 'onDocumentLinkResolve'));
            connection.onDocumentOnTypeFormatting(bound(this.formattingService, 'onDocumentOnTypeFormatting'));
            connection.onDocumentRangeFormatting(bound(this.formattingService, 'onDocumentRangeFormatting'));
            connection.onDocumentSymbol(bound(this.whereUsedService, 'onDocumentSymbol'));
            connection.onExecuteCommand(bound(this.workspaceService, 'onExecuteCommand'));
            connection.onExit(bound(this, 'onExit'));
            connection.onHover(bound(this.whereUsedService, 'onHover'));
            connection.onInitialize(bound(this, 'onInitialize'));
            connection.onInitialized(bound(this, 'onInitialized'));
            connection.onReferences(bound(this.whereUsedService, 'onReferences'));
            connection.onRenameRequest(bound(this.refactoringService, 'onRenameRequest'));
            connection.onShutdown(bound(this, 'onShutdown'));
            connection.onWillSaveTextDocument(bound(this.workspaceService, 'onWillSaveTextDocument'));
            connection.onWillSaveTextDocumentWaitUntil(bound(this.workspaceService, 'onWillSaveTextDocumentWaitUntil'));
            connection.onWorkspaceSymbol(bound(this.whereUsedService, 'onWorkspaceSymbol'));
        }
        catch (e) {
            this.trace.conditionalTrace(trace_1.LspTraceComponent.UTIL, trace_1.LspTraceLevel.INFRASTRUCTURE, e.stack);
        }
    }
    getWorkspaceFoldersConfig(params) {
        let workspaceFoldersConfig = [];
        const handleDeprecatedWorkspaceInit = () => {
            const rootUri = params.rootUri || (params.rootPath ? utils_1.toSimpleUri(params.rootPath) : null);
            if (rootUri) {
                workspaceFoldersConfig = [{ name: '(rootUri)', uri: rootUri }];
            }
        };
        if (params.workspaceFolders !== undefined) {
            this.requestTracer.info('Client supports workspace folders: ', params.workspaceFolders);
            if (params.workspaceFolders && params.workspaceFolders.length) {
                workspaceFoldersConfig = params.workspaceFolders;
            }
            else {
                this.requestTracer.info('No workspace folders set, trying deprecated rootUri/rootPath: ', params.rootUri || params.rootPath);
                handleDeprecatedWorkspaceInit();
            }
        }
        else {
            this.requestTracer.info('Client supports rootUri/rootPath: ', params.rootUri || params.rootPath);
            handleDeprecatedWorkspaceInit();
        }
        return workspaceFoldersConfig;
    }
    get serverCapabilities() {
        const pkg = require('../../package.json');
        return {
            serverInfo: {
                name: pkg.name,
                version: pkg.version
            },
            capabilities: {
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: ['.', '@']
                },
                definitionProvider: true,
                documentFormattingProvider: true,
                documentRangeFormattingProvider: true,
                documentOnTypeFormattingProvider: {
                    firstTriggerCharacter: '}',
                    moreTriggerCharacter: [';']
                },
                documentHighlightProvider: true,
                documentLinkProvider: { resolveProvider: true },
                documentSymbolProvider: true,
                hoverProvider: true,
                referencesProvider: true,
                textDocumentSync: LSP.TextDocumentSyncKind.Full,
                workspaceSymbolProvider: true,
                workspace: {
                    workspaceFolders: {
                        supported: true,
                        changeNotifications: true
                    }
                },
                codeActionProvider: true,
                executeCommandProvider: {
                    commands: [
                        quickFixes_1.QuickFixCommands.MAINTAIN_TRANSLATION
                    ]
                }
            }
        };
    }
    onInitialize(params) {
        var _a;
        this.options.clientCapabilities = params;
        const workspaceFoldersConfig = this.getWorkspaceFoldersConfig(params);
        this.workspaceService.createWorkspaceFolders(workspaceFoldersConfig, this.compiler);
        (_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.enable();
        const getLogFolder = () => {
            const settingFile = this.getWorkspaceSettingsPath();
            return settingFile
                ? path.join(path.dirname(settingFile), 'logs')
                : undefined;
        };
        const getLogFileName = () => {
            switch (workspaceFoldersConfig.length) {
                case 0: return '(no-workspace)';
                case 1: return utils_1.toLocalPath(workspaceFoldersConfig[0].uri);
                default: return workspaceFoldersConfig
                    .map(config => config.name)
                    .join('_+_');
            }
        };
        this.trace.configure({
            name: getLogFileName(),
            folder: getLogFolder()
        });
        return this.serverCapabilities;
    }
    getLspSettingsPath() {
        return path.join(__dirname, '..', '..', '.cds-lsp', '.settings.json');
    }
    getWorkspaceSettingsPath() {
        return this.workspaceService.workspaceFolders
            .filter(WorkspaceFolder_1.isRealWorkspaceFolder)
            .map(wsf => path.join(wsf.workspaceRoot, '.cds-lsp', '.settings.json'))
            .find(wsRoot => fs.existsSync(wsRoot));
    }
    async onInitialized() {
        this.requestTracer.tryCatch(() => {
            var _a, _b;
            (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.workspace) === null || _b === void 0 ? void 0 : _b.onDidChangeWorkspaceFolders((changes) => this.onDidChangeWorkspaceFolders(changes));
        }, trace_1.LspTraceLevel.ERROR, 'Registration for onDidChangeWorkspaceFolders');
        await this.updateWatchRegistration();
        if (!this.options.getClientCapability(utils_1.ClientCapability.CHANGE_CONFIG, false)) {
            const lspSettingsPath = this.getLspSettingsPath();
            const workspaceSettingsPath = this.getWorkspaceSettingsPath();
            if (lspSettingsPath || workspaceSettingsPath) {
                this._onDidChangeConfiguration(this.readSettings(lspSettingsPath), this.readSettings(workspaceSettingsPath));
            }
        }
    }
    async updateWatchRegistration() {
        if (this.options.getClientCapability('capabilities.workspace.didChangeWatchedFiles.dynamicRegistration', false)) {
            const register = (name, type, registerParams) => {
                if (!this.registrations.get(name)) {
                    this.requestTracer.info(`Registering ${name}`);
                    const registration = this.connection.client.register(type, registerParams);
                    this.registrations.set(name, registration);
                    registration.then(() => this.requestTracer.info(`${name} REGISTERED`));
                }
            };
            this.requestTracer.verbose('Client supports dynamic registration');
            this.requestTracer.info('Enabling file-system change reporting for CDS relevant files');
            const watchers = [];
            const kind = LSP.WatchKind.Create + LSP.WatchKind.Change + LSP.WatchKind.Delete;
            watchers.push({ kind, globPattern: utils_1.PACKAGE_JSON });
            watchers.push({ kind, globPattern: '{.git,.cds}ignore' });
            watchers.push({ kind, globPattern: '.cdsrc.json' });
            for (const workspaceFolder of this.workspaceService.workspaceFolders.filter(WorkspaceFolder_1.isRealWorkspaceFolder)) {
                const cdsEnv = await workspaceFolder.fetchCdsEnv();
                const globPattern = `**/{${cdsEnv.i18n.folders.join(',')}}/${cdsEnv.i18n.file}{*.properties,*.json,*.csv}`;
                watchers.push({ kind, globPattern });
            }
            register('DidChangeWatchedFilesNotification', LSP.DidChangeWatchedFilesNotification.type, { watchers });
        }
        else {
            this.requestTracer.warn('Client DOES NOT support dynamic registration');
        }
    }
    readSettings(configPath) {
        try {
            if (fs.existsSync(configPath)) {
                const content = (fs.readFileSync(configPath, 'utf8')).toString();
                return JSON.parse(content);
            }
        }
        catch (e) {
            this.requestTracer.warn(() => `Local settings file ${configPath} exists, but is not a valid JSON:\n${e}`);
        }
        return undefined;
    }
    async onDidChangeWorkspaceFolders(changes) {
        this.requestTracer.info('Workspace folders changed: ', changes);
        for (const addedFolder of changes.added) {
            try {
                const wsf = this.workspaceService.addWorkspaceFolder(addedFolder, this.compiler);
                await wsf.onWorkspaceChanged();
            }
            catch (e) {
                this.requestTracer.error(() => `Failed to add workspace folder '${addedFolder.name}' with URI ${addedFolder.uri}: `, e.stack || e);
            }
        }
        changes.removed.forEach((removedFolder) => {
            try {
                this.workspaceService.removeWorkspaceFolder(removedFolder.uri);
            }
            catch (e) {
                this.requestTracer.error(() => `Failed to remove workspace folder '${removedFolder.name}' with URI ${removedFolder.uri}: `, e.stack || e);
            }
        });
    }
    async onDidChangeConfiguration(params) {
        return this._onDidChangeConfiguration(this.readSettings(this.getLspSettingsPath()), this.readSettings(this.getWorkspaceSettingsPath()), params);
    }
    mergeConfigParams(...paramsS) {
        if (paramsS.length > 1) {
            return paramsS
                .slice(1)
                .reduce((merged, current, i) => {
                this.requestTracer.info(`Overlaying settings (${i + 1})`);
                return mergeJSONs(merged, current, undefined, this.requestTracer);
            }, paramsS[0]);
        }
        return paramsS === null || paramsS === void 0 ? void 0 : paramsS[0];
    }
    async _onDidChangeConfiguration(...paramsS) {
        const params = this.mergeConfigParams(...paramsS);
        if (!this.requestTracer.isTracing(trace_1.LspTraceLevel.VERBOSE)) {
            this.trace.conditionalTrace(trace_1.LspTraceComponent.REQUESTS, trace_1.LspTraceLevel.INFRASTRUCTURE, 'New user settings: ', params);
        }
        this.options.userSettings = params;
        this.trace.configure({
            components: this.options.getUserSetting(utils_1.UserSetting.TRACE_COMPONENTS, []),
            logfileCount: this.options.getUserSetting(utils_1.UserSetting.TRACE_LOGFILES_COUNT),
            logfileSize: this.options.getUserSetting(utils_1.UserSetting.TRACE_LOGFILES_MAXSIZE)
        });
        for (const workspaceFolder of this.workspaceService.workspaceFolders) {
            await workspaceFolder.onWorkspaceChanged();
        }
    }
    onShutdown() {
    }
    onExit() {
        trace_1.currentTrace().conditionalTrace(trace_1.LspTraceComponent.REQUESTS, trace_1.LspTraceLevel.INFRASTRUCTURE, 'This is the end...');
        process.exit(0);
    }
    sendDiagnostics(params) {
        if (this.connection) {
            this.requestTracer.info(() => `${trace_1.MESSAGE_OUTGOING}sendDiagnostics ${params.uri}`);
            this.requestTracer.verbose(() => `${params.uri} ${utils_1.renderDiags(params.diagnostics)}`);
            this.connection.sendDiagnostics(params);
        }
    }
    async applyWorkspaceEdits(params) {
        if (this.connection) {
            this.requestTracer.info(() => `${trace_1.MESSAGE_OUTGOING}applyEdit`);
            this.requestTracer.verbose(() => `${params.label} ${utils_1.renderWorkspaceEdit(params.edit)}`);
            return this.connection.workspace.applyEdit(params);
        }
        return undefined;
    }
    async userPopup(level, message, ...buttons) {
        var _a;
        this.trace.conditionalTrace(trace_1.LspTraceComponent.UTIL, trace_1.LspTraceLevel.INFO, 'userPopup/' + trace_1.LspTraceLevel[level] + ': ', message);
        if (this.connection) {
            const params = buttons.map(name => {
                this.trace.conditionalTrace(trace_1.LspTraceComponent.UTIL, trace_1.LspTraceLevel.VERBOSE, 'map button: ' + name);
                return { title: name };
            });
            let method;
            switch (level) {
                case trace_1.LspTraceLevel.ERROR:
                    method = this.connection.window.showErrorMessage;
                    break;
                case trace_1.LspTraceLevel.WARNING:
                    method = this.connection.window.showWarningMessage;
                    break;
                case trace_1.LspTraceLevel.INFO:
                    method = this.connection.window.showInformationMessage;
                    break;
                case trace_1.LspTraceLevel.VERBOSE:
                    this.connection.sendNotification(LSP.ShowMessageNotification.type, {
                        message,
                        type: LSP.MessageType.Info
                    });
                    return '';
                default:
                    throw new Error('unsupported user popup level: ' + level);
            }
            const action = await method.call(this.connection.window, message, ...params);
            return (_a = action === null || action === void 0 ? void 0 : action.title) !== null && _a !== void 0 ? _a : '?';
        }
        return '';
    }
}
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: utils_1.empty(),
        expectedState: trace_1.LspOperatingState.Shutdown,
        newState: trace_1.LspOperatingState.Operating
    })
], CdsLanguageServer.prototype, "onInitialize", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], CdsLanguageServer.prototype, "onInitialized", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.REQUESTS)
], CdsLanguageServer.prototype, "updateWatchRegistration", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], CdsLanguageServer.prototype, "onDidChangeWorkspaceFolders", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], CdsLanguageServer.prototype, "onDidChangeConfiguration", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.REQUESTS)
], CdsLanguageServer.prototype, "_onDidChangeConfiguration", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined,
        newState: trace_1.LspOperatingState.Shutdown
    })
], CdsLanguageServer.prototype, "onShutdown", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined,
        expectedState: trace_1.LspOperatingState.Ignore,
        newState: trace_1.LspOperatingState.Shutdown
    })
], CdsLanguageServer.prototype, "onExit", null);
exports.CdsLanguageServer = CdsLanguageServer;
function mergeJSONs(target = {}, add = {}, baseFqn = '', tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.UTIL)) {
    const isObject = (obj) => typeof obj === 'object';
    Object.entries(add).forEach(([key, addVal]) => {
        const fqn = baseFqn.length ? baseFqn + '.' + key : key;
        const targetVal = target[key];
        if (targetVal && isObject(targetVal) && isObject(addVal)) {
            if ((Array.isArray(targetVal) && Array.isArray(addVal))) {
                tracer.verbose(() => `- ${fqn}: to ${targetVal} appending ${addVal}`);
                targetVal.push(...addVal);
                return;
            }
            mergeJSONs(targetVal, addVal, fqn, tracer);
        }
        else {
            if (targetVal !== addVal) {
                tracer.verbose(() => `- ${fqn}: changing from ${targetVal} to ${addVal}`);
            }
            target[key] = addVal;
        }
    });
    return target;
}
exports.mergeJSONs = mergeJSONs;
//# sourceMappingURL=CdsLanguageServer.js.map