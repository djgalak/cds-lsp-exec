"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const utils_1 = require("../utils");
const cdsenv_1 = require("../utils/cdsenv");
const trace_1 = require("../utils/trace");
class Compiler {
    constructor(options, moduleLoader = new cdsenv_1.ModuleLoader()) {
        this.options = options;
        this.moduleLoader = moduleLoader;
        this._projectRootToLocalSapCdsPath = new Map();
        this.lastCompiler = null;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL);
    }
    hasLocalSapCds(projectRoot) {
        const cachedResolved = this._projectRootToLocalSapCdsPath.get(projectRoot);
        if (!cachedResolved || !fs.existsSync(cachedResolved)) {
            const resolvedPath = this.moduleLoader.resolver.resolveId('@sap/cds', projectRoot);
            this._projectRootToLocalSapCdsPath.set(projectRoot, resolvedPath);
        }
        return !!this._projectRootToLocalSapCdsPath.get(projectRoot);
    }
    async compile(localPath, files = utils_1.empty(), workspaceRoot, options = utils_1.empty()) {
        if (options.attachTokens === undefined) {
            this.tracer.verbose('Ensuring tokens are attached');
            options.attachTokens = true;
        }
        const frame = trace_1.currentFrame();
        frame.requestScope.compilations += 1;
        let model = null;
        const { tracer } = this;
        const filesUsed = new Set();
        const { resolvedPath: globalSapCds } = this.moduleLoader.resolveGlobalSapCds();
        this.tracer.debug(() => `Compiling with files map: ${Object.keys(files).reduce((out, file) => out.concat('\n' + file), '')}`);
        const fileCacheProxy = new Proxy(files, {
            get(target, p, receiver) {
                const content = Reflect.get(target, p, receiver);
                if (!content) {
                    tracer.debug(() => `- ${String(p)}`);
                }
                if (content) {
                    if (typeof content === 'string') {
                        filesUsed.add(p.toString());
                        tracer.debug(() => `+ ${String(p)}`);
                    }
                    else {
                        tracer.debug(() => `> ${String(p)}`);
                    }
                }
                return content;
            },
            set(target, p, value, receiver) {
                return Reflect.set(target, p, value, receiver);
            }
        });
        const stopwatch = new trace_1.Stopwatch();
        let cdsCompiler;
        const setGlobalCdsHome = (home) => {
            this.tracer[home ? 'warn' : 'verbose'](`Setting cds.home=${home}`);
            global.cds = { home };
        };
        setGlobalCdsHome(this.hasLocalSapCds(workspaceRoot) ? undefined : globalSapCds);
        try {
            cdsCompiler = this._getCompiler(workspaceRoot);
            model = await cdsCompiler.compile([localPath], workspaceRoot, options, fileCacheProxy);
        }
        catch (e) {
            model = e.model;
            if (!model) {
                this.tracer.error('failed to compile model: ', e.errors || e.stack || e);
                if (this.options.getUserSetting(utils_1.UserSetting.SHOW_COMPILER_ERRORS, false)) {
                    const stats = await trace_1.currentFrame().appScope.stats.healthStats();
                    stats.type = 'internal compiler error';
                    stats.stack = e.stack || e;
                    trace_1.currentTrace().addTelemetry(stats);
                }
            }
        }
        finally {
            frame.requestScope.compilationElapsedMillis += (stopwatch.elapsedNanos / 1000000);
            for (const filePath of filesUsed) {
                const content = files[filePath];
                if (content) {
                    frame.requestScope.compiledFiles += 1;
                    frame.requestScope.compiledSourceLength += content.length;
                }
            }
        }
        return model;
    }
    async parse(content, localPath, workspaceRoot, options = utils_1.empty()) {
        return this._getCompiler(workspaceRoot).parse(content, localPath, options);
    }
    _getCompiler(workspaceRoot) {
        let compiler;
        try {
            compiler = this.moduleLoader.loadCompiler(workspaceRoot);
            return compiler;
        }
        finally {
            if (compiler !== this.lastCompiler) {
                this.tracer.info(() => { var _a, _b; return `Compiler changed to ${(_a = compiler === null || compiler === void 0 ? void 0 : compiler.version()) !== null && _a !== void 0 ? _a : 'none'} located at ${(_b = compiler === null || compiler === void 0 ? void 0 : compiler.__loadedFrom) !== null && _b !== void 0 ? _b : 'nowhere'}`; });
                this.lastCompiler = compiler;
                const stats = trace_1.currentFrame().appScope.stats;
                stats.lastUsedCompiler = compiler;
                trace_1.currentTrace().addTelemetry(stats.healthStats());
            }
        }
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, {
        traceLevel: trace_1.LspTraceLevel.VERBOSE,
        argumentsRenderer: args => `${args[0]}`,
        resultRenderer: r => r ? '<AST>' : 'null',
        trackMemory: true
    })
], Compiler.prototype, "compile", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, {
        argumentsRenderer: args => `${args[1]} - ${args[0] ? args[0].length : 0} bytes`,
        resultRenderer: r => r ? '<AST>' : 'null'
    })
], Compiler.prototype, "parse", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, { traceLevel: trace_1.LspTraceLevel.VERBOSE, errorHandler: (errorKind, e, prefix, tracer) => { tracer.info(`} => ${e}`); throw e; }, resultRenderer: (res) => res ? `${res.version()} ${res.__logicalLocation} - ${res.__loadedFrom}` : 'undefined' })
], Compiler.prototype, "_getCompiler", null);
exports.Compiler = Compiler;
//# sourceMappingURL=Compiler.js.map