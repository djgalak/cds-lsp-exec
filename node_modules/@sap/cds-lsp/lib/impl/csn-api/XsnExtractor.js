"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const trace_1 = require("../utils/trace");
const Thing_1 = require("./Thing");
const ThingResolver_1 = require("./ThingResolver");
class XsnExtractor {
    extract(model, callback) {
        return new InternalXsnExtractor(model, callback).extract();
    }
}
exports.XsnExtractor = XsnExtractor;
class InternalXsnExtractor {
    constructor(model, callback) {
        this.model = model;
        this.callback = callback;
        this.resolver = new ThingResolver_1.ThingResolver();
        this._tags = new Tags();
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL);
        this.exceptions = [];
        this._definitionsToProcess = new Map();
    }
    extract() {
        this.extractTokens();
        this.extractMessages();
        this.extractExtensionDefinitions();
        this.extractDefinitionArtifacts('', this.model.definitions, true);
        let nPreviousDefs = Number.MAX_SAFE_INTEGER;
        while (this._definitionsToProcess.size < nPreviousDefs) {
            const defs = this._definitionsToProcess;
            nPreviousDefs = defs.size;
            this._definitionsToProcess = new Map();
            for (const [def, fqn] of defs) {
                const canHandle = () => {
                    const allResolved = ThingResolver_1.flatten(this.resolver.resolve(def));
                    for (const aResolved of allResolved) {
                        if (aResolved !== def && defs.has(aResolved)) {
                            this._definitionsToProcess.set(def, fqn);
                            return false;
                        }
                    }
                    return true;
                };
                if (canHandle()) {
                    this.callback.onDefinitionFound(def, fqn, this.resolver);
                }
            }
        }
        if (this._definitionsToProcess.size) {
            this.exceptions.push(new Error('Pending unprocessed definitions - potential circular'));
        }
        this.extractModelReferences();
        this.extractDependentFiles();
        this._tags = undefined;
        return this.exceptions;
    }
    extractExtensionDefinitions() {
        const crawlExtensions = (parentFqn, extensions = []) => {
            var _a;
            for (const extension of extensions) {
                if (((_a = extension === null || extension === void 0 ? void 0 : extension.name) === null || _a === void 0 ? void 0 : _a.path) && (extension === null || extension === void 0 ? void 0 : extension.kind) === 'extend') {
                    const localName = extension.name.path.map((s) => s.id).join('.');
                    const extFqn = getFqn(parentFqn, localName);
                    this.handleDefinitionThing(extFqn, extension, true);
                    this.extractDefinitionElements(extFqn, extension.elements);
                }
            }
        };
        const crawlArtifacts = (parentFqn, artifacts = Object.create(null)) => {
            for (const [localName, artifactX] of entries(artifacts)) {
                const artifactFqn = (artifactX.kind === 'source')
                    ? artifactX.namespace ? ThingResolver_1.getFullyQualifiedName(artifactX.namespace) : ''
                    : getFqn(parentFqn, localName);
                for (const artifact of ThingResolver_1.flatten(artifactX)) {
                    crawlExtensions(artifactFqn, artifact.extensions);
                    crawlArtifacts(artifactFqn, artifact.artifacts);
                }
            }
        };
        crawlArtifacts('', this.model.sources);
    }
    extractTokens() {
        for (const [localPath, source] of Object.entries(this.model.sources)) {
            if (source) {
                tryCatch(this.exceptions, () => {
                    this.callback.onTokensFound(localPath, localPath.endsWith('.cds') ? source.tokenStream.tokens : []);
                });
            }
        }
    }
    extractMessages() {
        tryCatch(this.exceptions, () => {
            const allMessages = new Map();
            const addMessages = (messages = []) => messages.forEach(m => {
                if (m && Thing_1.locationOf(m) && Thing_1.locationOf(m).filename) {
                    let fileMessages = allMessages.get(Thing_1.locationOf(m).filename);
                    if (!fileMessages) {
                        fileMessages = new Set();
                        allMessages.set(Thing_1.locationOf(m).filename, fileMessages);
                    }
                    fileMessages.add(m);
                }
            });
            addMessages(this.model.messages);
            Object.values(this.model.sources || {}).forEach(sourceNode => addMessages(sourceNode.messages));
            for (const [filepath, fileMessages] of allMessages.entries()) {
                this.callback.onMessagesFound(filepath, [...fileMessages]);
            }
        });
    }
    extractDependentFiles() {
        tryCatch(this.exceptions, () => {
            Object.entries(this.model.sources).forEach(([absoluteLocalPath, source]) => {
                const depPaths = (source.dependencies || [])
                    .filter(dep => dep.realname)
                    .map(dep => dep.realname);
                this.callback.onDirectDependenciesFound(absoluteLocalPath, depPaths);
            });
        });
    }
    extractDefinitionElements(parentFqn, elements = Object.create(null)) {
        for (const [id, element] of entries(elements)) {
            if (!id) {
                this.tracer.warn(() => `extractDefinitionElements: element without id: ${util.inspect(elements, true, 3)}`);
                continue;
            }
            const els = ThingResolver_1.flatten(element);
            for (const el of els) {
                const fqn = getFqn(parentFqn, id);
                if (el) {
                    if (this._tags.isAlreadyVisited(el)) {
                        continue;
                    }
                    if (el.kind === 'element') {
                        if (!el.$inferred ||
                            (el.$inferred !== '*' && el.$inferred !== 'include' && el.$inferred !== 'proxy' && el.$inferred !== 'localized' && el.$inferred !== 'localized-texts')) {
                            if (el.$inferred && el.$inferred !== 'query') {
                                this.tracer.warn('Unknown $inferred value ', el.$inferred);
                            }
                            this.onDefinitionFound(el, fqn);
                        }
                    }
                    else {
                        this.handleDefinitionThing(fqn, el);
                    }
                    this.extractDefinitionElements(fqn, el.elements);
                    this.extractDefinitionElements(fqn, el.enum);
                }
            }
        }
    }
    onDefinitionFound(thing, fullyQualifiedName, isExtend = false) {
        tryCatch(this.exceptions, () => {
            if (!thing) {
                return;
            }
            if (this._tags.isAlreadyVisited(thing)) {
                return;
            }
            this._tags.markVisited(thing);
            this._definitionsToProcess.set(thing, fullyQualifiedName);
        });
    }
    extractDefinitionArtifacts(parentFqn, artifacts = Object.create(null), includeNonEnumerables = false) {
        tryCatch(this.exceptions, () => {
            for (const [localName, artifactX] of entries(artifacts, includeNonEnumerables)) {
                const artifactFqn = getFqn(parentFqn, localName);
                for (const artifact of ThingResolver_1.flatten(artifactX)) {
                    if (this._tags.isAlreadyVisited(artifact)) {
                        continue;
                    }
                    this.handleDefinitionThing(artifactFqn, artifact);
                    this.extractDefinitionElements(artifactFqn, artifact.elements);
                    this.extractDefinitionElements(artifactFqn, artifact.actions);
                    this.extractDefinitionArtifacts(artifactFqn, artifact.artifacts);
                    this.extractDefinitionQueries(artifactFqn, artifact.queries);
                    this.extractDefinitionMap(artifactFqn, artifact.params);
                }
            }
        });
    }
    extractDefinitionQueries(parentFqn, queries = []) {
        tryCatch(this.exceptions, () => {
            const qs = ThingResolver_1.flatten(queries);
            for (let i = 0; i < qs.length; i++) {
                const q = qs[i];
                const queryFqn = getFqn(parentFqn, `<query${i}>`);
                if (q.mixin) {
                    const mixinFqn = getFqn(queryFqn, '<mixin>');
                    this.extractDefinitionElements(mixinFqn, q.mixin);
                }
                this.extractDefinitionQueries(queryFqn, q.queries);
            }
        });
    }
    extractModelReferences() {
        for (const [, source] of entries(this.model.sources)) {
            this.extractSource(source);
        }
    }
    extractSource(source) {
        this.extractUsings(source.usings);
        this.extractExtensions(source.extensions);
        this.extractArtifacts(source.artifacts);
    }
    extractUsings(usings = []) {
        for (const using of usings) {
            this.handleThing(using);
            this.extractAnnotationAssignments(using);
            const handleUsing = (using1) => {
                if (using1.extern && using1.extern.path) {
                    this.extractPath(using1.extern.path);
                }
            };
            if (using.extern) {
                handleUsing(using);
            }
            if (using.usings) {
                for (const using1 of using.usings) {
                    handleUsing(using1);
                }
            }
        }
    }
    extractExtensions(extensions = []) {
        for (const extension of extensions) {
            this.handleThing(extension);
            this.extractAnnotationAssignments(extension);
            this.extractElements(extension.elements);
            if (extension.name) {
                this.extractPath(extension.name.path);
            }
        }
    }
    extractArtifacts(artifacts = Object.create(null)) {
        for (const [, artifactX] of entries(artifacts)) {
            for (const artifact of ThingResolver_1.flatten(artifactX)) {
                this.handleThing(artifact);
                if (artifact.name && artifact.name.path) {
                    this.extractPath(artifact.name.path);
                }
                this.extractExtensions(artifact.extensions);
                this.extractAnnotationAssignments(artifact);
                this.extractElements(artifact.elements, artifact.kind);
                this.extractArtifacts(artifact.artifacts);
                this.extractIncludes(artifact.includes);
                this.extractQueries(artifact.queries);
                this.extractElements(artifact.params);
                this.extractElements(artifact.actions);
                this.extractType(artifact.returns);
                this.extractType(artifact);
            }
        }
    }
    extractDefinitionMap(parentFqn, map) {
        for (const [id, thing] of entries(map)) {
            const fqn = getFqn(parentFqn, id);
            this.handleDefinitionThing(fqn, thing);
        }
    }
    extractIncludes(arr = []) {
        for (const thing of arr) {
            if (thing.path) {
                this.extractPath(thing.path);
            }
            else {
                this.handleThing(thing);
            }
        }
    }
    extractPath(arr = []) {
        for (let segmentIndex = 0; segmentIndex < arr.length; segmentIndex++) {
            tryCatch(this.exceptions, () => {
                const segment = arr[segmentIndex];
                if (segment._artifact) {
                    this.handleThing(segment);
                }
                else {
                    const getSegmentName = (seg) => seg.id;
                    for (let previousSegmentIndex = segmentIndex - 1; previousSegmentIndex >= 0; previousSegmentIndex--) {
                        const previousSegment = arr[previousSegmentIndex];
                        if (previousSegment._artifact) {
                            const maxResolvedItems = this.resolver.resolve(previousSegment._artifact);
                            for (let maxResolvedItem of maxResolvedItems) {
                                for (let k = previousSegmentIndex + 1; k <= segmentIndex; k++) {
                                    const segmentName = getSegmentName(arr[k]);
                                    if (maxResolvedItem.elements && maxResolvedItem.elements[segmentName]) {
                                        maxResolvedItem = maxResolvedItem.elements[segmentName];
                                        continue;
                                    }
                                    if (maxResolvedItem.artifacts && maxResolvedItem.artifacts[segmentName]) {
                                        maxResolvedItem = maxResolvedItem.artifacts[segmentName];
                                        continue;
                                    }
                                    maxResolvedItem = null;
                                    break;
                                }
                                if (maxResolvedItem) {
                                    segment._artifact = maxResolvedItem;
                                    if (segment._artifact) {
                                        this.handleThing(segment);
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
            });
        }
    }
    extractThisTypeValue(thing) {
        if (!thing) {
            return;
        }
        this.handleThing(thing);
        this.extractType(thing.type);
        this.extractConditionArgs(thing.value);
    }
    extractQueries(arr = []) {
        for (const thing of arr) {
            this.handleThing(thing);
            this.extractElements(thing.mixin);
            this.extractElements(thing.elements);
            this.extractConditionArgs(thing.from);
            this.extractConditionArgs(thing.on);
            this.extractConditionArgs(thing.where);
            this.extractArray(thing.groupBy);
            this.extractConditionArgs(thing.having);
            this.extractConditionArgs(thing.args);
            ThingResolver_1.flatten(thing.columns).forEach(col => this.extractThisTypeValue(col));
            this.extractArray(ThingResolver_1.flatten(thing.orderBy).map(ob => ob && ob.value));
            if (thing.exclude) {
                for (const [id, element] of entries(thing.exclude)) {
                    if (!element._artifact && thing.from) {
                        for (const fromEntity of ThingResolver_1.flatten(thing.from)) {
                            if (fromEntity._artifact && fromEntity._artifact.elements && fromEntity._artifact.elements[id]) {
                                element._artifact = fromEntity._artifact.elements[id];
                                break;
                            }
                        }
                    }
                }
                this.extractElements(thing.exclude);
            }
            this.extractQueries(thing.queries);
        }
    }
    extractConditionArgs(arr = []) {
        for (const thing of ThingResolver_1.flatten(arr)) {
            for (const t of ThingResolver_1.flatten(thing)) {
                this.handleThing(t);
                this.extractPath(t.path);
                this.extractConditionArgs(t.args);
                this.extractConditionArgs(t.on);
            }
        }
    }
    extractArray(arr = []) {
        for (const thing of arr) {
            if (!thing) {
                continue;
            }
            this.handleThing(thing);
            this.extractPath(thing.path);
        }
    }
    handleDefinitionThing(fqn, thing, isExtend = false) {
        const things = ThingResolver_1.flatten(thing);
        things.forEach(t => {
            if (t._artifact || t.extern || t.origin) {
                this.tracer.warn('Definition with resolvable properties: ', t);
                return;
            }
            tryCatch(this.exceptions, () => {
                this.onDefinitionFound(t, fqn, isExtend);
            });
        });
    }
    handleThing(thing, hint) {
        tryCatch(this.exceptions, () => {
            if (!thing) {
                return;
            }
            const handle = (t) => {
                if (this._tags.isAlreadyVisited(t)) {
                    return;
                }
                this._tags.markVisited(t);
                this.callback.onReferenceFound(t, this.resolver, hint);
            };
            if (Array.isArray(thing)) {
                thing.forEach(handle);
            }
            else if (typeof thing !== 'string' && thing[0] && thing[1]) {
                for (const t in thing) {
                    if (Object.prototype.hasOwnProperty.call(thing, t)) {
                        handle(t);
                    }
                }
            }
            else {
                handle(thing);
            }
        });
    }
    extractElements(elements = Object.create(null), hint) {
        for (const [, element] of entries(elements)) {
            if (element) {
                if (element.$inferred !== '*' && element.$inferred !== 'include' && element.$inferred !== 'proxy') {
                    this.handleThing(element, hint);
                }
                this.extractAnnotationAssignments(element);
                this.extractType(element.returns);
                this.extractElements(element.elements, hint);
                this.extractType(element);
                if (element.onCond) {
                    this.extractConditionArgs(element.onCond.args);
                }
                if (hint === 'view') {
                    this.extractConditionArgs(element.value);
                }
                if (element.value && element.$inferred !== '*') {
                    this.handleThing(element.value);
                }
            }
        }
    }
    extractType(element) {
        tryCatch(this.exceptions, () => {
            if (!element) {
                return;
            }
            if (element.items) {
                this.extractType(element.items);
            }
            const type = element.target && Thing_1.locationOf(element.target)
                ? element.target
                : element.type;
            if (type) {
                if (type.path) {
                    this.extractPath(type.path);
                }
                else {
                    this.handleThing(type);
                }
            }
        });
    }
    extractAnnotationAssignments(thing) {
        var _a;
        if (thing && thing.kind === 'block') {
            thing = thing._parent;
        }
        if (!thing) {
            return;
        }
        if (thing.$inferred === '*') {
            return;
        }
        const handleAnnotation = (assignment) => {
            if (!assignment) {
                return;
            }
            const name = assignment.name;
            if (name && name.path && name.path.length) {
                for (let i = 0; i < name.path.length; i++) {
                    const isLastSegment = i === name.path.length - 1;
                    const pathSegment = name.path[i];
                    const fqn = name.path
                        .slice(0, i + 1)
                        .map(s => s.id)
                        .join('.');
                    this.handleThing({
                        location: Thing_1.locationOf(name),
                        name: {
                            location: Thing_1.locationOf(pathSegment)
                        },
                        absolute: fqn,
                        value: isLastSegment ? (assignment.val || assignment.value) : undefined,
                        carrier: thing
                    }, 'annotation');
                }
            }
            else {
                this.handleThing(assignment, 'annotation');
            }
        };
        const annoNames = Object.keys(thing).filter(key => key.startsWith('@'));
        for (const annoName of annoNames) {
            const annotationAssignment = thing[annoName];
            handleAnnotation(annotationAssignment);
        }
        const handleAssignment = (assignment) => {
            if (!assignment)
                return;
            this.handleThing({
                location: assignment.location,
                carrier: thing
            }, 'annotationAssignment');
        };
        const assignments = (_a = thing === null || thing === void 0 ? void 0 : thing.annotationAssignments) !== null && _a !== void 0 ? _a : [];
        assignments.forEach(handleAssignment);
    }
}
function entries(obj, includeNonEnumrables = false) {
    if (!obj) {
        return [];
    }
    if (includeNonEnumrables) {
        return Object.getOwnPropertyNames(obj).map(key => [key, obj[key]]);
    }
    return Object.keys(obj).map(key => [key, obj[key]]);
}
exports.entries = entries;
function getFqn(parentFqn, localName) {
    if (parentFqn) {
        return parentFqn + '.' + localName;
    }
    return localName;
}
class Tags {
    constructor() {
        this._visited = new Map();
    }
    isAlreadyVisited(thing) {
        return thing && this._visited.has(thing);
    }
    markVisited(thing) {
        this._visited.set(thing, true);
    }
}
function tryCatch(exceptions, f) {
    try {
        f();
    }
    catch (e) {
        exceptions.push(e);
    }
}
//# sourceMappingURL=XsnExtractor.js.map