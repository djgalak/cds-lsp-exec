"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PpRuleToken_1 = require("../prettyprint/PpRuleToken");
const StringUtil_1 = require("../prettyprint/util/StringUtil");
const utils_1 = require("../utils");
const trace_1 = require("../utils/trace");
class GenericToken {
    constructor(token, uri) {
        this.uri = uri;
        this.text = token.text;
        this.line = token.line - 1;
        this.character = token.column;
        this.tokenIndex = token.tokenIndex;
    }
    toString() {
        return `${this.text}@${this.line}:${this.character}`;
    }
    get range() {
        return {
            start: {
                line: this.line,
                character: this.character
            },
            end: {
                line: this.line,
                character: this.character + this.text.length
            }
        };
    }
    get location() {
        return {
            uri: this.uri,
            range: this.range
        };
    }
    compare(position) {
        let res = this.line - position.line;
        if (res === 0) {
            res = position.character - this.character;
            if (res < 0) {
                return 1;
            }
            if (res <= this.text.length) {
                return 0;
            }
            return -1;
        }
        return Math.sign(res);
    }
}
exports.GenericToken = GenericToken;
class AnnotationAssignmentToken extends GenericToken {
    constructor(embeddedAnnotation, idToken, carrier) {
        super({ text: embeddedAnnotation, line: idToken.line + 1, column: idToken.character, tokenIndex: idToken.tokenIndex }, idToken.uri);
        this.carrier = carrier;
    }
    get range() {
        if (!this._range) {
            const lines = this.text.split(StringUtil_1.NEWLINE_REGEX);
            this._range = {
                start: {
                    line: this.line,
                    character: this.character
                },
                end: {
                    line: this.line + lines.length - 1,
                    character: lines.length === 1
                        ? this.character + this.text.length
                        : lines[lines.length - 1].length
                }
            };
        }
        return this._range;
    }
    compare(position) {
        switch (PpRuleToken_1.rangeRelativeToCursor(this.range, position)) {
            case 'tokenBeforeCursor': return -1;
            case 'tokenAfterCursor': return 1;
            default: return 0;
        }
    }
}
exports.AnnotationAssignmentToken = AnnotationAssignmentToken;
class IdentifierToken extends GenericToken {
    get definitions() {
        return this._definition;
    }
    addDefinition(target) {
        if (this._definition === undefined) {
            this._definition = target;
            return;
        }
        const alreadyKnown = (t) => t === target;
        const traceAddAdditionalDefinition = (existingDef, addDef) => {
            const tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL);
            if (tracer.isTracing(trace_1.LspTraceLevel.VERBOSE)) {
                tracer.warn(() => `Trying to redefine Token ${this.text}@${this.line}:${this.character} definition ${existingDef.fullyQualifiedName} with different definition ${addDef.fullyQualifiedName}`);
            }
        };
        if (Array.isArray(this._definition)) {
            for (const t of this._definition) {
                if (alreadyKnown(t)) {
                    return;
                }
            }
            traceAddAdditionalDefinition(this._definition[0], target);
            this._definition.push(target);
        }
        else {
            if (alreadyKnown(this._definition)) {
                return;
            }
            traceAddAdditionalDefinition(this._definition, target);
            this._definition = [this._definition, target];
        }
    }
}
exports.IdentifierToken = IdentifierToken;
class StringLiteralToken extends GenericToken {
}
exports.StringLiteralToken = StringLiteralToken;
class GenericDefinition {
    constructor(fullyQualifiedName, kind) {
        this.fullyQualifiedName = fullyQualifiedName;
        this.kind = kind;
        this._references = new Set();
        this._annotationReferences = utils_1.empty();
        this.redefinitions = new Set();
    }
    addReference(ref) {
        this._references.add(ref);
    }
    get references() {
        return [...this._references.values()];
    }
    addAnnotationReference(fqn, annotationRef) {
        const formerRef = this._annotationReferences[fqn];
        if (!formerRef) {
            this._annotationReferences[fqn] = annotationRef;
        }
        else {
            if (Array.isArray(formerRef)) {
                if (formerRef.includes(annotationRef)) {
                    trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL).warn(() => `Annotation reference '${fqn}' already known: ${annotationRef}`);
                }
                else {
                    formerRef.push(annotationRef);
                }
            }
            else {
                if (formerRef === annotationRef) {
                    trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL).warn(() => `Annotation reference '${fqn}' already known: ${formerRef}`);
                }
                else {
                    this._annotationReferences[fqn] = [formerRef, annotationRef];
                }
            }
        }
    }
    annotation(fqn) {
        return this._annotationReferences[fqn];
    }
    addRedefinition(definition) {
        this.redefinitions.add(definition);
    }
}
exports.GenericDefinition = GenericDefinition;
class ExplicitDefinition extends GenericDefinition {
    constructor(fullyQualifiedName, kind, location, nameLocation, isExtend, isMixin) {
        super(fullyQualifiedName, kind);
        this.location = location;
        this.nameLocation = nameLocation;
        this.isExtend = isExtend;
        this.isMixin = isMixin;
        this.baseDefinitions = new Set();
    }
    addReference(ref) {
        const range = ref.range;
        if (range.start.line === this.nameLocation.range.start.line
            && range.start.character === this.nameLocation.range.start.character) {
            return;
        }
        super.addReference(ref);
    }
    addBaseDefinition(baseDef) {
        this.baseDefinitions.add(baseDef);
    }
}
exports.ExplicitDefinition = ExplicitDefinition;
class ExplicitAlias extends ExplicitDefinition {
    constructor(baseDefinition, fullyQualifiedName, kind, location, nameLocation, isExtend = false) {
        super(fullyQualifiedName, kind, location, nameLocation, isExtend);
        this.baseDefinition = baseDefinition;
    }
}
exports.ExplicitAlias = ExplicitAlias;
class BuiltinDefinition extends GenericDefinition {
}
exports.BuiltinDefinition = BuiltinDefinition;
class FreeAnnotationDefinition extends GenericDefinition {
}
exports.FreeAnnotationDefinition = FreeAnnotationDefinition;
class LocationIndex {
    constructor() {
        this._uriToPosix = utils_1.empty();
    }
    forUri(uri, create = 'dummy') {
        let posix = this._uriToPosix[uri];
        if (!posix) {
            if (create === 'dummy') {
                return DUMMY_POSITION_INDEX;
            }
            else if (create === 'create') {
                posix = new PositionIndex();
                this._uriToPosix[uri] = posix;
            }
        }
        return posix;
    }
}
exports.LocationIndex = LocationIndex;
class PositionIndex {
    constructor() {
        this._rowToCharix = utils_1.empty();
    }
    inRow(row, create = 'dummy') {
        let charix = this._rowToCharix[row];
        if (!charix) {
            if (create === 'dummy') {
                return DUMMY_CHARACTER_INDEX;
            }
            else if (create === 'create') {
                charix = new CharacterIndex();
                this._rowToCharix[row] = charix;
            }
        }
        return charix;
    }
    at(position) {
        return this.inRow(position.line).atCharacter(position.character);
    }
    add(t, position) {
        this.inRow(position.line, 'create').add(t, position);
    }
    all() {
        return Object.values(this._rowToCharix).reduce((all, ci) => all.concat(...ci.all()), []);
    }
}
exports.PositionIndex = PositionIndex;
class DummyPositionIndex extends PositionIndex {
    inRow(row, create = 'dummy') { return DUMMY_CHARACTER_INDEX; }
    add(t, position) { }
}
const DUMMY_POSITION_INDEX = new DummyPositionIndex();
class CharacterIndex {
    constructor() {
        this._characterToT = utils_1.empty();
    }
    atCharacter(startCharacter) {
        return this._characterToT[startCharacter];
    }
    all() {
        return Object.values(this._characterToT);
    }
    add(t, position) {
        this._characterToT[position.character] = t;
    }
}
class DummyCharacterIndex extends CharacterIndex {
    atCharacter(startCharacter) { return undefined; }
    all() { return []; }
    add(t, position) { }
}
const DUMMY_CHARACTER_INDEX = new DummyCharacterIndex();
function sortLocations(items, getLocation) {
    return items.sort((i1, i2) => {
        const l1 = getLocation(i1);
        const l2 = getLocation(i2);
        let diff = l1.uri.localeCompare(l2.uri);
        if (!diff) {
            diff = l1.range.start.line - l2.range.start.line;
            if (!diff) {
                diff = l1.range.start.character - l2.range.start.character;
            }
        }
        return diff;
    });
}
exports.sortLocations = sortLocations;
function sortAndUniqueLocations(items, getLocation) {
    return sortLocations(items, getLocation)
        .filter((item, i, all) => i === 0 || compareLocations(getLocation(all[i - 1]), getLocation(item)));
}
exports.sortAndUniqueLocations = sortAndUniqueLocations;
function compareLocations(loc1, loc2) {
    let x = loc1.uri.localeCompare(loc2.uri);
    if (x !== 0) {
        return Math.sign(x);
    }
    x = comparePosition(loc1.range.start, loc2.range.start);
    return x !== 0
        ? x
        : comparePosition(loc1.range.end, loc2.range.end);
}
exports.compareLocations = compareLocations;
function comparePosition(pos1, pos2) {
    const x = pos1.line - pos2.line;
    return Math.sign((x !== 0)
        ? x
        : pos1.character - pos2.character);
}
exports.comparePosition = comparePosition;
//# sourceMappingURL=IndexTypes.js.map