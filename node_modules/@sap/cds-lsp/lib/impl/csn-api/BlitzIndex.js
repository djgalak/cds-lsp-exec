"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const util = require("util");
const TranslationUtils_1 = require("../services/translation/TranslationUtils");
const utils_1 = require("../utils");
const trace_1 = require("../utils/trace");
const CsnAdapter_1 = require("./CsnAdapter");
const IndexTypes_1 = require("./IndexTypes");
const Thing_1 = require("./Thing");
const ThingResolver_1 = require("./ThingResolver");
const XsnExtractor_1 = require("./XsnExtractor");
function allDefinitions(def) {
    const allDefs = new Set();
    function followDef(d) {
        if (allDefs.has(d)) {
            return;
        }
        allDefs.add(d);
        for (const redefinition of d.redefinitions) {
            followDef(redefinition);
        }
        if (d instanceof IndexTypes_1.ExplicitDefinition) {
            for (const baseDefinition of d.baseDefinitions) {
                followDef(baseDefinition);
            }
        }
    }
    flatten(def).forEach(followDef);
    return allDefs;
}
exports.allDefinitions = allDefinitions;
function localpathToUri(adapter) {
    const _localpathToUri = utils_1.empty();
    return (localpath) => {
        let uri = _localpathToUri[localpath];
        if (!uri) {
            uri = adapter.toUri(adapter.toAbsoluteLocalPath(localpath));
            _localpathToUri[localpath] = uri;
        }
        return uri;
    };
}
function tokenType(tokenTypeName) {
    let tokenTypeNumber;
    return (token) => {
        if (tokenTypeNumber === undefined) {
            const lexer = token.getTokenSource();
            for (let i = 0; i < lexer.symbolicNames.length; i++) {
                if (lexer.symbolicNames[i] === tokenTypeName) {
                    tokenTypeNumber = i;
                    break;
                }
            }
        }
        return token.type === tokenTypeNumber;
    };
}
function flatten(x) {
    return !x ? [] : Array.isArray(x) ? x : [x];
}
exports.flatten = flatten;
class FileIndex {
    constructor() {
        this._definitions = new IndexTypes_1.PositionIndex();
        this.idTokens = [];
        this.i18nTokens = [];
        this.stringTokens = [];
        this.compilerMessages = [];
        this.directDependentUris = [];
        this.statistics = new Statistics();
        this._annotationAssignments = new Map();
    }
    addAnnotationAssignment(location, embeddedAnnotation, carrier) {
        const key = (pos) => `${pos.line}:${pos.character}`;
        const k = key(location.range.start);
        if (!this._annotationAssignments.has(k)) {
            const idToken = this.idTokens.find(idTok => idTok.line === location.range.start.line && idTok.character === location.range.start.character);
            this._annotationAssignments.set(k, new IndexTypes_1.AnnotationAssignmentToken(embeddedAnnotation, idToken, carrier));
        }
    }
    get annotationAssignments() {
        return this._annotationAssignments.values();
    }
}
exports.FileIndex = FileIndex;
class Statistics {
    constructor() {
        this.tokenCount = 0;
        this.identifiers = 0;
        this.definitions = 0;
        this.references = 0;
        this.translations = 0;
        this.messages = 0;
        this.directDependencies = 0;
    }
}
class BlitzIndex {
    constructor(_mainUri, workspaceVersion) {
        this._mainUri = _mainUri;
        this.workspaceVersion = workspaceVersion;
        this.isInvalid = false;
        this._fqnToBuiltinDef = utils_1.empty();
        this._fqnToAnnotation = utils_1.empty();
        this.exceptions = [];
        this._mainStatistics = new Statistics();
        this._uriToFileIndex = utils_1.empty();
    }
    static build(mainUri, workspaceDocuments, model, workspaceVersion, adapter) {
        const tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL);
        const mainReferences = new Set();
        const _identifierTokens = new IndexTypes_1.LocationIndex();
        const identifierAt = (location) => findToken(_identifierTokens
            .forUri(location.uri)
            .inRow(location.range.start.line)
            .all(), location.range.start);
        const uniqueStrings = utils_1.empty();
        function extractionFor(index) {
            const recordReference = (ref) => {
                mainReferences.add(ref);
            };
            const toUri = localpathToUri(adapter);
            const toLspLocation = (csnLocation) => csnLocation
                ? { uri: toUri(csnLocation.filename), range: utils_1.adaptRange(csnLocation) }
                : undefined;
            const isIdentifier = (t) => t.isIdentifier;
            const isStringLiteral = tokenType('String');
            const uniquify = (s) => uniqueStrings[s] || (uniqueStrings[s] = s);
            const canon = (s) => {
                const b = Buffer.from(s);
                return uniquify(b.toString());
            };
            return {
                onTokensFound: (localpath, tokens) => {
                    const uri = adapter.toUri(localpath);
                    const fileIndex = index.forUri(uri, 'create');
                    for (let i = 0; i < tokens.length; i++) {
                        const t = tokens[i];
                        fileIndex.statistics.tokenCount++;
                        if (isIdentifier(t)) {
                            const token = new IndexTypes_1.IdentifierToken(t, uri);
                            _identifierTokens.forUri(uri, 'create').add(token, token);
                            fileIndex.idTokens.push(token);
                        }
                        else if (isStringLiteral(t)) {
                            const token = new IndexTypes_1.StringLiteralToken(t, uri);
                            const tID = TranslationUtils_1.getTranslationId(token.text);
                            if (tID !== undefined) {
                                token.translationId = tID;
                                fileIndex.i18nTokens.push(token);
                            }
                            else {
                                if (i > 0 && tokens[i - 1].text === 'from') {
                                    token.isUsingPath = true;
                                }
                                fileIndex.stringTokens.push(token);
                            }
                        }
                    }
                },
                onMessagesFound: (localPath, messages) => {
                    const uri = toUri(localPath);
                    const fileIndex = index.forUri(uri, 'create');
                    fileIndex.compilerMessages.push(...messages.map(m => CsnAdapter_1.adaptDiagnostic(m)));
                },
                onDefinitionFound: (thing, fullyQualifiedName, resolver) => {
                    var _a;
                    fullyQualifiedName = uniquify(fullyQualifiedName);
                    if (fullyQualifiedName === 'localized' || fullyQualifiedName.startsWith('localized.')) {
                        return;
                    }
                    if (thing.builtin) {
                        if (!index._fqnToBuiltinDef[fullyQualifiedName]) {
                            const bDef = new IndexTypes_1.BuiltinDefinition(thing.name.absolute, thing.kind);
                            index._fqnToBuiltinDef[bDef.fullyQualifiedName] = bDef;
                            return;
                        }
                    }
                    const thingLocation = Thing_1.locationOf(thing);
                    if (!thingLocation || thingLocation.filename === '<built-in>') {
                        if (thing.kind === 'block') {
                            const blockResolved = flatten(resolver.resolve(thing));
                            if ((blockResolved === null || blockResolved === void 0 ? void 0 : blockResolved.length) === 1) {
                                thing = blockResolved[0];
                            }
                        }
                        if (thing.kind === 'namespace') {
                            if (fullyQualifiedName === 'cds' || fullyQualifiedName === 'localized') {
                                if (!index._fqnToBuiltinDef[fullyQualifiedName]) {
                                    index._fqnToBuiltinDef[fullyQualifiedName] = new IndexTypes_1.BuiltinDefinition(fullyQualifiedName, thing.kind);
                                }
                            }
                            else {
                                tracer.warn('Skipping namespace: ', thing);
                            }
                            return;
                        }
                        if (Array.isArray(thing)) {
                            throw new Error(`ARRAY Thing without location: ${thing}`);
                        }
                        throw new Error(`Thing without location: ${thing}`);
                    }
                    const nameLocation = Thing_1.locationOf(thing === null || thing === void 0 ? void 0 : thing.name);
                    if ((nameLocation === null || nameLocation === void 0 ? void 0 : nameLocation.$weak) === true && ((_a = nameLocation === null || nameLocation === void 0 ? void 0 : nameLocation.filename) === null || _a === void 0 ? void 0 : _a.endsWith('.cds'))) {
                        return;
                    }
                    const resolved = flatten(resolver.resolve(thing));
                    const baseDefs = resolved.filter(r => r !== thing);
                    const definition = new IndexTypes_1.ExplicitDefinition(fullyQualifiedName, ThingResolver_1.getExpectedKind(thing), toLspLocation(thingLocation), toLspLocation(resolver.nameLocation(thing)), ThingResolver_1.getKind(thing) === 'extend' || ThingResolver_1.getKind(thing) === 'aspect', fullyQualifiedName.includes('<mixin>'));
                    if (tracer.isTracing(trace_1.LspTraceLevel.DEBUG)) {
                        const printLoc = (loc) => `${path.basename(loc.uri)}[${loc.range.start.line}:${loc.range.start.character}-${loc.range.end.line}:${loc.range.end.character}]`;
                        const otherLoc = definition.nameLocation.uri !== definition.location.uri ? printLoc(definition.location) : '';
                        const meth = otherLoc ? 'error' : fullyQualifiedName.includes('_texts') ? 'warn' : 'debug';
                        tracer[meth](`@@@ onDefinitionFound: ${fullyQualifiedName}@${printLoc(definition.nameLocation)} ${otherLoc}`);
                    }
                    if (fullyQualifiedName.includes('_texts')) {
                        let textsFqn;
                        if (definition.kind === 'entity' && fullyQualifiedName.endsWith('_texts')) {
                            textsFqn = fullyQualifiedName;
                        }
                        else if (definition.kind === 'element') {
                            textsFqn = fullyQualifiedName.split('.').slice(0, -1).join('.');
                        }
                        if (textsFqn) {
                            const defs = index.forUri(definition.nameLocation.uri, 'dummy')._definitions;
                            const mainDef = defs.at(definition.nameLocation.range.start);
                            if (mainDef && IndexTypes_1.compareLocations(mainDef.nameLocation, definition.nameLocation) === 0) {
                                tracer.verbose(() => `${trace_1.Ansi.SUCCESS}found main definition ${mainDef.fullyQualifiedName}${trace_1.Ansi.RESET}, skipping ${fullyQualifiedName}`);
                                return;
                            }
                            else {
                                tracer.verbose(() => `${trace_1.Ansi.ERROR}no main definition found for ${fullyQualifiedName}${trace_1.Ansi.RESET}, keeping it`);
                            }
                        }
                    }
                    if (fullyQualifiedName.endsWith('.localized')) {
                        tracer.warn(`Localized: ${fullyQualifiedName} ${thing.kind} ${thing.$inferred}`);
                    }
                    index
                        .forUri(definition.nameLocation.uri, 'create')
                        ._definitions
                        .add(definition, definition.nameLocation.range.start);
                    const position = definition.nameLocation.range.start;
                    const token = _identifierTokens.forUri(definition.nameLocation.uri).at(position);
                    if (token instanceof IndexTypes_1.IdentifierToken) {
                        token.addDefinition(definition);
                    }
                    if (definition.kind === 'annotation') {
                        index._fqnToAnnotation[fullyQualifiedName] = definition;
                    }
                    else if (definition.kind === 'element') {
                        const segments = fullyQualifiedName.split('.');
                        const fqn = segments.slice(0, -1).join('.');
                        const annoParent = index._fqnToAnnotation[fqn];
                        if (annoParent) {
                            index._fqnToAnnotation[fullyQualifiedName] = definition;
                        }
                    }
                    baseDefs
                        .map(bd => toLspLocation(resolver.nameLocation(bd)))
                        .forEach(loc => {
                        if (loc) {
                            const baseDef = index.definitionAt(loc.uri, loc.range.start);
                            if (baseDef) {
                                definition.addBaseDefinition(baseDef);
                                baseDef.addRedefinition(definition);
                            }
                        }
                    });
                },
                onReferenceFound: (refThing, resolver, hint) => {
                    function anyLocation(thing) {
                        return (thing.name && resolver.nameLocation(thing)) || Thing_1.locationOf(thing);
                    }
                    if (hint === 'annotationAssignment') {
                        const annotationLocation = toLspLocation(anyLocation(refThing));
                        let embeddedContent = new utils_1.TextLines(workspaceDocuments[annotationLocation.uri]).getText(annotationLocation.range);
                        const matchEmbeddedContent = embeddedContent.match(/@?\s*(.*)$/s);
                        if (matchEmbeddedContent) {
                            annotationLocation.range.start.character += embeddedContent.indexOf(matchEmbeddedContent[1]);
                            embeddedContent = matchEmbeddedContent[1];
                        }
                        const fileIndex = index.forUri(annotationLocation.uri);
                        const carrierLocation = toLspLocation(anyLocation(refThing.carrier));
                        const carrierIdentifier = index.identifierAt(carrierLocation.uri, carrierLocation.range.start);
                        fileIndex.addAnnotationAssignment(annotationLocation, embeddedContent, carrierIdentifier);
                        return;
                    }
                    if (!Thing_1.locationOf(refThing)) {
                        if (refThing.kind === 'namespace') {
                            tracer.error('REF: Skipping namespace: ', refThing);
                            return;
                        }
                        if (typeof refThing === 'object' && refThing.kind !== 'block') {
                            const fq = ThingResolver_1.getFullyQualifiedName(refThing);
                            tracer.error(() => `REF: Thing ${fq} without location: ${refThing}`);
                        }
                        return;
                    }
                    const lspLocation = toLspLocation(anyLocation(refThing));
                    if (lspLocation.range.start.line !== lspLocation.range.end.line) {
                        return;
                    }
                    const token = _identifierTokens.forUri(lspLocation.uri).at(lspLocation.range.start);
                    if (!token ||
                        token.text.length !== lspLocation.range.end.character - lspLocation.range.start.character) {
                        return;
                    }
                    const handleAnnotation = (fqn, carrierThing) => {
                        if (fqn) {
                            const annotationDefinition = index._fqnToBuiltinDef[fqn] || index._fqnToAnnotation[fqn] || (index._fqnToAnnotation[fqn] = new IndexTypes_1.FreeAnnotationDefinition(fqn, refThing.kind));
                            const known = mainReferences.has(token);
                            const refIsStringLiteral = typeof refThing.value === 'string';
                            if (known) {
                                if (refIsStringLiteral && !(token.annotationValue)) {
                                    tracer.error('Reference is already known but of different type');
                                }
                                return;
                            }
                            if (refIsStringLiteral) {
                                token.annotationValue = refThing.value;
                            }
                            const annotationRef = token;
                            annotationDefinition.addReference(annotationRef);
                            recordReference(annotationRef);
                            const resolvedCarriers = flatten(resolver.resolve(carrierThing));
                            resolvedCarriers.forEach(res => {
                                const carrierLoc = toLspLocation(resolver.nameLocation(res));
                                const carrierDef = carrierLoc && index.definitionAt(carrierLoc.uri, carrierLoc.range.start);
                                if (carrierDef) {
                                    carrierDef.addAnnotationReference(fqn, annotationRef);
                                }
                            });
                            const idToken = identifierAt(lspLocation);
                            if (idToken) {
                                idToken.addDefinition(annotationDefinition);
                            }
                        }
                    };
                    if (hint === 'annotation') {
                        const fqn = refThing.absolute;
                        handleAnnotation(fqn, refThing.carrier || refThing);
                        return;
                    }
                    else if (refThing.literal && refThing.literal !== 'string') {
                        return;
                    }
                    const resolved = resolver.resolve(refThing);
                    const resolvedDefs = flatten(resolved);
                    if (!resolvedDefs.length) {
                        const unresIdToken = identifierAt(lspLocation);
                        if (unresIdToken) {
                            tracer.error(() => `Given ref only resolved via token: ${unresIdToken.text}@${unresIdToken.line}:${unresIdToken.character}`);
                        }
                        else {
                            tracer.error(() => `No identifier token found for given reference thing @${lspLocation.range.start.line}:${lspLocation.range.start.character}`);
                        }
                        return;
                    }
                    for (const resolvedDef of resolvedDefs) {
                        let def;
                        if (resolvedDef.builtin || !Thing_1.locationOf(resolvedDef) || (resolvedDef.name && Thing_1.locationOf(resolvedDef.name) && Thing_1.locationOf(resolvedDef.name).filename === '<built-in>')) {
                            const resFqn = resolvedDef.name.absolute;
                            def = index._fqnToBuiltinDef[resFqn];
                        }
                        else {
                            const lspLoc = toLspLocation(anyLocation(resolvedDef));
                            def = index
                                .forUri(lspLoc.uri)
                                ._definitions
                                .inRow(lspLoc.range.start.line)
                                .atCharacter(lspLoc.range.start.character);
                        }
                        if (def) {
                            def.addReference(token);
                            token.addDefinition(def);
                        }
                        else {
                            if (resolvedDef.op) {
                                continue;
                            }
                            if (resolvedDef.kind === 'enum symbol') {
                                continue;
                            }
                            if (refThing.$duplicate !== true && resolvedDef.$duplicate !== true && resolvedDef.kind !== 'builtin') {
                                if (tracer.isTracing(trace_1.LspTraceLevel.VERBOSE)) {
                                    tracer.warn(() => `No def found for ref ${lspLocation.uri}@${utils_1.renderRange(lspLocation.range)}, resolved is `, util.inspect(resolvedDef, { depth: 2 }));
                                }
                            }
                        }
                    }
                },
                onDirectDependenciesFound: (absoluteLocalPath, dependentAbsoluteLocalPaths) => {
                    const toUniqueUri = (filePath) => canon(adapter.toUri(filePath));
                    const uri = toUniqueUri(absoluteLocalPath);
                    const fileIndex = index.forUri(uri, 'create');
                    fileIndex.directDependentUris = dependentAbsoluteLocalPaths.map(toUniqueUri);
                }
            };
        }
        const blitz = new BlitzIndex(mainUri, workspaceVersion);
        blitz.exceptions = new XsnExtractor_1.XsnExtractor().extract(model, extractionFor(blitz));
        if (blitz.exceptions.length) {
            tracer.error(blitz.exceptions.reduce((s, e) => s + '\n--------\n' + (e.stack || e), 'Exceptions during AST extraction:'));
        }
        const mainStatistics = blitz._mainStatistics;
        Object.entries(blitz._uriToFileIndex).forEach(([, fileIndex]) => {
            const fileStats = fileIndex.statistics;
            fileStats.definitions = fileIndex._definitions.all().length;
            fileStats.translations = fileIndex.i18nTokens.length;
            fileStats.identifiers = fileIndex.idTokens.length;
            fileStats.directDependencies = fileIndex.directDependentUris.length;
            fileStats.messages = fileIndex.compilerMessages.length;
            mainStatistics.tokenCount += fileStats.tokenCount;
            mainStatistics.definitions += fileStats.definitions;
            mainStatistics.translations += fileStats.translations;
            mainStatistics.identifiers += fileStats.identifiers;
            mainStatistics.directDependencies += fileStats.directDependencies;
            mainStatistics.messages += fileStats.messages;
        });
        tracer.footprint(`computing reference statistics for ${blitz._mainUri}`, () => {
            mainReferences.forEach(r => blitz.forUri(r.uri).statistics.references++);
        });
        mainStatistics.references = mainReferences.size;
        return blitz;
    }
    getTransitiveDependencies(uri) {
        const hull = new Set();
        this._transitiveDependencies(uri, hull, new Set());
        hull.delete(uri);
        return hull;
    }
    _transitiveDependencies(uri, hull, alreadyFollowed) {
        hull.add(uri);
        if (alreadyFollowed.has(uri)) {
            return;
        }
        alreadyFollowed.add(uri);
        const fileIndex = this.forUri(uri);
        if (fileIndex) {
            const directDeps = fileIndex.directDependentUris;
            if (directDeps) {
                directDeps.forEach(d => this._transitiveDependencies(d, hull, alreadyFollowed));
            }
        }
    }
    forUri(uri, create = 'warnCreate') {
        let fileIndex = this._uriToFileIndex[uri];
        if (!fileIndex) {
            if (create === 'warnCreate') {
                trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL).warn(() => `Access for uri ${uri} in index ${this._mainUri} created empty file index`);
            }
            fileIndex = new FileIndex();
            this._uriToFileIndex[uri] = fileIndex;
        }
        return fileIndex;
    }
    get builtUris() {
        return Object.keys(this._uriToFileIndex);
    }
    get stats() {
        const stats = this._mainStatistics;
        return `${stats.tokenCount} tokens, ${stats.identifiers} identifiers, ${stats.definitions} definitions, ${stats.references} references, ${stats.translations} translation strings, ${stats.messages} messages, ${stats.directDependencies} dependencies`;
    }
    correspondingDefinition(def) {
        if (def instanceof IndexTypes_1.ExplicitDefinition) {
            return this.definitionAt(def.nameLocation.uri, def.nameLocation.range.start);
        }
        return this.definitionFor(def.fullyQualifiedName);
    }
    definitionAt(uri, position) {
        return this.forUri(uri)._definitions.inRow(position.line).atCharacter(position.character);
    }
    definitionFor(fqn) {
        return this._fqnToBuiltinDef[fqn] || this._fqnToAnnotation[fqn];
    }
    getOwnDefinitions(uri) {
        return this.forUri(uri)._definitions.all();
    }
    identifierAt(uri, position) {
        return findToken(this.forUri(uri).idTokens, position);
    }
    stringAt(uri, position) {
        return findToken(this.forUri(uri).i18nTokens, position) || findToken(this.forUri(uri).stringTokens, position);
    }
    correspondingStringTokens(text) {
        const sameText = (t) => t.text === text;
        return Object.entries(this._uriToFileIndex)
            .reduce((all, [, fileIndex]) => all.concat(fileIndex.i18nTokens.filter(sameText)
            .concat(fileIndex.stringTokens.filter(sameText))), []);
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, {
        argumentsRenderer: args => args[0],
        resultRenderer: (index) => index.stats,
        trackMemory: true
    })
], BlitzIndex, "build", null);
exports.BlitzIndex = BlitzIndex;
function findToken(tokens, position, start = 0, end = tokens.length - 1) {
    if (typeof position === 'number') {
        return binSearch(tokens, position, (tok, pos) => tok.tokenIndex - pos, start, end);
    }
    return binSearch(tokens, position, (tok, pos) => tok.compare(pos), start, end);
}
exports.findToken = findToken;
function toSymbolInfo(def) {
    const nameSegments = def.fullyQualifiedName.split('.');
    switch (def.kind) {
        case 'context':
        case 'service':
        case 'namespace':
            return {
                name: def.fullyQualifiedName,
                containerName: '',
                location: def.location,
                kind: utils_1.adaptSymbolKind(def.kind)
            };
        default:
            return {
                name: shortName(def, nameSegments),
                containerName: nameSegments.slice(0, -1).join('.'),
                location: def.location,
                kind: utils_1.adaptSymbolKind(def.kind)
            };
    }
}
exports.toSymbolInfo = toSymbolInfo;
function shortName(def, segments = def.fullyQualifiedName.split('.')) {
    return segments.slice(-1)[0];
}
exports.shortName = shortName;
function binSearch(a, x, compare, start = 0, end = a.length - 1) {
    if (start > end) {
        return undefined;
    }
    const mid = Math.floor((start + end) / 2);
    const comparison = compare(a[mid], x);
    if (comparison === 0) {
        return a[mid];
    }
    if (comparison > 0) {
        return binSearch(a, x, compare, start, mid - 1);
    }
    return binSearch(a, x, compare, mid + 1, end);
}
exports.binSearch = binSearch;
//# sourceMappingURL=BlitzIndex.js.map