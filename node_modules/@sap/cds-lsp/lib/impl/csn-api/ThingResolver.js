"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Thing_1 = require("./Thing");
class ThingResolver {
    resolve(thing, options = { step: 'ToDefinition' }) {
        const resolvedItems = this._resolve(thing);
        const totallyResolved = [];
        for (const resolvedItem of resolvedItems) {
            if (resolvedItem === thing) {
                totallyResolved.push(...flatten(resolvedItem));
            }
            else {
                totallyResolved.push(...this.resolve(resolvedItem));
            }
        }
        return totallyResolved;
    }
    _resolve(thing) {
        let tArtifact = thing._artifact;
        if (!tArtifact && thing.origin) {
            tArtifact = thing.origin;
        }
        if (!tArtifact && thing.extern && thing.kind === 'using') {
            tArtifact = thing.extern;
        }
        const aArtifacts = flatten(tArtifact);
        const resolvedThings = [];
        for (const tArt of aArtifacts) {
            resolvedThings.push(resolveSingle(thing, tArt));
        }
        return resolvedThings;
        function resolveSingle(aThing, artifact) {
            if (artifact) {
                return artifact;
            }
            const tName = aThing.name;
            if (tName) {
                if (tName._artifact) {
                    return tName._artifact;
                }
                if (tName.path && tName.path.length) {
                    const lastPathSegment = tName.path[tName.path.length - 1];
                    if (lastPathSegment._artifact) {
                        return lastPathSegment._artifact;
                    }
                }
            }
            const t = aThing;
            if (tName && tName.absolute && t._deps && !t.$replacement) {
                for (const dep of t._deps) {
                    if (dep.art && dep.art.name && dep.art.name.absolute === tName.absolute && !dep.art.name.element) {
                        return dep.art;
                    }
                }
            }
            return aThing;
        }
    }
    nameLocation(thing) {
        if (!(thing === null || thing === void 0 ? void 0 : thing.name)) {
            return Thing_1.locationOf(thing);
        }
        const name = thing.name;
        if (name.path) {
            const lastSegment = name.path.slice(-1)[0];
            if (Thing_1.locationOf(lastSegment)) {
                return Thing_1.locationOf(lastSegment);
            }
        }
        if (name.absolute && name.id && name.absolute.length !== name.id.length && name.absolute.endsWith(name.id)) {
            const loc = Thing_1.locationOf(name);
            if (loc) {
                if (loc.start.line === loc.end.line) {
                    if (loc.end.column - loc.start.column > name.id.length) {
                        return {
                            filename: loc.filename,
                            start: {
                                line: loc.start.line,
                                column: loc.end.column - name.id.length
                            }, end: loc.end
                        };
                    }
                }
            }
        }
        return Thing_1.locationOf(thing.name);
    }
}
exports.ThingResolver = ThingResolver;
function flatten(x) {
    if (Array.isArray(x)) {
        return x;
    }
    return [x];
}
exports.flatten = flatten;
function getLocation(thing) {
    return Thing_1.locationOf(thing);
}
exports.getLocation = getLocation;
function getFullyQualifiedName(thing) {
    let node = thing;
    let name = '';
    if (node) {
        if (node.extern) {
            node = node.extern;
        }
        if (node.origin) {
            node = node.origin;
        }
        let x;
        if (node._artifact) {
            x = node._artifact.name;
        }
        else if (node.name) {
            x = node.name;
        }
        if (x && !x.absolute && x._artifact) {
            x = x._artifact.name;
        }
        if (x) {
            name = x.absolute || '';
            if (x.element) {
                name += '.' + x.element;
            }
            if (!name) {
                node = x;
                x = undefined;
            }
        }
        if (!x) {
            if (node.path) {
                return node.path.map((s) => s.id).join('.');
            }
        }
    }
    return name;
}
exports.getFullyQualifiedName = getFullyQualifiedName;
function getKind(thing) {
    return thing.kind;
}
exports.getKind = getKind;
function getExpectedKind(thing) {
    let cursor = thing;
    while (cursor && getKind(cursor) === 'extend') {
        cursor = (cursor.name && cursor.name._artifact) || null;
    }
    let expectedKind = cursor ? getKind(cursor) : undefined;
    if (expectedKind === 'entity' && cursor.projection) {
        expectedKind = 'view';
    }
    return expectedKind || thing.expectedKind;
}
exports.getExpectedKind = getExpectedKind;
function getSymbolLocation(thing) {
    const node = thing;
    return Thing_1.locationOf(node === null || node === void 0 ? void 0 : node.name) || Thing_1.locationOf(node);
}
exports.getSymbolLocation = getSymbolLocation;
//# sourceMappingURL=ThingResolver.js.map