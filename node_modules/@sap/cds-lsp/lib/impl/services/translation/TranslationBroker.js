"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path_1 = require("path");
const path = require("path");
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
const CsvIndex_1 = require("./CsvIndex");
const JsonIndex_1 = require("./JsonIndex");
const PropertiesIndex_1 = require("./PropertiesIndex");
class TranslationBroker {
    constructor(workspaceFolder) {
        this.workspaceFolder = workspaceFolder;
        this.translationIndexes = new Map();
        this._fileOrder = [];
        this._sourcePathToI18nFolderPath = new Map();
        this._cdsEnvI18nFoldersUsedForCache = [];
    }
    reset() {
        this.translationIndexes.clear();
        this._fileOrder = [];
        this._sourcePathToI18nFolderPath.clear();
        this._cdsEnvI18nFoldersUsedForCache = [];
    }
    onTranslationFileChanged(cdsEnv, uri, content) {
        if (content === undefined) {
            this.translationIndexes.delete(uri);
        }
        else {
            this.translationIndexes.set(uri, this.createIndex(cdsEnv, uri, content));
        }
        this._fileOrder = this.calculateFileOrder();
    }
    getTranslation(translationId) {
        for (const uri of this._fileOrder) {
            const translation = this.translationIndexes.get(uri).getEntry(translationId);
            if (translation) {
                return translation;
            }
        }
        return undefined;
    }
    async fetchAllTranslations(sourceFileUri) {
        const tUris = await this.fetchMostRelevantTranslationFileUris(sourceFileUri);
        const idToTrans = new Map();
        tUris.reverse();
        for (const tUri of tUris) {
            for (const translation of this.translationIndexes.get(tUri).entries) {
                idToTrans.set(translation.id, translation);
            }
        }
        return [...idToTrans.values()];
    }
    async fetchMostRelevantTranslationFileUris(forSourceUri) {
        const wsf = this.workspaceFolder;
        const isDirectSource = (uri) => {
            if (uri.startsWith(wsf.workspaceUri)) {
                const wsRelativePath = uri.slice(wsf.workspaceUri.length + 1);
                return !wsRelativePath.includes('node_modules/');
            }
            return true;
        };
        if (!isDirectSource(forSourceUri))
            return undefined;
        const i18nFolder = await this.fetchI18nFolder(forSourceUri);
        if (!i18nFolder) {
            return undefined;
        }
        const tUris = this._fileOrder.filter(someTUri => path_1.dirname(utils_1.toLocalPath(someTUri)) === i18nFolder);
        if (tUris.length) {
            return tUris;
        }
        const cdsEnv = await wsf.fetchCdsEnv();
        return [wsf.adapter.toUri(path.join(i18nFolder, `${cdsEnv.i18n.file}${cdsEnv.i18n.fallback_bundle ? '_' + cdsEnv.i18n.fallback_bundle : ''}.properties`))];
    }
    async fetchI18nFolder(sourceFileUri) {
        const env = await this.workspaceFolder.fetchCdsEnv();
        const envI18nFoldersChanged = (currentFolders) => {
            const previousFolders = this._cdsEnvI18nFoldersUsedForCache;
            if (currentFolders === previousFolders)
                return false;
            if (currentFolders.length !== previousFolders.length)
                return true;
            for (const currentFolder of currentFolders) {
                if (!previousFolders.includes(currentFolder))
                    return true;
            }
            return false;
        };
        if (envI18nFoldersChanged(env.i18n.folders)) {
            this._cdsEnvI18nFoldersUsedForCache = env.i18n.folders;
            this._sourcePathToI18nFolderPath.clear();
        }
        if (utils_1.Untitled.isUntitledFile(sourceFileUri))
            return undefined;
        const localPath = path_1.dirname(utils_1.toLocalPath(sourceFileUri));
        const defaultI18nFolder = () => {
            if (localPath.startsWith(this.workspaceFolder.workspaceRoot)) {
                const defaultPath = path.join(this.workspaceFolder.workspaceRoot, env.i18n.folders[0] || 'i18n');
                return defaultPath;
            }
            return undefined;
        };
        const knownI18nFolders = this._fileOrder.map(f => path_1.dirname(utils_1.toLocalPath(f)));
        const detectI18nFolderIn = (folder) => {
            const cached = this._sourcePathToI18nFolderPath.get(folder);
            if (cached)
                return cached;
            for (const relativeI18nFolder of env.i18n.folders) {
                const i18nFolder = path.join(folder, relativeI18nFolder);
                if (knownI18nFolders.includes(i18nFolder) || fs.existsSync(i18nFolder)) {
                    this._sourcePathToI18nFolderPath.set(folder, i18nFolder);
                    return i18nFolder;
                }
            }
            return undefined;
        };
        const walk = (folder) => {
            const i18nFolder = detectI18nFolderIn(folder);
            if (i18nFolder)
                return i18nFolder;
            const parentFolder = path_1.dirname(folder);
            const isWithinWorkspaceFolder = parentFolder.startsWith(this.workspaceFolder.workspaceRoot);
            if (isWithinWorkspaceFolder)
                return walk(parentFolder);
            const isGitRoot = fs.existsSync(path.join(folder, '.git'));
            if (isGitRoot)
                return undefined;
            const isDeviceRoot = parentFolder === folder;
            if (isDeviceRoot)
                return undefined;
            return walk(parentFolder);
        };
        return walk(localPath) || defaultI18nFolder();
    }
    async fetchTranslationIndex(translationFileUri) {
        let index = this.translationIndexes.get(translationFileUri);
        if (!index) {
            const cdsEnv = await this.workspaceFolder.fetchCdsEnv();
            index = this.createIndex(cdsEnv, translationFileUri, (await this.workspaceFolder.fetchSourceFiles())[translationFileUri]);
            this.translationIndexes.set(translationFileUri, index);
        }
        return index;
    }
    createIndex(cdsEnv, translationFileUri, content) {
        const createIndex = {
            '.properties': () => new PropertiesIndex_1.PropertiesIndex(translationFileUri),
            '.json': () => new JsonIndex_1.JsonIndex(translationFileUri),
            '.csv': () => new CsvIndex_1.CsvIndex(translationFileUri)
        };
        const extension = path_1.extname(translationFileUri);
        const index = createIndex[extension]();
        index.index(cdsEnv, content);
        return index;
    }
    calculateFileOrder() {
        const basename = (uri) => path.basename(uri, '.properties');
        return [...this.translationIndexes.keys()].sort((uri1, uri2) => {
            const dirname1 = path.dirname(uri1);
            const dirname2 = path.dirname(uri2);
            return (dirname1 === dirname2)
                ? basename(uri1).localeCompare(basename(uri2))
                : dirname1.localeCompare(dirname2);
        });
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.DOCUMENTATION, { argumentsRenderer: args => `${args[2] ? '<update> ' : '<delete> '}${args[1]}` })
], TranslationBroker.prototype, "onTranslationFileChanged", null);
exports.TranslationBroker = TranslationBroker;
//# sourceMappingURL=TranslationBroker.js.map