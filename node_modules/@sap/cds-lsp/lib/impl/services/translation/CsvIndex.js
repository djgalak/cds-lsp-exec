"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
exports.BOM = '\ufeff';
class CsvIndex extends utils_1.I18nIndex {
    constructor() {
        super(...arguments);
        this.separator = ';';
    }
    index(cdsEnv, content = '') {
        const translations = new Map();
        try {
            const [header, ...rows] = this.parse(content, cdsEnv);
            this.nLanguages = header ? header.length - 1 : 0;
            if (!header)
                return;
            const collectEntries = (lang) => {
                const getLangIndex = (l) => header.findIndex((posAndVal) => posAndVal.value === l);
                let langIndex = getLangIndex(lang);
                if (langIndex < 0)
                    langIndex = getLangIndex((lang.match(/[a-zA-Z]+/) || [])[0]);
                if (langIndex > 0) {
                    for (const row of rows) {
                        const t = row[langIndex];
                        if (t) {
                            const tID = row[0].value;
                            if (t.value || !translations.has(tID) || !translations.get(tID).text) {
                                translations.set(tID, {
                                    text: t.value,
                                    id: tID,
                                    line: t.position.line,
                                    character: t.position.character,
                                    uri: this.uri
                                });
                            }
                        }
                    }
                }
                return langIndex > 0 ? langIndex : undefined;
            };
            this.defLangIndex = collectEntries(cdsEnv.i18n.default_language);
            this.fallbackLangIndex = collectEntries(cdsEnv.i18n.fallback_bundle);
        }
        finally {
            this.content = content;
            this.map = translations;
        }
    }
    createEntry(cdsEnv, tID, translationType) {
        var _a, _b, _c;
        const AFTER_LAST_LINE = 999999;
        const findInsertionLine = () => {
            for (const [, translation] of this.map.entries()) {
                if (tID.localeCompare(translation.id) < 0) {
                    return translation.line;
                }
            }
            return AFTER_LAST_LINE;
        };
        let line = this.nLanguages ? (_a = this.map.get(tID)) === null || _a === void 0 ? void 0 : _a.line : undefined;
        const lineExists = line !== undefined;
        line = line !== null && line !== void 0 ? line : findInsertionLine();
        const langIndex = (_c = (_b = this.fallbackLangIndex) !== null && _b !== void 0 ? _b : this.defLangIndex) !== null && _c !== void 0 ? _c : 1;
        if (lineExists) {
            const entry = this.map.get(tID);
            return [{
                    newText: utils_1.ADD_TEXT_HERE,
                    range: {
                        start: { line: entry.line, character: entry.character },
                        end: { line: entry.line, character: entry.character },
                    }
                }];
        }
        let newText = tID;
        let nLangs = this.nLanguages;
        if (nLangs === 0) {
            newText = `${exports.BOM}ID${this.separator}${cdsEnv.i18n.fallback_bundle}\n` + newText;
            nLangs = 1;
        }
        for (let i = 0; i < nLangs; i++) {
            newText += this.separator;
            if (i + 1 === langIndex) {
                newText += utils_1.ADD_TEXT_HERE;
            }
        }
        newText += '\n';
        if (line === AFTER_LAST_LINE && this.nLanguages) {
            if (!this.content.endsWith('\n')) {
                newText = '\n' + newText;
            }
        }
        return [{
                newText,
                range: {
                    start: { line, character: 0 },
                    end: { line, character: 0 }
                }
            }];
    }
    parse(content, cdsEnv) {
        const rows = [];
        if (content[0] === exports.BOM)
            content = content.slice(1);
        this.separator = content.match(/([,;\t])/)
            ? RegExp.$1
            : ';';
        content
            .split(/\s*\r?\n/)
            .forEach((line, lineNumber) => {
            const values = [];
            let value = '';
            let valColumn = 0;
            let c;
            for (let columnNumber = 0; columnNumber < line.length;) {
                c = line[columnNumber++];
                if (c === this.separator) {
                    values.push({
                        position: {
                            line: lineNumber,
                            character: valColumn
                        },
                        value
                    });
                    valColumn = columnNumber;
                    value = '';
                }
                else if (c === '"') {
                    if (line[columnNumber] === '"')
                        value += line[columnNumber++];
                    else {
                        while (columnNumber < line.length) {
                            const escapedC = line[columnNumber++];
                            if (escapedC === '"') {
                                if (line[columnNumber] === '"')
                                    value += line[columnNumber++];
                                else
                                    break;
                            }
                            else if (escapedC === '\\')
                                value += '\\\\';
                            else
                                value += escapedC;
                        }
                    }
                }
                else if (c === '\\')
                    value += '\\\\';
                else
                    value += c;
            }
            if (value || c === this.separator) {
                values.push({
                    position: {
                        line: lineNumber,
                        character: valColumn
                    },
                    value
                });
            }
            if (values.length > 0)
                rows.push(values);
        });
        return rows;
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.DOCUMENTATION, {
        argumentsRenderer: args => args[1],
        resultRenderer: (voidRes, args, thisArg) => `${thisArg.map.size} entries`
    })
], CsvIndex.prototype, "index", null);
exports.CsvIndex = CsvIndex;
//# sourceMappingURL=CsvIndex.js.map