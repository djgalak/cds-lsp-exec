"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_source_map_1 = require("json-source-map");
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
function afterStart(node, content) {
    const keyStart = node.pos.key || node.pos.value;
    const offset = content.slice(keyStart.pos).indexOf('{') + 1;
    return { line: keyStart.line, column: keyStart.column + offset, pos: keyStart.pos + offset };
}
class JsonNodeX {
    constructor(id, data, jsonNodePath, pointers) {
        this.id = id;
        this.data = data;
        this.jsonNodePath = jsonNodePath;
        this.pointers = pointers;
    }
    get pos() {
        return this.pointers[this.jsonNodePath];
    }
    createSubNode(id) {
        var _a;
        return new JsonNodeX(id, (_a = this.data) === null || _a === void 0 ? void 0 : _a[id], `${this.jsonNodePath}/${id}`, this.pointers);
    }
    *subNodes() {
        for (const key of Object.keys(this.data || {})) {
            yield this.createSubNode(key);
        }
    }
}
class JsonIndex extends utils_1.I18nIndex {
    index(cdsEnv, content) {
        const translations = new Map();
        this.content = content;
        if (content) {
            this.parsed = json_source_map_1.parse(content);
            const languageFolder = new JsonNodeX(null, this.parsed.data, '', this.parsed.pointers);
            const collectEntries = (lang) => {
                const languageNode = languageFolder.createSubNode(lang);
                for (const tNode of languageNode.subNodes()) {
                    const { line, column } = tNode.pos.value;
                    translations.set(tNode.id, {
                        uri: this.uri,
                        line,
                        character: column + 1,
                        id: tNode.id,
                        text: tNode.data
                    });
                }
            };
            collectEntries(cdsEnv.i18n.default_language);
            collectEntries(cdsEnv.i18n.fallback_bundle);
        }
        this.map = translations;
    }
    createEntry(cdsEnv, tID, translationType) {
        var _a, _b, _c, _d, _e;
        const rootNode = new JsonNodeX(null, (_b = (_a = this.parsed) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {}, '', (_c = this.parsed) === null || _c === void 0 ? void 0 : _c.pointers);
        const getLangNode = (lang) => {
            const langNode = rootNode.createSubNode(lang);
            return langNode.data ? langNode : undefined;
        };
        const editLanguageNode = (_d = getLangNode(cdsEnv.i18n.fallback_bundle)) !== null && _d !== void 0 ? _d : getLangNode(cdsEnv.i18n.default_language);
        const firstSpecificLanguageNode = getLangNode((_e = utils_1.entries(rootNode.data)[0]) === null || _e === void 0 ? void 0 : _e[0]);
        let position;
        let newText = `"${tID}": "${utils_1.ADD_TEXT_HERE}"`;
        const wrap = (before, after) => {
            const charBefore = this.content[position.pos - 1];
            const charAfter = this.content[position.pos];
            const lfBefore = charBefore === '\n' || charBefore === '\r';
            const lfAfter = charAfter === '\n' || charAfter === '\r';
            if (before.startsWith('\n') && lfBefore) {
                before = before.slice(1);
            }
            if (after.endsWith('\n') && lfAfter) {
                after = after.slice(0, -1);
            }
            newText = `${before}${newText}${after}`;
        };
        const injectInExistingEntries = () => {
            let currentEntry;
            for (const tNode of editLanguageNode.subNodes()) {
                currentEntry = tNode;
                if (tNode.id.localeCompare(tID) > 0) {
                    position = tNode.pos.key;
                    wrap('', ',\n    ');
                    return;
                }
            }
            if (currentEntry) {
                position = currentEntry.pos.valueEnd;
                wrap(',\n    ', '');
            }
            else {
                position = afterStart(editLanguageNode, this.content);
                wrap('\n    ', '\n');
            }
        };
        if (!editLanguageNode) {
            newText = `"${cdsEnv.i18n.fallback_bundle}": {\n    ${newText}\n  }`;
            if (firstSpecificLanguageNode) {
                position = firstSpecificLanguageNode.pos.key;
                newText += ',\n  ';
            }
            else {
                if (rootNode.pointers) {
                    position = afterStart(rootNode, this.content);
                    wrap('\n  ', '\n');
                }
            }
        }
        else {
            injectInExistingEntries();
        }
        if (!rootNode.pointers) {
            newText = `{\n  ${newText}\n}`;
            position = { line: 0, column: 0, pos: 0 };
        }
        return [{
                newText,
                range: { start: { line: position.line, character: position.column }, end: { line: position.line, character: position.column } }
            }];
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.DOCUMENTATION, {
        argumentsRenderer: args => args[1],
        resultRenderer: (voidRes, args, thisArg) => `${thisArg.map.size} entries`
    })
], JsonIndex.prototype, "index", null);
exports.JsonIndex = JsonIndex;
//# sourceMappingURL=JsonIndex.js.map