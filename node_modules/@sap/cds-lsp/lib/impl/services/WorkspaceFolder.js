"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const csn_api_1 = require("../csn-api");
const utils_1 = require("../utils");
const cdsenv_1 = require("../utils/cdsenv");
const trace_1 = require("../utils/trace");
const DocumentationProvider_1 = require("./DocumentationProvider");
const TranslationBroker_1 = require("./translation/TranslationBroker");
const WorkspaceDiagnostics_1 = require("./WorkspaceDiagnostics");
class WorkspaceFolder {
    constructor(workspaceRootUri, name, compiler, sendDiagnosticsProvider, options = new utils_1.LspOptions(), localRoot) {
        this.name = name;
        this.compiler = compiler;
        this.options = options;
        this._openDocuments = new utils_1.CdxTextDocuments();
        this.translationBroker = new TranslationBroker_1.TranslationBroker(this);
        this.documentationProvider = new DocumentationProvider_1.DocumentationProvider(this.translationBroker);
        this.workspaceDocuments = utils_1.empty();
        this._workspaceScanned = false;
        this._indexByUri = utils_1.empty();
        this._taskManager = new utils_1.TaskManager();
        this._envTaskManager = new utils_1.TaskManager();
        this._workspaceVersion = 0;
        const trace = trace_1.currentTrace();
        this.tracer = trace.tracer(trace_1.LspTraceComponent.WORKSPACE);
        this.modelTracer = trace.tracer(trace_1.LspTraceComponent.MODEL);
        this.fileTracer = trace.tracer(trace_1.LspTraceComponent.FILES);
        if (workspaceRootUri.startsWith('file:/') && !workspaceRootUri.startsWith('file://')) {
            workspaceRootUri = workspaceRootUri.replace('file:/', 'file:///');
        }
        this.adapter = new utils_1.Adapter(workspaceRootUri, localRoot);
        this.tracer.info(() => `WorkspaceFolder ${name}: workspaceUri=${this.workspaceUri} workspaceRoot=${this.workspaceRoot}`);
        this.checkRootExists();
        this.diagnostics = new WorkspaceDiagnostics_1.WorkspaceDiagnostics(options, this.translationBroker, sendDiagnosticsProvider);
    }
    get workspaceScanned() {
        return this._workspaceScanned;
    }
    set workspaceScanned(value) {
        this.tracer.verbose(() => `workspaceScanned=${value}`);
        this._workspaceScanned = value;
    }
    get workspaceUri() {
        return this.adapter.clientRootUri;
    }
    get workspaceRoot() {
        return this.adapter.localRoot;
    }
    async onWorkspaceChanged(urisChanged) {
        const needsTotalRecompilation = !urisChanged || urisChanged.length === 0;
        return this.onWorkspaceFolderChanged(needsTotalRecompilation ? undefined : urisChanged);
    }
    async onDidOpenTextDocument(params) {
        this._openDocuments.onDidOpenTextDocument(params);
        const contentOnDisk = this.workspaceDocuments[params.textDocument.uri];
        const contentInEditor = this._openDocuments.get(params.textDocument.uri).getText();
        if (contentOnDisk !== contentInEditor) {
            this.invalidateIndex(params.textDocument.uri);
        }
        const diag = await this.validateFile(params.textDocument.uri);
        return diag ? { [diag.uri]: diag.diagnostics } : utils_1.empty();
    }
    async onDidChangeTextDocument(params) {
        this._openDocuments.onDidChangeTextDocument(params);
        const changes = await this.onWorkspaceChanged([params.textDocument.uri]);
        return changes[params.textDocument.uri] || [];
    }
    onDidCloseTextDocument(params) {
        this._openDocuments.onDidCloseTextDocument(params);
        const uri = params.textDocument.uri;
        const dependencyLevel = this.dependencyLevel(uri);
        let maxRemainCount;
        switch (this.options.getUserSetting(utils_1.UserSetting.WORKSPACE_VALIDATION_MODE, utils_1.WorkspaceValidationMode.OpenEditorsAndDirectSources)) {
            case utils_1.WorkspaceValidationMode.OpenEditorsOnly:
                maxRemainCount = -1;
                break;
            case utils_1.WorkspaceValidationMode.OpenEditorsAndDirectSources:
                maxRemainCount = 0;
                break;
            case utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies:
                maxRemainCount = 1;
                break;
        }
        const wipeDiagsAtClient = dependencyLevel > maxRemainCount;
        if (wipeDiagsAtClient) {
            this.diagnostics.validationState.updateFile(uri, null);
        }
    }
    getOpenFiles(workspaceRootUri) {
        const openFiles = utils_1.empty();
        const dirtyFiles = this._openDocuments.all();
        dirtyFiles.forEach((dirtyTextDocument) => {
            const uri = dirtyTextDocument.uri;
            if (uri.startsWith(workspaceRootUri)) {
                openFiles[uri] = dirtyTextDocument.getText();
                this.fileTracer.verbose(() => `from open editor: ${uri}`);
            }
        });
        return openFiles;
    }
    getResponsibilityScore(uriOrLocalPath) {
        if (utils_1.isUrl(uriOrLocalPath)) {
            const uri = uriOrLocalPath;
            if (uri.startsWith(this.workspaceUri)) {
                return this.workspaceUri.length;
            }
        }
        else {
            const localPath = uriOrLocalPath;
            if (localPath.startsWith(this.workspaceRoot)) {
                return this.workspaceUri.length;
            }
        }
        return 0;
    }
    mixLocalAndDirtyFiles(workspaceDocuments) {
        const openFiles = this.getOpenFiles(this.workspaceUri);
        for (const uri of Object.keys(workspaceDocuments)) {
            if (!openFiles[uri]) {
                openFiles[uri] = workspaceDocuments[uri];
            }
        }
        return openFiles;
    }
    async calculateUrisToValidate(urisChanged = []) {
        let urisToValidate = new Set(urisChanged);
        const fullBuild = urisToValidate.size === 0;
        const validatableUris = Object.keys(await this.fetchSourceFiles(this.options.getUserSetting(utils_1.UserSetting.WORKSPACE_VALIDATION_MODE)));
        if (fullBuild) {
            urisToValidate = new Set(validatableUris);
        }
        else {
            for (const anyUri of validatableUris) {
                const previousCompile = this.diagnostics.validationState.compiledFiles[anyUri];
                if (previousCompile) {
                    for (const changedUri of urisToValidate) {
                        if (previousCompile.dependentUris.includes(changedUri)) {
                            urisToValidate.add(anyUri);
                            break;
                        }
                    }
                }
                else {
                    urisToValidate.add(anyUri);
                    break;
                }
            }
            this.tracer.verbose(() => `Potentially effected files to compile: ${utils_1.toCollectionString(urisToValidate)}`);
        }
        return { urisToValidate: [...urisToValidate], fullBuild };
    }
    async fetchSourceFiles(validationMode) {
        const documents = await this._getFiles(validationMode);
        for (const uri of Object.keys(documents)) {
            if (!utils_1.isCdsFile(uri, documents[uri])) {
                delete documents[uri];
            }
        }
        return documents;
    }
    async fetchPackageJsonFiles(validationMode) {
        const documents = await this._getFiles(validationMode);
        for (const uri of Object.keys(documents)) {
            if (!utils_1.isPackageJsonFile(uri)) {
                delete documents[uri];
            }
        }
        return documents;
    }
    async _getFiles(validationMode) {
        const onlyOpenEditors = validationMode && validationMode === utils_1.WorkspaceValidationMode.OpenEditorsOnly;
        if (!onlyOpenEditors && !this.workspaceScanned) {
            await this._taskManager.enqueue(`scanWorkspace:${this.workspaceRoot}`, 0, async () => {
                await this._scanFolderForSources();
                return undefined;
            });
            const cdsEnv = await this.fetchCdsEnv();
            const translationPropertiesUris = Object.keys(this.workspaceDocuments).filter(utils_1.isTranslationFile.bind(null, cdsEnv));
            this.tracer.footprint(`Index translation ${translationPropertiesUris.length} files`, () => translationPropertiesUris.forEach(translationPropertiesUri => this.translationBroker.onTranslationFileChanged(cdsEnv, translationPropertiesUri, this.workspaceDocuments[translationPropertiesUri])));
            this.workspaceScanned = true;
        }
        let workspaceDocuments = this.workspaceDocuments;
        if (validationMode) {
            switch (validationMode) {
                case utils_1.WorkspaceValidationMode.OpenEditorsOnly:
                    workspaceDocuments = utils_1.empty();
                    break;
                case utils_1.WorkspaceValidationMode.OpenEditorsAndDirectSources:
                    {
                        const uris = Object.keys(this.workspaceDocuments);
                        workspaceDocuments = utils_1.empty();
                        for (const uri of uris) {
                            if (this.dependencyLevel(uri) === 0) {
                                workspaceDocuments[uri] = this.workspaceDocuments[uri];
                            }
                        }
                    }
                    break;
                case utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies:
            }
        }
        return this.mixLocalAndDirtyFiles(workspaceDocuments);
    }
    dependencyLevel(uri) {
        if (!uri.startsWith(this.workspaceUri)) {
            this.tracer.warn(`Given file ${uri} not part of workspace ${this.workspaceUri} => assuming first level dependency`);
            return 1;
        }
        const relativePath = uri.slice(this.workspaceUri.length);
        return relativePath.split('/').reduce((count, segment) => count + (segment === 'node_modules' ? 1 : 0), 0);
    }
    async __scanForSources(workspaceRoot, workspaceDocuments) {
        const loopDetector = new utils_1.LoopDetector(workspaceRoot);
        const thisModule = new utils_1.NodeModule(workspaceRoot, loopDetector, this.adapter, () => this.fetchCdsEnv());
        const sourceFiles = [];
        sourceFiles.push(...await thisModule.scanFiles(workspaceDocuments));
        const dependencies = await thisModule.fetchDependencies();
        for (const dependency of dependencies) {
            sourceFiles.push(...await new utils_1.NodeModule(dependency.localPath, loopDetector, this.adapter, () => this.fetchCdsEnv()).scanFiles(workspaceDocuments));
        }
        const readFiles = () => {
            let bytesRead = 0;
            sourceFiles.forEach((filename) => {
                const uri = this.adapter.toUri(filename);
                if (!workspaceDocuments[uri]) {
                    bytesRead += this.updateWorkspaceDocuments(uri, workspaceDocuments);
                }
            });
            this.tracer.info(() => `A total of ${bytesRead} bytes read`);
        };
        this.tracer.footprint('Reading source files', readFiles);
    }
    async _scanFolderForSources() {
        return this.__scanForSources(this.workspaceRoot, this.workspaceDocuments);
    }
    updateWorkspaceDocuments(uri, workspaceDocuments, prefix = '') {
        let bytesRead = 0;
        const content = this.readContent(uri, prefix);
        if (content !== undefined) {
            workspaceDocuments[uri] = content;
            bytesRead += content.length;
        }
        return bytesRead;
    }
    readContent(uri, prefix = '') {
        const filename = utils_1.toLocalPath(uri);
        try {
            let content = '';
            this.fileTracer.footprint(`${prefix}${prefix.length ? ' - ' : ''} read file from local workspace: ${filename}`, () => {
                content = fs.readFileSync(filename, { encoding: 'utf8' });
                return `${content.length} bytes read`;
            });
            return content;
        }
        catch (error) {
            this.fileTracer.error(error.toString());
        }
        return undefined;
    }
    checkRootExists() {
        if (!fs.existsSync(this.workspaceRoot)) {
            throw new Error('Given workspace root does not exist locally: ' + this.workspaceRoot);
        }
    }
    isDirtyIndex(uri, workspaceVersion) {
        const index = this._indexByUri[uri];
        return !index || index.isInvalid;
    }
    async findDirtyUris(workspaceVersion) {
        const uris = Object.keys(await this.fetchSourceFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies));
        return uris
            .filter(potentialDirtyUri => this.isDirtyIndex(potentialDirtyUri, workspaceVersion));
    }
    async rebuildDirtyIndexes() {
        const workspaceVersion = this._workspaceVersion;
        let urisToRebuild = await this.findDirtyUris(workspaceVersion);
        return this._taskManager.enqueue(`rebuildDirtyIndexes:${this.workspaceUri}`, workspaceVersion, async () => {
            this.tracer.verbose(() => `Rebuild indexes for workspaceVersion ${workspaceVersion}`);
            const cdsEnv = await this.fetchCdsEnv();
            const roots = {};
            Object.entries(cdsEnv.rootModels)
                .forEach(([kind, list]) => roots[kind] = new Set(list));
            const segmentsCount = (uri) => uri.split('/').length;
            const rank = (uri) => {
                for (let i = 0; i < cdsenv_1.kinds.length; i++) {
                    const kind = cdsenv_1.kinds[i];
                    if (roots[kind].has(uri)) {
                        return i;
                    }
                }
                return segmentsCount(uri)
                    + (uri.endsWith('index.cds')
                        ? 10
                        : 1000);
            };
            urisToRebuild = urisToRebuild
                .map(uri => ({ rank: rank(uri), uri }))
                .sort((x1, x2) => x1.rank - x2.rank)
                .map(x => x.uri);
            this.tracer.verbose(() => `URIs to rebuild: ${utils_1.renderUris(urisToRebuild)}`);
            const renderIfTracing = (builtUri, uri) => () => `Setting index for ${builtUri} - mainUri ${uri}`;
            for (const uri of urisToRebuild) {
                if (this.isDirtyIndex(uri, workspaceVersion)) {
                    const index = await this.buildIndex(uri, workspaceVersion);
                    index.builtUris.forEach(builtUri => {
                        this.tracer.verbose(renderIfTracing(builtUri, uri));
                        this._indexByUri[builtUri] = index;
                    });
                }
            }
            this.tracer.verbose(() => `Done: Rebuild indexes for workspaceVersion ${workspaceVersion}`);
            return undefined;
        });
    }
    async buildIndex(uri, workspaceVersion) {
        const localPath = utils_1.toLocalPath(uri);
        const ast = (await this.fetchAst(localPath));
        const blitzIndex = csn_api_1.BlitzIndex.build(uri, this.workspaceDocuments, ast, workspaceVersion, this.getAdapter(uri));
        for (const builtUri of blitzIndex.builtUris) {
            const relativePath = utils_1.toLocalPath(builtUri).slice(this.workspaceRoot.length + 1);
            await this.diagnostics.calculateAnnotationDiagnostics(builtUri, ast, relativePath);
        }
        return blitzIndex;
    }
    getAdapter(fileUri) {
        return this.adapter;
    }
    async fetchCdsEnv() {
        return this._cachedCdsEnv || this._envTaskManager.enqueue(`fetching cds.env:${this.workspaceUri}`, this._workspaceVersion, async () => {
            if (!this._cachedCdsEnv) {
                this._cachedCdsEnv = await this._fetchCdsEnv();
            }
            return this._cachedCdsEnv;
        });
    }
    async _fetchCdsEnv() {
        return fetchCdsEnvRaw(this.workspaceRoot, this.tracer);
    }
    async fetchIndex(uri) {
        let index = this._indexByUri[uri];
        if (!index || index.isInvalid) {
            this.tracer.verbose(() => `Recalculating index for ${uri}`);
            await this.rebuildDirtyIndexes();
            index = this._indexByUri[uri];
        }
        else {
            this.tracer.verbose(() => `Index from cache for ${uri}`);
        }
        return index;
    }
    async fetchAst(localPath) {
        return this.compileFile(localPath);
    }
    async compileFile(localPath) {
        const fileCache = utils_1.empty();
        const files = {
            ...await this.fetchSourceFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies),
        };
        utils_1.entries(files).forEach(([uri, content]) => {
            fileCache[utils_1.toLocalPath(uri)] = content;
        });
        const env = await this.fetchCdsEnv();
        const compilerOptions = env && env.compilerOptions;
        return this.compiler.compile(localPath, fileCache, this.getWorkspaceRoot(localPath), compilerOptions);
    }
    getWorkspaceRoot(localFilePath) {
        return this.workspaceRoot;
    }
    async onDidChangeWatchedFiles(params) {
        const singleRecompilationEvents = [];
        const packageJsonEvents = [];
        let needsTranslationRecompilation = false;
        let needsTotalRecompilation = false;
        const cdsEnvChange = params.changes.find(c => utils_1.isCdsEnvFile(c.uri));
        if (cdsEnvChange) {
            this.tracer.info(`cdsenv change (${cdsEnvChange.uri} - ${cdsEnvChange.type})`);
            this.workspaceScanned = false;
            needsTotalRecompilation = true;
            this._cachedCdsEnv = undefined;
        }
        const cdsEnv = await this.fetchCdsEnv();
        const contentProvider = (content) => () => content;
        for (const fileEvent of params.changes) {
            const uri = fileEvent.uri;
            const wasDeleted = fileEvent.type === LSP.FileChangeType.Deleted;
            const content = wasDeleted ? undefined : this.readContent(uri, 'fileChanged');
            const fileType = utils_1.typeofFile(uri, cdsEnv, contentProvider(content));
            if (fileType === utils_1.LspFileType.Unrelated) {
                continue;
            }
            this.updateFileCache(uri, content);
            if (fileType === utils_1.LspFileType.CdsEnv) {
                this._cachedCdsEnv = undefined;
                this.translationBroker.reset();
                needsTranslationRecompilation = true;
                continue;
            }
            if (fileType === utils_1.LspFileType.TranslationDefinitions) {
                this.translationBroker.onTranslationFileChanged(cdsEnv, fileEvent.uri, content);
                needsTranslationRecompilation = true;
                continue;
            }
            if (wasDeleted) {
                if (fileType === utils_1.LspFileType.PackageJson) {
                }
                else {
                    needsTotalRecompilation = true;
                }
            }
            else {
                switch (fileType) {
                    case utils_1.LspFileType.CsnFile:
                    case utils_1.LspFileType.CdsSource:
                        singleRecompilationEvents.push(fileEvent);
                        break;
                    case utils_1.LspFileType.IgnoreFile:
                        needsTotalRecompilation = true;
                        break;
                    case utils_1.LspFileType.PackageJson:
                        packageJsonEvents.push(fileEvent);
                        break;
                }
            }
            if (fileEvent.type === LSP.FileChangeType.Created) {
                needsTotalRecompilation = true;
            }
        }
        try {
            if (packageJsonEvents.length) {
                needsTotalRecompilation = true;
            }
            if (needsTotalRecompilation) {
                await this.onWorkspaceFolderChanged();
                needsTranslationRecompilation = false;
                return;
            }
            if (singleRecompilationEvents.length) {
                singleRecompilationEvents
                    .filter(e => e.type === LSP.FileChangeType.Deleted)
                    .forEach(e => {
                    this.diagnostics.validationState.updateFile(e.uri, null);
                    delete this._indexByUri[e.uri];
                });
                await this.onWorkspaceFolderChanged(singleRecompilationEvents.filter(e => e.type !== LSP.FileChangeType.Deleted).map(e => e.uri));
                return;
            }
        }
        finally {
            if (needsTranslationRecompilation) {
                for (const uri of Object.keys(this.workspaceDocuments)) {
                    if (utils_1.isCdsSourceFile(uri)) {
                        const index = await this.fetchIndex(uri);
                        if (index.forUri(uri).i18nTokens.length) {
                            await this.diagnostics.calculateCombinedDiagnosticsAndSend(uri, index, this._workspaceVersion);
                        }
                    }
                }
            }
        }
    }
    updateFileCache(uri, content) {
        if (content === undefined) {
            delete this.workspaceDocuments[uri];
        }
        else {
            this.workspaceDocuments[uri] = content;
        }
    }
    markWorkspaceAsDirty() {
        this._workspaceVersion++;
        this.tracer.verbose(() => `::workspace#${this._workspaceVersion}`);
    }
    async onWorkspaceFolderChanged(urisChanged = []) {
        this.tracer.info(() => `WorkspaceFolder '${this.name}': ${this.workspaceRoot}`);
        this.markWorkspaceAsDirty();
        const { urisToValidate, fullBuild } = await this.calculateUrisToValidate(urisChanged);
        for (const uri of urisToValidate) {
            this.invalidateIndex(uri);
        }
        let allDiagnosticsSent = utils_1.empty();
        if (fullBuild) {
            allDiagnosticsSent = this.diagnostics.cleanDiagnostics(this.name);
        }
        const compileFile = (uri) => async () => {
            try {
                const diag = await this.validateFile(uri);
                if (diag) {
                    allDiagnosticsSent[diag.uri] = diag.diagnostics;
                }
            }
            catch (e) {
                this.tracer.error(() => `Failed to compile ${uri}: `, e.stack || e);
            }
        };
        await this.tracer.footprint(`Compile ${urisToValidate.length} files`, async () => {
            for (let i = 0; i < urisToValidate.length; i++) {
                const uri = urisToValidate[i];
                await this.tracer.footprint(`Compile file ${i}/${urisToValidate.length}: ${uri}`, compileFile(uri));
            }
        });
        return allDiagnosticsSent;
    }
    invalidateIndex(uri) {
        this.tracer.verbose(() => `Invalidating index for ${uri}`);
        const index = this._indexByUri[uri];
        if (index) {
            if (!index.isInvalid) {
                trace_1.currentFrame().requestScope.dirtyModels++;
                this.markWorkspaceAsDirty();
                index.isInvalid = true;
            }
        }
    }
    async validateFile(uri) {
        const index = await this.fetchIndex(uri);
        return this.diagnostics.calculateCombinedDiagnosticsAndSend(uri, index, this._workspaceVersion);
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE, {
        argumentsRenderer: args => args[0] ? args[0].size + ' files changed' : 'all files to be recompiled',
        resultRenderer: utils_1.renderNothing,
        trackMemory: true
    })
], WorkspaceFolder.prototype, "onWorkspaceChanged", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE, { resultRenderer: utils_1.renderUris })
], WorkspaceFolder.prototype, "findDirtyUris", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL)
], WorkspaceFolder.prototype, "rebuildDirtyIndexes", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE)
], WorkspaceFolder.prototype, "_fetchCdsEnv", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, { resultRenderer: utils_1.renderNothing, trackMemory: true })
], WorkspaceFolder.prototype, "fetchIndex", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, {
        argumentsRenderer: args => args[0],
        resultRenderer: utils_1.renderNothing
    })
], WorkspaceFolder.prototype, "compileFile", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE, { errorHandler: (errorKind, e, prefix, tracr) => { tracr.error(`}_${prefix} => ${e}`); } })
], WorkspaceFolder.prototype, "onDidChangeWatchedFiles", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.MODEL, {
        argumentsRenderer: args => args[0] ? utils_1.arr([...args[0]]) : '',
        resultRenderer: utils_1.renderDiagsMap
    })
], WorkspaceFolder.prototype, "onWorkspaceFolderChanged", null);
exports.WorkspaceFolder = WorkspaceFolder;
exports.isOutsider = (wsf) => wsf instanceof OutsiderWorkspaceFolder;
exports.isUntitled = (wsf) => wsf instanceof UntitledWorkspaceFolder;
exports.isRealWorkspaceFolder = (wsf) => !exports.isOutsider(wsf) && !exports.isUntitled(wsf);
class OutsiderWorkspaceFolder extends WorkspaceFolder {
    constructor(compiler, workspaceService, sendDiagnosticsProvider) {
        super(utils_1.toSimpleUri(path.resolve('/')), '(Outsiders)', compiler, sendDiagnosticsProvider);
        this.workspaceService = workspaceService;
    }
    get workspaceScanned() {
        return true;
    }
    set workspaceScanned(value) {
        this.tracer.warn(() => 'OutsiderWorkspaceFolder will never scan workspace');
    }
    checkRootExists() {
    }
    async _fetchCdsEnv() {
        return cdsenv_1.defaultEnv();
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE)
], OutsiderWorkspaceFolder.prototype, "_fetchCdsEnv", null);
exports.OutsiderWorkspaceFolder = OutsiderWorkspaceFolder;
class UntitledWorkspaceFolder extends WorkspaceFolder {
    constructor(compiler, workspaceService, sendDiagnosticsProvider) {
        super(utils_1.Untitled.UNTITLED_ROOT_URI, '(Untitled)', compiler, sendDiagnosticsProvider, undefined, utils_1.Untitled.UNTITLED_ROOT);
        this.workspaceService = workspaceService;
    }
    checkRootExists() {
    }
    get workspaceScanned() {
        return true;
    }
    set workspaceScanned(value) {
        this.tracer.warn(() => 'UntitledWorkspaceFolder will never scan workspace');
    }
    async fetchSourceFiles(validationMode) {
        const openFiles = this._openDocuments.all();
        const docs = {};
        openFiles.forEach(doc => docs[doc.uri] = doc.getText());
        return docs;
    }
    async _fetchCdsEnv() {
        return cdsenv_1.defaultEnv();
    }
    dependencyLevel(uri) {
        return 2;
    }
    getWorkspaceRoot(localFilePath) {
        return path.dirname(localFilePath);
    }
    getAdapter(fileUri) {
        if (utils_1.Untitled.isUntitledFile(fileUri)) {
            return this.adapter;
        }
        return new utils_1.Adapter(path.dirname(fileUri) + '/');
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE)
], UntitledWorkspaceFolder.prototype, "_fetchCdsEnv", null);
exports.UntitledWorkspaceFolder = UntitledWorkspaceFolder;
async function fetchCdsEnvRaw(workspaceRoot, tracer) {
    try {
        const node = process.argv0;
        const cdsenv = path.join(__dirname, '..', 'utils', 'cdsenv', 'callCdsEnv');
        const enableTrace = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.UTIL).isTracing(trace_1.LspTraceLevel.VERBOSE)
            ? '--verbose'
            : '';
        const processFinished = await utils_1.execAsync(`"${node}" "${cdsenv}" ${enableTrace}`, workspaceRoot);
        if (tracer)
            tracer.verbose(processFinished.stderr);
        return JSON.parse(processFinished.stdout);
    }
    catch (e) {
        if (tracer)
            tracer.error(e);
    }
    return cdsenv_1.defaultEnv();
}
exports.fetchCdsEnvRaw = fetchCdsEnvRaw;
//# sourceMappingURL=WorkspaceFolder.js.map