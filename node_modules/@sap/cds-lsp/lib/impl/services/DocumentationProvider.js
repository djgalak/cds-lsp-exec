"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const csn_api_1 = require("../csn-api");
const utils_1 = require("../utils");
const trace_1 = require("../utils/trace");
const TranslationUtils_1 = require("./translation/TranslationUtils");
class DocumentationProvider {
    constructor(translationBroker) {
        this.translationBroker = translationBroker;
    }
    renderDocumentation(doc) {
        const renderTranslated = (ts, isTitle = false) => utils_1.markdownTranslation(ts.text, ts.foundTranslation, isTitle);
        let out = doc.title ? renderTranslated(doc.title, true) : '';
        if (doc.description) {
            if (out.length) {
                out += '  \n';
            }
            out += renderTranslated(doc.description);
        }
        return out;
    }
    async fetchDocumentation(genericToken) {
        if (!genericToken) {
            return {};
        }
        const translateId = (tId, fallbackText = '') => {
            if (tId) {
                const tx = this.translationBroker.getTranslation(tId);
                return {
                    foundTranslation: !!tx,
                    text: tx ? tx.text : fallbackText
                };
            }
            return { foundTranslation: false, text: fallbackText };
        };
        let definitions;
        if (genericToken instanceof csn_api_1.GenericToken) {
            if (genericToken instanceof csn_api_1.StringLiteralToken) {
                const tID = genericToken.translationId;
                return { description: translateId(tID) };
            }
            if (!(genericToken instanceof csn_api_1.IdentifierToken)) {
                return {};
            }
            definitions = csn_api_1.flatten(genericToken.definitions);
        }
        else {
            definitions = [genericToken];
        }
        definitions = definitions.filter(d => d instanceof csn_api_1.GenericDefinition);
        const getTag = (annotationName) => {
            for (const definition of definitions) {
                const annotationRefs = csn_api_1.flatten(definition.annotation(annotationName));
                for (let i = annotationRefs.length - 1; i >= 0; i--) {
                    const annotationRef = annotationRefs[i];
                    if (annotationRef.annotationValue) {
                        return annotationRef.annotationValue.replace(/\\n/g, '\n');
                    }
                }
            }
            return undefined;
        };
        const translate = (s) => {
            if (s) {
                const tId = TranslationUtils_1.getTranslationId(s);
                return translateId(tId, s);
            }
            return undefined;
        };
        const description = translate(getTag('cds.doc') || getTag('description'));
        const title = translate(getTag('title'));
        return { description, title };
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.DOCUMENTATION, { argumentsRenderer: utils_1.renderNothing })
], DocumentationProvider.prototype, "renderDocumentation", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.DOCUMENTATION, { argumentsRenderer: utils_1.renderNothing })
], DocumentationProvider.prototype, "fetchDocumentation", null);
exports.DocumentationProvider = DocumentationProvider;
//# sourceMappingURL=DocumentationProvider.js.map