"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const trace_1 = require("../utils/trace");
const quickFixes_1 = require("./quickFixes");
const WorkspaceFolder_1 = require("./WorkspaceFolder");
class WorkspaceService {
    constructor(lspServer, options) {
        this.lspServer = lspServer;
        this.options = options;
        this._workspaceFolders = utils_1.empty();
        this._quickFixes = new Map();
        this.uriOrLocalPathToWorkspaceFolder = new Map();
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.WORKSPACE);
        this._quickFixes.set(quickFixes_1.QuickFixCommands.MAINTAIN_TRANSLATION, new quickFixes_1.MaintainTranslationQuickFix(lspServer));
    }
    get workspaceFolders() {
        return Object.values(this._workspaceFolders);
    }
    _addWorkspaceFolder(workspaceProvider) {
        this._workspaceFolders[workspaceProvider.workspaceUri] = workspaceProvider;
    }
    addWorkspaceFolder(workspaceFolderConfig, compiler) {
        const workspaceFolder = new WorkspaceFolder_1.WorkspaceFolder(workspaceFolderConfig.uri, workspaceFolderConfig.name, compiler, this.lspServer, this.options);
        this._addWorkspaceFolder(workspaceFolder);
        return workspaceFolder;
    }
    createWorkspaceFolders(workspaceFoldersConfig, compiler) {
        this._addWorkspaceFolder(new WorkspaceFolder_1.UntitledWorkspaceFolder(compiler, this, this.lspServer));
        this._addWorkspaceFolder(new WorkspaceFolder_1.OutsiderWorkspaceFolder(compiler, this, this.lspServer));
        const errorMessage = (workspaceFolderConfig) => () => `Failed to add workspace folder '${workspaceFolderConfig.name}' with URI ${workspaceFolderConfig.uri}: `;
        for (const workspaceFolderConfig of workspaceFoldersConfig) {
            try {
                this.addWorkspaceFolder(workspaceFolderConfig, compiler);
            }
            catch (e) {
                this.lspServer.userPopup(trace_1.LspTraceLevel.WARNING, `Specified workspace folder '${workspaceFolderConfig.name}' could not be opened:\n${e}`);
                this.tracer.error(errorMessage(workspaceFolderConfig), e.stack || e);
            }
        }
    }
    removeWorkspaceFolder(rootUri) {
        const workspaceFolder = this._workspaceFolders[rootUri];
        workspaceFolder.diagnostics.cleanDiagnostics(workspaceFolder.name);
        delete this._workspaceFolders[rootUri];
        const urisToDelete = [];
        for (const [uri, wsf] of this.uriOrLocalPathToWorkspaceFolder.entries()) {
            if (wsf === workspaceFolder) {
                urisToDelete.push(uri);
            }
        }
        for (const uri of urisToDelete) {
            this.uriOrLocalPathToWorkspaceFolder.delete(uri);
        }
    }
    getWorkspaceFolder(uriOrLocalPath) {
        let workspaceFolder = this.uriOrLocalPathToWorkspaceFolder.get(uriOrLocalPath);
        if (!workspaceFolder) {
            workspaceFolder = Object.values(this._workspaceFolders).reduce((best, currentFolder) => {
                const score = currentFolder.getResponsibilityScore(uriOrLocalPath);
                return score > best.score
                    ? { folder: currentFolder, score }
                    : best;
            }, { folder: undefined, score: -100 }).folder;
            this.tracer.verbose(() => `File ${uriOrLocalPath} is handled by workspace folder ${workspaceFolder ? workspaceFolder.workspaceUri : workspaceFolder}`);
            this.uriOrLocalPathToWorkspaceFolder.set(uriOrLocalPath, workspaceFolder);
        }
        return workspaceFolder;
    }
    async onDidOpenTextDocument(params) {
        if (utils_1.isCdsFile(params.textDocument.uri, params.textDocument.text)) {
            const workspaceFolder = this.getWorkspaceFolder(params.textDocument.uri);
            return workspaceFolder.onDidOpenTextDocument(params);
        }
        return {};
    }
    async onDidChangeTextDocument(params) {
        if (!utils_1.isCdsFile(params.textDocument.uri))
            return [];
        const workspaceFolder = this.getWorkspaceFolder(params.textDocument.uri);
        return workspaceFolder.onDidChangeTextDocument(params);
    }
    onDidCloseTextDocument(params) {
        const workspaceFolder = this.getWorkspaceFolder(params.textDocument.uri);
        return workspaceFolder.onDidCloseTextDocument(params);
    }
    async onCodeAction(params) {
        const commands = [];
        for (const quickFix of this._quickFixes.values()) {
            commands.push(...await quickFix.createCommands(params));
        }
        return commands;
    }
    async onExecuteCommand(params) {
        var _a;
        return (_a = this._quickFixes.get(params.command)) === null || _a === void 0 ? void 0 : _a.execute(params);
    }
    onDidSaveTextDocument(params) {
        this.tracer.info(() => `** saved editor file ${params.textDocument.uri} #${params.textDocument.version}`);
    }
    onWillSaveTextDocument(params) {
        this.tracer.info(() => `** about to save editor file ${params.textDocument.uri}`);
    }
    onWillSaveTextDocumentWaitUntil(params) {
        this.tracer.info(() => `** saving editor file ${params.textDocument.uri}`);
        return [];
    }
    async onDidChangeWatchedFiles(params) {
        const wsfToEvents = new Map();
        params.changes.forEach((fileEvent) => {
            const uri = fileEvent.uri;
            const workspaceFolder = this.getWorkspaceFolder(uri);
            let events = wsfToEvents.get(workspaceFolder);
            if (!events) {
                events = [];
                wsfToEvents.set(workspaceFolder, events);
            }
            events.push(fileEvent);
        });
        for (const [workspaceFolder, fileEvents] of wsfToEvents) {
            await workspaceFolder.onDidChangeWatchedFiles({ changes: fileEvents });
        }
    }
    requestWorkspaceScan(folder) {
        try {
            const workspaceFolder = this.getWorkspaceFolder(folder);
            workspaceFolder.workspaceScanned = false;
        }
        catch (e) {
            this.tracer.error(() => `Could not determine workspace folder to request rescan for ${folder}`);
        }
    }
}
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocOpened,
        resultRenderer: () => '',
        onErrorReturn: utils_1.empty()
    })
], WorkspaceService.prototype, "onDidOpenTextDocument", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderChangeTextDoc,
        resultRenderer: utils_1.renderDiags,
        onErrorReturn: []
    })
], WorkspaceService.prototype, "onDidChangeTextDocument", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocClosed,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], WorkspaceService.prototype, "onDidCloseTextDocument", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderCodeAction,
        resultRenderer: utils_1.renderCommands,
        onErrorReturn: []
    })
], WorkspaceService.prototype, "onCodeAction", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderExecCmd,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], WorkspaceService.prototype, "onExecuteCommand", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocSaved,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], WorkspaceService.prototype, "onDidSaveTextDocument", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocWillSave,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], WorkspaceService.prototype, "onWillSaveTextDocument", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: []
    })
], WorkspaceService.prototype, "onWillSaveTextDocumentWaitUntil", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderChangeWatched,
        resultRenderer: utils_1.renderAsIs,
        onErrorReturn: undefined
    })
], WorkspaceService.prototype, "onDidChangeWatchedFiles", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE)
], WorkspaceService.prototype, "requestWorkspaceScan", null);
exports.WorkspaceService = WorkspaceService;
//# sourceMappingURL=WorkspaceService.js.map