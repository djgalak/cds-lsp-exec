"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const CdsPrettyPrint_1 = require("../prettyprint/CdsPrettyPrint");
const GlobalContext_1 = require("../prettyprint/GlobalContext");
const PpFormatter_1 = require("../prettyprint/PpFormatter");
const Logger_1 = require("../prettyprint/util/Logger");
const StringUtil_1 = require("../prettyprint/util/StringUtil");
const utils_1 = require("../utils");
const trace_1 = require("../utils/trace");
class FormattingService {
    constructor(compiler, workspaceService) {
        this.compiler = compiler;
        this.workspaceService = workspaceService;
        this.logger = new Logger_1.Logger();
        this.prettyPrinter = new CdsPrettyPrint_1.CdsPrettyPrint(this.logger);
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.FORMATTING);
        Logger_1.redirectLogger(this.tracer, this.logger);
    }
    async onDocumentFormatting(params) {
        return this.beautify(params.textDocument.uri, params.options);
    }
    async onDocumentRangeFormatting(params) {
        return this.beautify(params.textDocument.uri, params.options, params.range);
    }
    async onDocumentOnTypeFormatting(params) {
        return this.beautify(params.textDocument.uri, params.options, undefined, params.position);
    }
    async beautify(uri, lspOptions, range, position) {
        const content = await this.fetchContent(uri);
        Logger_1.redirectLogger(this.tracer, this.prettyPrinter.logger);
        const workspaceFolder = this.workspaceService.getWorkspaceFolder(uri);
        const formatted = await this.prettyPrinter.beautify(content, lspOptions, utils_1.toLocalPath(uri), workspaceFolder.workspaceRoot);
        return this.getTextEdits(formatted, range, position);
    }
    async fetchContent(uri) {
        const workspaceFolder = this.workspaceService.getWorkspaceFolder(uri);
        const sourceFiles = await workspaceFolder.fetchSourceFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies);
        return sourceFiles[uri];
    }
    getTextEdits(formatted, lspRange, closingCharacterPosition) {
        const textEdits = [];
        const { originalTokens, formattedTokens } = formatted;
        const selectionRange = PpFormatter_1.determineRangeTokens(originalTokens, lspRange, closingCharacterPosition);
        const inclusionRanges = GlobalContext_1.calculateInclusionRanges(originalTokens, formatted.exclusionRanges, selectionRange);
        if (originalTokens.length !== formattedTokens.length) {
            this.tracer.error(() => `Failed to beautify: token length have changed (${originalTokens.length} => ${formattedTokens.length}) `);
        }
        const betweenRange = (token, nextToken) => ({
            start: token.getEndCursor(),
            end: nextToken.getStartCursor()
        });
        const handleToken = (tokenIndex) => {
            const originalToken = originalTokens[tokenIndex];
            const formattedToken = formattedTokens[tokenIndex];
            if (originalToken.originalText !== formattedToken.text) {
                textEdits.push({
                    range: { start: originalToken.getStartCursor(), end: originalToken.getEndCursor() },
                    newText: formattedToken.text
                });
            }
        };
        const handleWhitespace = (startIndex, endIndex) => {
            if (startIndex === -1) {
                const orgWhitespace = formatted.originalContent.slice(0, originalTokens[0].getStartOffset());
                const newWhitespace = formatted.formattedContent.slice(0, formattedTokens[0].getStartOffset());
                if (orgWhitespace !== newWhitespace) {
                    textEdits.push({
                        range: { start: { line: 0, character: 0 }, end: originalTokens[0].getStartCursor() },
                        newText: newWhitespace
                    });
                }
                return;
            }
            if (endIndex === -1) {
                const orgWhitespace = formatted.originalContent.slice(originalTokens[originalTokens.length - 1].getEndOffset() + 1);
                const newWhitespace = formatted.formattedContent.slice(formattedTokens[formattedTokens.length - 1].getEndOffset() + 1);
                if (orgWhitespace !== newWhitespace) {
                    const lastToken = originalTokens[originalTokens.length - 1];
                    const endCursor = lastToken.getEndCursor();
                    const trailingWhitespace = formatted.originalContent.slice(lastToken.getEndOffset() + 1);
                    const trailingLines = trailingWhitespace.split(StringUtil_1.NEWLINE_REGEX);
                    const whitespacesOfLastLine = trailingLines[trailingLines.length - 1];
                    const character = whitespacesOfLastLine.length + (trailingLines.length === 1 ? endCursor.character : 0);
                    textEdits.push({
                        range: {
                            start: endCursor,
                            end: { line: endCursor.line + trailingLines.length - 1, character }
                        },
                        newText: newWhitespace
                    });
                }
                return;
            }
            {
                const originalToken = originalTokens[endIndex];
                const formattedToken = formattedTokens[endIndex];
                const orgPrevToken = originalTokens[startIndex];
                const formPrevToken = formattedTokens[startIndex];
                const orgWhitespace = formatted.originalContent.slice(orgPrevToken.getEndOffset() + 1, originalToken.getStartOffset());
                const newWhitespace = formatted.formattedContent.slice(formPrevToken.getEndOffset() + 1, formattedToken.getStartOffset());
                if (orgWhitespace !== newWhitespace) {
                    textEdits.push({
                        range: betweenRange(orgPrevToken, originalToken),
                        newText: newWhitespace
                    });
                }
            }
        };
        const processInclusionRange = (range) => {
            const getStart = () => {
                const { startToken, includingWhitespaceBefore } = range;
                this.logger.logInfo(() => `Formatting from token #${startToken.tokenIndex} (${startToken.text})${includingWhitespaceBefore ? ' including whitespace before' : ''}`);
                return { index: startToken.tokenIndex, includingWhitespaceBefore };
            };
            const getEnd = () => {
                const { endToken, includingWhitespaceAfter } = range;
                this.logger.logInfo(() => `Formatting to token #${endToken.tokenIndex} (${endToken.text})${includingWhitespaceAfter ? ' including whitespace after' : ''}`);
                return { index: endToken.tokenIndex, includingWhitespaceAfter };
            };
            const start = getStart();
            const end = getEnd();
            if (end.includingWhitespaceAfter) {
                handleWhitespace(end.index, end.index + 1 === originalTokens.length ? -1 : end.index + 1);
            }
            for (let i = end.index; i > start.index; i--) {
                handleToken(i);
                handleWhitespace(i - 1, i);
            }
            handleToken(start.index);
            if (start.includingWhitespaceBefore) {
                handleWhitespace(start.index === 0 ? -1 : start.index - 1, start.index);
            }
        };
        inclusionRanges.reverse().forEach(processInclusionRange);
        return textEdits;
    }
}
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderTextEdits,
        onErrorReturn: undefined
    })
], FormattingService.prototype, "onDocumentFormatting", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderTextEdits,
        onErrorReturn: undefined
    })
], FormattingService.prototype, "onDocumentRangeFormatting", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderAsIs,
        resultRenderer: utils_1.renderTextEdits,
        onErrorReturn: undefined
    })
], FormattingService.prototype, "onDocumentOnTypeFormatting", null);
exports.FormattingService = FormattingService;
//# sourceMappingURL=FormattingService.js.map