"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const InternalAnnotationHandler_1 = require("../contributions/InternalAnnotationHandler");
const csn_api_1 = require("../csn-api");
const utils_1 = require("../utils");
const trace_1 = require("../utils/trace");
const ValidationState_1 = require("./ValidationState");
class WorkspaceDiagnostics {
    constructor(options, translationBroker, sendDiagnosticsProvider) {
        var _a, _b;
        this.options = options;
        this.translationBroker = translationBroker;
        this._annotationDiagnosticsByUri = utils_1.empty();
        this.modelTracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.MODEL);
        this.annotationHandlers = (_b = (_a = trace_1.currentFrame().appScope.iocFactory) === null || _a === void 0 ? void 0 : _a.newInstance(InternalAnnotationHandler_1.ANNOTATION_HANDLERS)) !== null && _b !== void 0 ? _b : [];
        this.validationState = new ValidationState_1.ValidationState(sendDiagnosticsProvider);
    }
    async calculateAnnotationDiagnostics(uri, ast, relativePath) {
        for (const annotationHandler of this.annotationHandlers) {
            const annotationDiags = await annotationHandler.fetchAnnotationDiagnostics(uri, ast, relativePath);
            this._annotationDiagnosticsByUri[uri] = annotationDiags;
        }
    }
    calculateDiagnostics(uri, index, translationMessages) {
        var _a;
        const levelToShow = utils_1.SeverityAdapter.adapt(this.options.getUserSetting(utils_1.UserSetting.DIAGNOSTICS_LEVEL, 'Warning'));
        const fileIndex = index.forUri(uri);
        const diagnostics = fileIndex.compilerMessages
            .concat((_a = this._annotationDiagnosticsByUri[uri]) !== null && _a !== void 0 ? _a : [])
            .concat(...translationMessages)
            .filter(d => { var _a; return ((_a = d === null || d === void 0 ? void 0 : d.severity) !== null && _a !== void 0 ? _a : LSP.DiagnosticSeverity.Hint) <= levelToShow; });
        const hash = diagnostics.length ? utils_1.calculateHashDigest(JSON.stringify(diagnostics)) : ValidationState_1.CLEAN_HASH;
        const dependentUris = [...index.getTransitiveDependencies(uri)];
        dependentUris.sort();
        if (this.modelTracer.isTracing(trace_1.LspTraceLevel.VERBOSE)) {
            this.modelTracer.verbose(() => `Dependencies of ${uri}: `, Object.values(dependentUris));
        }
        return {
            uri,
            dependentUris,
            diagnostics,
            diagnosticsHash: hash,
            workspaceVersion: index.workspaceVersion
        };
    }
    async calculateCombinedDiagnosticsAndSend(uri, index, workspaceVersion) {
        const translationMessages = this.options.getUserSetting(utils_1.UserSetting.WARN_MISSING_TRANSLATIONS, false)
            ? await this.calculateTranslationDiagnostics(uri, index)
            : [];
        const compiledFile = this.calculateDiagnostics(uri, index, translationMessages);
        return this.validationState.updateFile(uri, compiledFile, workspaceVersion);
    }
    async calculateTranslationDiagnostics(uri, index) {
        const translationMessages = [];
        const fileIndex = index.forUri(uri);
        const i18nTokens = fileIndex.i18nTokens;
        for (const i18nToken of i18nTokens) {
            const tID = i18nToken.translationId;
            const translationMissing = this.translationBroker.getTranslation(tID) === undefined;
            if (translationMissing) {
                let columnStartOffset = 0;
                let columnEndOffset = i18nToken.text.length;
                if (tID) {
                    columnStartOffset = i18nToken.text.indexOf(tID);
                    columnEndOffset = columnStartOffset + tID.length;
                }
                const range = {
                    start: {
                        line: i18nToken.line,
                        character: i18nToken.character + columnStartOffset
                    },
                    end: {
                        line: i18nToken.line,
                        character: i18nToken.character + columnEndOffset
                    }
                };
                let appendix = '';
                const potentialTagname = csn_api_1.findToken(fileIndex.idTokens, i18nToken.tokenIndex - 2);
                switch (potentialTagname && potentialTagname.text) {
                    case 'title':
                    case 'description':
                        appendix = '/' + potentialTagname.text;
                        break;
                }
                translationMessages.push({
                    message: tID ? `Text for translation ID '${tID}' not defined` : 'Missing translation ID. Please add an ID',
                    code: `${utils_1.ErrorCodes.NO_TRANSLATION_TEXT}${appendix}`,
                    severity: LSP.DiagnosticSeverity.Warning,
                    range,
                    source: 'CDS'
                });
            }
        }
        return translationMessages;
    }
    cleanDiagnostics(name) {
        const allDiagnosticsSent = utils_1.empty();
        for (const uri of Object.keys(this.validationState.compiledFiles)) {
            const diag = this.validationState.updateFile(uri, null);
            if (diag) {
                allDiagnosticsSent[diag.uri] = diag.diagnostics;
            }
        }
        return allDiagnosticsSent;
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.DOCUMENTATION, {
        traceLevel: trace_1.LspTraceLevel.VERBOSE,
        argumentsRenderer: args => args[0],
        resultRenderer: utils_1.renderDiags
    })
], WorkspaceDiagnostics.prototype, "calculateTranslationDiagnostics", null);
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.WORKSPACE, { traceLevel: trace_1.LspTraceLevel.VERBOSE, argumentsRenderer: args => args[0] })
], WorkspaceDiagnostics.prototype, "cleanDiagnostics", null);
exports.WorkspaceDiagnostics = WorkspaceDiagnostics;
//# sourceMappingURL=WorkspaceDiagnostics.js.map