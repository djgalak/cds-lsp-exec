"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InternalAnnotationHandler_1 = require("../../contributions/InternalAnnotationHandler");
const PpRuleToken_1 = require("../../prettyprint/PpRuleToken");
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
const CompletionStructures_1 = require("./CompletionStructures");
class ExternalAnnotationProposals {
    constructor() {
        var _a, _b;
        this.name = __filename;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.COMPLETION);
        this.annotationHandlers = (_b = (_a = trace_1.currentFrame().appScope.iocFactory) === null || _a === void 0 ? void 0 : _a.newInstance(InternalAnnotationHandler_1.ANNOTATION_HANDLERS)) !== null && _b !== void 0 ? _b : [];
    }
    async fetchProposals(context) {
        var _a;
        const expectedItems = [];
        if (this.annotationHandlers.length) {
            const lspLine = (antlrToken) => antlrToken.line - 1;
            const tokens = context.parseAst.tokenStream.tokens;
            const isTokenAtOrBefore = (antlrToken) => {
                const diff = lspLine(antlrToken) - context.position.line;
                if (diff > 0) {
                    return false;
                }
                if (diff === 0) {
                    return antlrToken.column - context.position.character <= 0;
                }
                return true;
            };
            const findTokenAtOrBefore = () => {
                let start = 0;
                let end = tokens.length - 1;
                const newMid = () => Math.floor((start + end) / 2);
                let mid = newMid();
                let oldMid = -1;
                while (oldMid !== mid) {
                    if (isTokenAtOrBefore(tokens[mid])) {
                        start = mid;
                    }
                    else {
                        end = mid - 1;
                    }
                    oldMid = mid;
                    mid = newMid();
                }
                return isTokenAtOrBefore(tokens[end]) ? tokens[end] : tokens[start];
            };
            let tokenAtOrBefore = findTokenAtOrBefore();
            if (context.keywordMap['@'] !== undefined ||
                tokenAtOrBefore.text === '@' ||
                (tokenAtOrBefore.text === ')' && (tokenAtOrBefore = tokens[tokenAtOrBefore.tokenIndex - 1]) && false) ||
                (tokenAtOrBefore.text === '(' && ((_a = tokens[tokenAtOrBefore.tokenIndex - 1]) === null || _a === void 0 ? void 0 : _a.text) === '@') ||
                findAnnotationAtPosition(context.parseAst, { line: lspLine(tokenAtOrBefore), character: tokenAtOrBefore.column })) {
                const model = await context.compile(context);
                const relativePath = context.localTriggerPath.slice(context.workspaceFolder.workspaceRoot.length + 1);
                for (const annotationHandler of this.annotationHandlers) {
                    const completionItems = await annotationHandler.fetchCompletionItems({ textDocument: { uri: context.triggerUri }, position: context.position }, model, relativePath);
                    completionItems.forEach(c => {
                        var _a;
                        c.sortText = CompletionStructures_1.SortPrefix.Annotation + ((_a = c.sortText) !== null && _a !== void 0 ? _a : 'zzz');
                        if (!c.data) {
                            c.data = {};
                        }
                        c.data['*origin'] = annotationHandler.name;
                    });
                    expectedItems.push(...completionItems);
                }
            }
        }
        return expectedItems;
    }
}
exports.ExternalAnnotationProposals = ExternalAnnotationProposals;
function findAnnotationAtPosition(parseAst, cursorPosition) {
    const crawlAnnotations = (carrier) => {
        const assignment = scrapeAnnotations(cursorPosition, carrier === null || carrier === void 0 ? void 0 : carrier.annotationAssignments);
        return assignment
            ? { carrier, assignment }
            : undefined;
    };
    const crawlX = (artifacts = []) => {
        for (const artifact of artifacts) {
            const a = crawlAnnotations(artifact) ||
                crawlX(Object.values(artifact.artifacts || {})) ||
                crawlX(artifact.extensions || []) ||
                crawlX(Object.values(artifact.elements || {}));
            if (a)
                return a;
        }
        return undefined;
    };
    return crawlX(Object.values(parseAst.artifacts)) || crawlX(parseAst.extensions);
}
exports.findAnnotationAtPosition = findAnnotationAtPosition;
function scrapeAnnotations(cursor, annotationAssignments = []) {
    for (const xsnAnnotationAssignment of annotationAssignments) {
        if (isCursorWithinAnnotation(cursor, xsnAnnotationAssignment)) {
            return xsnAnnotationAssignment;
        }
    }
    return undefined;
}
const START_LOCATION = { filename: '', start: { line: 1, column: 1 }, end: { line: 1, column: 1 } };
function isCursorWithinAnnotation(cursor, annotationAssignment) {
    var _a;
    const loc = utils_1.RangeAdapter.adapt((_a = annotationAssignment === null || annotationAssignment === void 0 ? void 0 : annotationAssignment.location) !== null && _a !== void 0 ? _a : START_LOCATION);
    switch (PpRuleToken_1.rangeRelativeToCursor(loc, cursor)) {
        case 'tokenStartsAtCursor':
        case 'tokenContainsCursor':
        case 'tokenEndsWithCursor':
            return true;
        default:
            return false;
    }
}
//# sourceMappingURL=ExternalAnnotationProposals.js.map