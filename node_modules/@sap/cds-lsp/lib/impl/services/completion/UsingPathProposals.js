"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const utils_1 = require("../../utils");
const CompletionStructures_1 = require("./CompletionStructures");
const CompletionUtils_1 = require("./CompletionUtils");
class UsingPathProposals {
    constructor() {
        this.name = __filename;
    }
    async fetchProposals(context) {
        const line = context.textLines.getLines()[context.position.line];
        const usingFromMatch = UsingPathProposals.usingFromRegex.exec(line);
        if (usingFromMatch === null) {
            return [];
        }
        delete context.keywordMap.string;
        const usingFrom = usingFromMatch[1];
        const firstAllowedPosition = usingFrom.length;
        const cursor = context.position.character;
        if (firstAllowedPosition > cursor) {
            return [];
        }
        const potentialPath = usingFromMatch[2];
        const openingQuotPresent = potentialPath.length > 0;
        const openingQuotPosition = openingQuotPresent ? line.indexOf("'") : undefined;
        const rightOfOpeningQuot = openingQuotPresent && openingQuotPosition < cursor;
        let closingQuotPosition = openingQuotPresent ? line.indexOf("'", openingQuotPosition + 1) : undefined;
        if (closingQuotPosition === -1) {
            closingQuotPosition = undefined;
        }
        const pathPrefixStart = openingQuotPosition && openingQuotPosition < cursor ? openingQuotPosition + 1 : firstAllowedPosition;
        let pathPrefix = line.slice(pathPrefixStart, cursor);
        if (!rightOfOpeningQuot && /^\s+$/.test(pathPrefix)) {
            pathPrefix = '';
        }
        const pathSuffix = line.slice(cursor, closingQuotPosition);
        const textEditRange = CompletionUtils_1.replacementRange(pathPrefix, pathSuffix, false, context.position);
        const decorators = this.getSurroundingClutter(firstAllowedPosition, rightOfOpeningQuot, closingQuotPosition, cursor);
        const proposalMap = new Map();
        const workspaceDocuments = await context.workspaceFolder.fetchSourceFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies);
        Object.keys(workspaceDocuments)
            .filter(uri => uri !== context.triggerUri)
            .forEach(uri => {
            let relativePath = decodeURIComponent(path.relative(path.dirname(context.localTriggerPath), utils_1.toLocalPath(uri)));
            if (!/^\.[./\\]*[/\\]/.test(relativePath)) {
                relativePath = utils_1.toPlatformPath('./') + relativePath;
            }
            const relativeUnixPath = utils_1.toUnixPath(relativePath);
            const absolutePath = decodeURIComponent(path.resolve(context.localTriggerDir, relativePath));
            const nodeModulesPattern = /(.*)node_modules[/\\](((@[^/\\]+[/\\])?[^/\\]+)[/\\](.*)?)/;
            const nodeModulesMatch = nodeModulesPattern.exec(absolutePath);
            if (nodeModulesMatch) {
                const nodeModulesLocation = nodeModulesMatch[1];
                let outsideCurrentNodeModule = true;
                const onlyCurrentOrParentDirs = /^[./\\]*$/;
                const triggerNodeModulesMatch = nodeModulesPattern.exec(context.localTriggerPath);
                if (triggerNodeModulesMatch) {
                    const triggerNodeModulesLocation = triggerNodeModulesMatch[1];
                    const relativeNodeModulesLocation = path.relative(triggerNodeModulesLocation, nodeModulesLocation);
                    if (!onlyCurrentOrParentDirs.test(relativeNodeModulesLocation)) {
                        return;
                    }
                    const triggerDirBelowModule = path.dirname(triggerNodeModulesMatch[5]);
                    outsideCurrentNodeModule = /^\.\.[/\\]/.test(path.join(triggerDirBelowModule, relativePath));
                }
                else {
                    const relativeNodeModulesLocation = path.relative(context.localTriggerDir, nodeModulesLocation);
                    if (!onlyCurrentOrParentDirs.test(relativeNodeModulesLocation)) {
                        return;
                    }
                }
                if (outsideCurrentNodeModule) {
                    const unixPathBelowNodeModules = utils_1.toUnixPath(nodeModulesMatch[2]);
                    const moduleProposal = utils_1.toUnixPath(nodeModulesMatch[3]);
                    if (pathPrefix.startsWith(moduleProposal + '/')) {
                        const moduleAndSlashLength = moduleProposal.length + 1;
                        const pathBelowModule = unixPathBelowNodeModules.slice(moduleAndSlashLength);
                        const prefixAfterModule = pathPrefix.slice(moduleAndSlashLength);
                        const rangeAfterModule = CompletionUtils_1.replacementRange(prefixAfterModule, pathSuffix, false, context.position);
                        this.addMatchingUsingPathProposal(uri, pathBelowModule, pathBelowModule, true, prefixAfterModule, rangeAfterModule, decorators, proposalMap, rightOfOpeningQuot);
                    }
                    else {
                        this.addMatchingUsingPathProposal(uri, moduleProposal, moduleProposal, true, pathPrefix, textEditRange, decorators, proposalMap, rightOfOpeningQuot);
                    }
                }
                else {
                    this.addMatchingUsingPathProposal(uri, relativeUnixPath, relativeUnixPath, false, pathPrefix, textEditRange, decorators, proposalMap, rightOfOpeningQuot);
                }
            }
            else {
                this.addMatchingUsingPathProposal(uri, relativeUnixPath, relativeUnixPath, false, pathPrefix, textEditRange, decorators, proposalMap, rightOfOpeningQuot);
            }
        });
        return Array.from(proposalMap.values());
    }
    addMatchingUsingPathProposal(targetUri, proposal, label, fromNodeModules, pathPrefix, textEditRange, decorators, proposalMap, enforceMatch) {
        if (enforceMatch && !proposal.startsWith(pathPrefix)) {
            return;
        }
        let dotsCount = 0;
        if (!fromNodeModules) {
            const dotsAndSlashes = /^[./]*\//.exec(proposal);
            dotsCount = dotsAndSlashes ? dotsAndSlashes[0].replace(/\//g, '').length : 0;
        }
        const sortPrefix = fromNodeModules
            ? CompletionStructures_1.SortPrefix.Module
            : CompletionStructures_1.SortPrefix.File + (dotsCount + ':');
        const effectiveLabel = decorators.labelStart + label + decorators.labelEnd;
        const proposalWithoutExtension = proposal.replace(/\.(cds|json)$/, '');
        const effectiveProposal = decorators.start + proposalWithoutExtension + decorators.end;
        proposalMap.set(effectiveLabel, {
            label: effectiveLabel,
            sortText: sortPrefix + effectiveLabel,
            kind: LSP.CompletionItemKind.File,
            textEdit: LSP.TextEdit.replace(textEditRange, effectiveProposal),
            data: { targetUri }
        });
    }
    getSurroundingClutter(firstAllowedPosition, rightOfOpeningQuot, closingQuotPosition, cursor) {
        let start = '';
        let labelStartEnd = '';
        if (cursor === firstAllowedPosition) {
            start = ' ';
            labelStartEnd = "'";
        }
        start += (rightOfOpeningQuot ? '' : "'");
        const end = closingQuotPosition ? '' : "';";
        return {
            start,
            end,
            labelStart: labelStartEnd,
            labelEnd: labelStartEnd
        };
    }
}
exports.UsingPathProposals = UsingPathProposals;
UsingPathProposals.usingFromRegex = /^(\s*using\b.*\bfrom)\s*('([^']*).*|$)/;
//# sourceMappingURL=UsingPathProposals.js.map