"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const csn_api_1 = require("../../csn-api");
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
function replacementRange(aPrefix, aSuffix, reduce, position) {
    let reducedSuffix = aSuffix;
    if (reduce) {
        reducedSuffix = aSuffix.startsWith('.') ? '' : aSuffix.split('.')[0];
    }
    return LSP.Range.create(position.line, position.character - aPrefix.length, position.line, position.character + reducedSuffix.length);
}
exports.replacementRange = replacementRange;
function filterMessagesInScope({ position }, message, relativeProvokerPosition) {
    return (message && isInRange(csn_api_1.locationOf(message), {
        line: position.line,
        character: position.character + relativeProvokerPosition
    }));
}
exports.filterMessagesInScope = filterMessagesInScope;
function isInRange(range, cursorPos) {
    try {
        const rangeStart = utils_1.PositionAdapter.adapt(range.start);
        const rangeEnd = utils_1.PositionAdapter.adapt(range.end);
        if (rangeStart.line === cursorPos.line) {
            const endColumn = rangeEnd.line > rangeStart.line ? Infinity : rangeEnd.character;
            return rangeStart.character <= cursorPos.character && cursorPos.character <= endColumn;
        }
    }
    catch (e) {
        trace_1.currentTrace().tracer(trace_1.LspTraceComponent.COMPLETION).verbose(e.stack || e);
    }
    return false;
}
exports.isInRange = isInRange;
//# sourceMappingURL=CompletionUtils.js.map