"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
const CompletionStructures_1 = require("./CompletionStructures");
const CompletionUtils_1 = require("./CompletionUtils");
const DocumentationProposals_1 = require("./DocumentationProposals");
const ExternalAnnotationProposals_1 = require("./ExternalAnnotationProposals");
const FormatterOptionProposals_1 = require("./FormatterOptionProposals");
const IdentifierProposals_1 = require("./IdentifierProposals");
const KeywordProposals_1 = require("./KeywordProposals");
const TranslationReferenceProposals_1 = require("./TranslationReferenceProposals");
const UsingPathProposals_1 = require("./UsingPathProposals");
class CompletionService {
    constructor(_lspOptions, workspaceService, compiler) {
        this._lspOptions = _lspOptions;
        this.workspaceService = workspaceService;
        this.compiler = compiler;
        this.isStrictCompletions = process.argv.includes('--strict-code-completion');
        this.proposalProviders = [];
        this.keywordErrorProvoker = 'â‰ ';
        this.defaultParseOptions = {
            fallbackParser: 'cds',
            parseOnly: true,
            lintMode: true,
            attachTokens: true
        };
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.COMPLETION);
        this.documentationProposals = new DocumentationProposals_1.DocumentationProposals(this.tracer, this._lspOptions);
        this.proposalProviders.push(new IdentifierProposals_1.IdentifierProposals(this), new FormatterOptionProposals_1.FormatterOptionProposals(), new UsingPathProposals_1.UsingPathProposals(), new TranslationReferenceProposals_1.TranslationReferenceProposals(workspaceService), new ExternalAnnotationProposals_1.ExternalAnnotationProposals(), new KeywordProposals_1.KeywordProposals(this));
    }
    async onCompletion(textDocumentPosition) {
        const completionItems = await this.getCompletionItems(textDocumentPosition);
        return {
            isIncomplete: false,
            items: completionItems
        };
    }
    onCompletionResolve(item) {
        if (this._lspOptions.getClientCapability(utils_1.ClientCapability.SUPPORTED_DOC_FORMATS, []).includes(LSP.MarkupKind.Markdown)) {
            const showDocs = this._lspOptions.getUserSetting(utils_1.UserSetting.DOCS_IN_COMPLETION, true);
            if (showDocs) {
                this.documentationProposals.attachDocumentation(item);
            }
        }
        return item;
    }
    matchesPrefix(caseInsensitive, prefix, ...namesToCheck) {
        if (!this.isStrictCompletions) {
            return true;
        }
        for (let nameToCheck of namesToCheck) {
            if (caseInsensitive) {
                nameToCheck = nameToCheck.toLowerCase();
            }
            if (nameToCheck.startsWith(caseInsensitive ? prefix.toLowerCase() : prefix)) {
                return true;
            }
        }
        return false;
    }
    prepareContent({ textLines, position }, errorProvoker, relativeProvokerPosition) {
        return textLines.clone().insert(errorProvoker, {
            line: position.line,
            character: position.character + relativeProvokerPosition
        }).getText();
    }
    async fetchCompletionContext(textDocumentPosition) {
        const context = new CompletionStructures_1.CompletionContext((ctx, inlay = '') => this.compileWithInlay(ctx, inlay));
        context.triggerUri = textDocumentPosition.textDocument.uri;
        context.localTriggerPath = utils_1.toLocalPath(context.triggerUri);
        if (!path.isAbsolute(context.localTriggerPath)) {
            context.localTriggerPath = path.join(process.cwd(), context.localTriggerPath);
        }
        context.localTriggerDir = path.dirname(context.localTriggerPath);
        context.workspaceFolder = this.workspaceService.getWorkspaceFolder(context.triggerUri);
        context.originalFiles = await context.workspaceFolder.fetchSourceFiles();
        const originalContent = context.originalFiles[context.triggerUri];
        context.position = textDocumentPosition.position;
        context.originalContent = originalContent;
        context.textLines = new utils_1.TextLines(originalContent || '');
        const { prefix, suffix } = CompletionService.getPrefixAndSuffix(context.textLines, textDocumentPosition.position);
        context.prefix = prefix;
        context.suffix = suffix;
        return context;
    }
    async getCompletionItems(textDocumentPosition) {
        const context = await this.fetchCompletionContext(textDocumentPosition);
        if (this.tracer.isTracing(trace_1.LspTraceLevel.VERBOSE)) {
            const lineToTrace = context.textLines.clone().insert('<<<coco>>>', textDocumentPosition.position).getLines()[textDocumentPosition.position.line];
            this.tracer.verbose('Completions for line: ', lineToTrace);
        }
        context.parseAst = await this.compiler.parse(context.originalContent, context.localTriggerPath, context.workspaceFolder.workspaceRoot, this.defaultParseOptions);
        const { keywordMap, isEndOfStatement } = await this.fetchPossibleKeywords(context);
        context.isEndOfStatement = isEndOfStatement;
        context.keywordMap = keywordMap;
        const expectedItems = [];
        for (const proposalProvider of this.proposalProviders) {
            try {
                expectedItems.push(...await proposalProvider.fetchProposals(context));
            }
            catch (e) {
                this.tracer.warn(`Proposal provider ${proposalProvider.name} failed with: ${e.stack || e}`);
            }
        }
        const sortText = (x) => x.sortText || 'zzz';
        expectedItems.sort((first, second) => sortText(first).localeCompare(sortText(second), 'en-US', { sensitivity: 'base' }));
        return expectedItems;
    }
    async fetchPossibleKeywords(context) {
        const { textLines, position, prefix, suffix, workspaceFolder } = context;
        let isEndOfStatement = false;
        const keywordMap = utils_1.empty();
        {
            const trailingLine = textLines.getLines()[position.line].slice(position.character);
            const trailingTokens = trailingLine.split(' ').filter(segment => segment !== '');
            const nextToken = trailingTokens.length > 0 ? trailingTokens[0] : '';
            const handleParseMessage = (message, insertSuggestion = false) => {
                if (!message.expectedTokens) {
                    return;
                }
                this.tracer.verbose(() => `Raw suggestions for ${insertSuggestion ? 'insert' : 'replace'}: ${message.expectedTokens}`);
                message.expectedTokens.forEach(token => {
                    token = utils_1.replaceAll(token, "'", '');
                    token = token.toLowerCase();
                    if (token === '<eof>') {
                        return;
                    }
                    if (token === ';') {
                        isEndOfStatement = true;
                    }
                    if (prefix !== '' && nextToken.startsWith(token)) {
                        this.tracer.info(() => `Removing next suggested token: ${token}`);
                        return;
                    }
                    if (!insertSuggestion && prefix.length && !CompletionService.isIdentifierSegment(token)) {
                        return;
                    }
                    if (insertSuggestion && CompletionService.isIdentifierSegment(token)) {
                        return;
                    }
                    keywordMap[token] = insertSuggestion;
                });
            };
            await this.tracer.footprint('Parsing at beginning of prefix', async () => {
                const relativeProvokerPosition = -prefix.length;
                const ast = await this.compiler.parse(this.prepareContent(context, this.keywordErrorProvoker, relativeProvokerPosition), context.localTriggerPath, workspaceFolder.workspaceRoot, this.defaultParseOptions);
                let parseMessages = ast.messages;
                parseMessages = parseMessages.filter(msg => CompletionUtils_1.filterMessagesInScope(context, msg, relativeProvokerPosition));
                parseMessages.forEach(message => {
                    handleParseMessage(message);
                });
            });
            if (prefix.length && !suffix.length) {
                await this.tracer.footprint('Parsing after prefix', async () => {
                    const relativeProvokerPosition = 0;
                    const ast = await this.compiler.parse(this.prepareContent(context, this.keywordErrorProvoker, relativeProvokerPosition), context.localTriggerPath, workspaceFolder.workspaceRoot, this.defaultParseOptions);
                    let parseMessages = ast.messages;
                    parseMessages = parseMessages.filter(msg => CompletionUtils_1.filterMessagesInScope(context, msg, relativeProvokerPosition));
                    parseMessages.forEach(message => {
                        handleParseMessage(message, true);
                    });
                });
            }
        }
        return { keywordMap, isEndOfStatement };
    }
    async compileWithInlay(context, inlay) {
        const modifiedFiles = utils_1.empty();
        for (const [uri, content] of utils_1.entries(context.originalFiles)) {
            modifiedFiles[utils_1.toLocalPath(uri)] = content;
        }
        modifiedFiles[context.localTriggerPath] = this.prepareContent(context, inlay, -context.prefix.length);
        const options = {
            fallbackParser: 'cds',
            attachValidNames: (() => false)
        };
        const model = await this.compiler.compile(context.localTriggerPath, modifiedFiles, context.workspaceFolder.workspaceRoot, options);
        return model;
    }
    static isIdentifierSegment(s) {
        const regex = RegExp('^' + this.identifierRule + '$');
        return regex.test(s);
    }
    static getPrefixAndSuffix(textLines, cursorPosition) {
        const line = textLines.getLines()[cursorPosition.line];
        const prefixLine = line.slice(0, cursorPosition.character);
        const preMatches = prefixLine.match(new RegExp(CompletionService.dottedIdentifier + '\\.?$', 'gim'));
        let prefix = preMatches && preMatches.length
            ? preMatches.slice(-1)[0]
            : '';
        const reducedLine = (prefix + line.slice(cursorPosition.character));
        const allMatches = reducedLine.match(new RegExp(CompletionService.dottedIdentifier, 'gim'));
        const suffix = allMatches && allMatches.length && reducedLine.indexOf(allMatches[0]) === 0
            ? allMatches[0].slice(prefix.length)
            : '';
        const lastSegmentStart = prefix.lastIndexOf('.') + 1;
        if (lastSegmentStart > 0) {
            prefix = prefix.substring(lastSegmentStart);
        }
        return { prefix, suffix };
    }
}
CompletionService.identifierRule = '(([$_a-zA-Z][$_a-zA-Z0-9]*)|("[^\\u0022\\n\\r\\u2028\\u2029]*")+)';
CompletionService.dottedIdentifier = CompletionService.identifierRule + '(\\.' + CompletionService.identifierRule + ')*';
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderTextPos,
        resultRenderer: utils_1.renderCompletionList,
        onErrorReturn: { isIncomplete: false, items: [] }
    })
], CompletionService.prototype, "onCompletion", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderCompletionItem,
        resultRenderer: utils_1.renderCompletionItem,
        onErrorReturn: trace_1.FIRST_ARGUMENT
    })
], CompletionService.prototype, "onCompletionResolve", null);
exports.CompletionService = CompletionService;
//# sourceMappingURL=CompletionService.js.map