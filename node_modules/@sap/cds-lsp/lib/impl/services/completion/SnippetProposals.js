"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const utils_1 = require("../../utils");
const CompletionStructures_1 = require("./CompletionStructures");
class SnippetProposals {
    constructor(tracer, workspaceService, _lspOptions) {
        this.tracer = tracer;
        this.workspaceService = workspaceService;
        this._lspOptions = _lspOptions;
    }
    async getSnippetItems(keyword, fileUri, keywords, isEndOfStatement) {
        const expectedItems = [];
        const clientSupportsSnippets = this._lspOptions.getClientCapability(utils_1.ClientCapability.SUPPORT_SNIPPETS, false);
        if (clientSupportsSnippets) {
            const snippet = (title, body) => ({
                label: title + CompletionStructures_1.SnippetTail,
                sortText: CompletionStructures_1.SortPrefix.Snippet + keyword,
                kind: LSP.CompletionItemKind.Snippet,
                insertText: body,
                insertTextFormat: LSP.InsertTextFormat.Snippet
            });
            switch (keyword) {
                case '@':
                    if (isEndOfStatement && !keywords.includes('entity')) {
                        const tdSnippet = snippet('title & description', '@(\n\ttitle: \'{i18n>$1}\',\n\tdescription: \'{i18n>$2}\'\n)$0');
                        tdSnippet.documentation = 'Add title and description';
                        expectedItems.push(tdSnippet);
                    }
                    else {
                        const tdSnippet = snippet('title & description', '@title: \'{i18n>$1}\'\n@description: \'{i18n>$2}\'$0');
                        tdSnippet.documentation = 'Add title and description';
                        expectedItems.push(tdSnippet);
                        const docSnippet = snippet('doc', "@cds.doc: '$1'");
                        docSnippet.documentation = 'Add documentation\ne.g. shown at code completion or when hovering';
                        expectedItems.push(docSnippet);
                    }
                    break;
                case 'annotate':
                    {
                        const daSnippet = snippet('doc_annotate', 'annotate ${1:Foo} with @(\n\tcds.doc: \'$2\'\n);\n$0');
                        daSnippet.documentation = 'Add documentation via separate annotate\ne.g. shown at code completion or when hovering';
                        expectedItems.push(daSnippet);
                        expectedItems.push(snippet('annotate', 'annotate ${1:Foo} with $0;\n'));
                    }
                    break;
                case 'association':
                    expectedItems.push(snippet('Association to', 'Association ${1|to ,to one ,to many |}'));
                    break;
                case 'composition':
                    expectedItems.push(snippet('Composition of', 'Composition ${1|of ,of one ,of many |}'));
                    break;
                case 'context':
                    expectedItems.push(snippet('context', 'context ${1:$TM_FILENAME_BASE} {\n\t$0\n}'));
                    break;
                case 'element':
                    expectedItems.push(snippet('element', '${1:key }${2:ElementName} : $3;\n$0'));
                    break;
                case 'entity':
                    expectedItems.push(snippet('entity', 'entity ${1:Foo} : ${2:cuid} {\n\t$0\n}'));
                    expectedItems.push(snippet('entity projection', 'entity ${1:Foo} as projection on ${2:Bar};'));
                    break;
                case 'extend':
                    expectedItems.push(snippet('extend Foo with Bar', 'extend ${1:Foo} with ${2:Bar};\n$0'));
                    expectedItems.push(snippet('extend Foo with @annotation', 'extend ${1:Foo} with @${2:title:\'Foo\'};\n$0'));
                    expectedItems.push(snippet('extend Foo with element', 'extend ${1:Foo} with {\n\t${2:bar : Integer @(baz)}\n};\n$0'));
                    break;
                case 'namespace': {
                    const relativeFolder = fileUri
                        .slice(this.workspaceService.getWorkspaceFolder(fileUri).workspaceUri.length)
                        .split('/')
                        .slice(0, -1)
                        .filter((segment) => segment)
                        .join('.') || 'com.sample';
                    expectedItems.push(snippet('namespace', 'namespace ${1:' + relativeFolder + '};\n\n$0'));
                    break;
                }
                case 'service':
                    expectedItems.push(snippet('service', 'service ${1:MyService} {\n\n\t$0\n\n}'));
                    break;
                case 'type':
                    if (keywords.includes('entity')) {
                        expectedItems.push(snippet('enum', 'type ${1:Color} : ${2:String} enum {\n\t${3:black;}\n\t${4:white;}\n};\n$0'));
                        expectedItems.push(snippet('type', 'type ${1:Name} : ${2:String(${3:20})};\n$0'));
                        expectedItems.push(snippet('structured type', 'type ${1:Named} : {\n\t${2:Name} : ${3:String(${4:20})};\n\t$0\n};\n'));
                    }
                    break;
                case 'using': {
                    const suggestedPath = await this.fetchDefaultSuggestedPathForUsingSnippet(fileUri);
                    expectedItems.push(snippet('using', `using { $2 } from '$1${suggestedPath}';\n$0`));
                    break;
                }
            }
        }
        return expectedItems;
    }
    async fetchDefaultSuggestedPathForUsingSnippet(fileUri) {
        const pkgFiles = await this.workspaceService.getWorkspaceFolder(fileUri).fetchPackageJsonFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies);
        let fileSegments = fileUri.split('/');
        while (fileSegments.length) {
            try {
                fileSegments = fileSegments.slice(0, -1);
                const potentialPkgPath = fileSegments.concat('package.json').join('/');
                this.tracer.verbose(() => `Checking for path '${potentialPkgPath}'`);
                const pkgContent = pkgFiles[potentialPkgPath];
                if (!pkgContent) {
                    continue;
                }
                const pkg = JSON.parse(pkgContent);
                this.tracer.verbose(() => `Found '${potentialPkgPath}'. Checking dependencies for '@sap/cds'`);
                if (pkg && pkg.dependencies && pkg.dependencies['@sap/cds']) {
                    this.tracer.verbose("Found dependencies to '@sap/cds'. Suggesting '@sap/cds/common' as default using path");
                    return '@sap/cds/common';
                }
            }
            catch (e) {
                this.tracer.warn('Failed during check of package.json for @sap/cds', e);
            }
        }
        return '';
    }
}
exports.SnippetProposals = SnippetProposals;
//# sourceMappingURL=SnippetProposals.js.map