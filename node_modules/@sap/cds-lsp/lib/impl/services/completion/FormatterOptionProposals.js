"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const PpBaseTypes_1 = require("../../prettyprint/PpBaseTypes");
const PpRuleToken_1 = require("../../prettyprint/PpRuleToken");
const trace_1 = require("../../utils/trace");
const CompletionStructures_1 = require("./CompletionStructures");
class FormatterOptionProposals {
    constructor() {
        this.name = __filename;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.COMPLETION);
    }
    async fetchProposals(context) {
        try {
            const line = context.textLines.getLines()[context.position.line];
            this.tracer.debug(() => `Checking if potentially within comment, line: ${line.slice(0, 50)}`);
            const lastPotentialOpeningLineComment = line.lastIndexOf('//', context.position.character);
            let potentiallyWithinComment = false;
            if (lastPotentialOpeningLineComment >= 0) {
                potentiallyWithinComment = true;
            }
            else {
                const cursorOffset = context.textLines._splitLines.lineOffsets[context.position.line] + context.position.character;
                const lastPotentialOpeningBlockComment = context.originalContent.lastIndexOf('/*', cursorOffset);
                if (lastPotentialOpeningBlockComment >= 0) {
                    this.tracer.debug(() => `Block comment opening found at offset ${lastPotentialOpeningBlockComment}`);
                    const lastPotentialClosingBlockComment = context.originalContent.lastIndexOf('*/', cursorOffset);
                    this.tracer.debug(() => `Block comment closing found at offset ${lastPotentialClosingBlockComment}`);
                    if (lastPotentialClosingBlockComment >= cursorOffset || lastPotentialClosingBlockComment < lastPotentialOpeningBlockComment) {
                        potentiallyWithinComment = true;
                    }
                }
            }
            if (!potentiallyWithinComment) {
                return [];
            }
            const relevantCommentToken = (t) => {
                const category = PpBaseTypes_1.getCategory(t);
                if (category === 'Comment' || category === 'LineComment' || category === 'DocComment') {
                    const relPos = new PpRuleToken_1.PpToken(t).relativeToCursor(context.position);
                    switch (relPos) {
                        case 'tokenStartsAtCursor':
                        case 'tokenContainsCursor':
                        case 'tokenEndsWithCursor':
                            return true;
                    }
                }
                return false;
            };
            this.tracer.debug(() => 'Potentially within comment, parsing to retrieve token');
            const ast = context.parseAst;
            const token = ast.tokenStream.tokens.find(relevantCommentToken);
            if (token) {
                this.tracer.debug(() => `Comment token found: ${token.text}`);
                const category = PpBaseTypes_1.getCategory(token);
                const isBlockComment = category === 'Comment' || category === 'DocComment';
                const content = isBlockComment
                    ? token.text.slice(2, -2).trim() :
                    token.text.slice(2).trim();
                this.tracer.debug(() => `Comment token content: '${content}'`);
                const atFormatter = '@formatter';
                if (atFormatter.startsWith(content.slice(0, atFormatter.length))) {
                    const newText = (newContent) => isBlockComment ? `/* ${newContent} */` : `// ${newContent}`;
                    return [
                        {
                            label: 'Turn off code formatter from here on',
                            filterText: token.text,
                            sortText: CompletionStructures_1.SortPrefix.Keyword + 'formatterOff',
                            kind: LSP.CompletionItemKind.Constant,
                            textEdit: LSP.TextEdit.replace(new PpRuleToken_1.PpToken(token).range, newText('@formatter:off')),
                            commitCharacters: [],
                            data: {}
                        },
                        {
                            label: 'Turn on again code formatter',
                            filterText: token.text,
                            sortText: CompletionStructures_1.SortPrefix.Keyword + 'formatterOn',
                            kind: LSP.CompletionItemKind.Constant,
                            textEdit: LSP.TextEdit.replace(new PpRuleToken_1.PpToken(token).range, newText('@formatter:on')),
                            commitCharacters: [],
                            data: {}
                        }
                    ];
                }
            }
        }
        catch (e) {
            this.tracer.error('Failed to detect formatter proposals in comments', e);
        }
        return [];
    }
}
exports.FormatterOptionProposals = FormatterOptionProposals;
//# sourceMappingURL=FormatterOptionProposals.js.map