"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const trace_1 = require("../../utils/trace");
const CompletionStructures_1 = require("./CompletionStructures");
const CompletionUtils_1 = require("./CompletionUtils");
const SnippetProposals_1 = require("./SnippetProposals");
class KeywordProposals {
    constructor(completionService) {
        this.completionService = completionService;
        this.name = __filename;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.COMPLETION);
        this.snippetProposals = new SnippetProposals_1.SnippetProposals(this.tracer, completionService.workspaceService, completionService._lspOptions);
    }
    async fetchProposals(context) {
        return this.getKeywordItems(context);
    }
    async getKeywordItems(context) {
        let expectedItems = [];
        const keywords = Object.keys(context.keywordMap);
        for (let keyword of keywords) {
            if (this.completionService.matchesPrefix(true, context.prefix, keyword)) {
                if (!context.suffix.length) {
                    const snippetItems = await this.snippetProposals.getSnippetItems(keyword, context.triggerUri, keywords, context.isEndOfStatement);
                    expectedItems = expectedItems.concat(snippetItems);
                }
                let trimmedToken = keyword.trimLeft();
                let sortText = CompletionStructures_1.SortPrefix.Keyword + trimmedToken;
                switch (trimmedToken) {
                    case 'association':
                        trimmedToken = 'Association';
                        keyword = 'Association to ';
                        sortText = CompletionStructures_1.SortPrefix.Snippet + trimmedToken;
                        break;
                    case 'composition':
                        trimmedToken = 'Composition';
                        keyword = 'Composition of ';
                        sortText = CompletionStructures_1.SortPrefix.Snippet + trimmedToken;
                        break;
                }
                expectedItems.push({
                    label: trimmedToken,
                    sortText,
                    kind: LSP.CompletionItemKind.Keyword,
                    textEdit: LSP.TextEdit.replace(context.keywordMap[keyword]
                        ? LSP.Range.create(context.position.line, context.position.character, context.position.line, context.position.character)
                        : CompletionUtils_1.replacementRange(context.prefix, context.suffix, true, context.position), keyword)
                });
            }
        }
        return expectedItems;
    }
}
exports.KeywordProposals = KeywordProposals;
//# sourceMappingURL=KeywordProposals.js.map