"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const csn_api_1 = require("../../csn-api");
const utils_1 = require("../../utils");
const trace_1 = require("../../utils/trace");
const CompletionStructures_1 = require("./CompletionStructures");
const CompletionUtils_1 = require("./CompletionUtils");
class IdentifierProposals {
    constructor(completionService) {
        this.completionService = completionService;
        this.name = __filename;
        this.tracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.COMPLETION);
    }
    async fetchProposals(context) {
        if (context.keywordMap.identifier !== undefined) {
            delete context.keywordMap.identifier;
            return this.fetchPossibleIdentifierItems(context);
        }
        return [];
    }
    async fetchPossibleIdentifierItems(context) {
        const model = await context.compile(context, 'xx_xx_xx_xx_xx_xx_xx');
        let compileMessages = model.messages;
        compileMessages = compileMessages.filter(CompletionUtils_1.filterMessagesInScope.bind(null, context));
        this.completionService.documentationProposals.resetIdentifiers();
        const index = csn_api_1.BlitzIndex.build(context.triggerUri, context.workspaceFolder.workspaceDocuments, model, -1, this.completionService.workspaceService.getWorkspaceFolder(context.triggerUri).adapter);
        let expectedItems = [];
        for (const message of compileMessages) {
            expectedItems = expectedItems.concat(await this.extractIdentifiersFromCompileMessage(index, message, context, CompletionUtils_1.replacementRange(context.prefix, context.suffix, true, context.position)));
        }
        return expectedItems;
    }
    async extractIdentifiersFromCompileMessage(index, message, { prefix, position, triggerUri }, range) {
        var _a;
        const expectedItems = [];
        try {
            const validNames = message.validNames;
            if (this.tracer.isTracing(trace_1.LspTraceLevel.VERBOSE)) {
                const vns = utils_1.entries(validNames).map(([id, vn]) => `${vn.kind} ${id}`);
                this.tracer.verbose('Raw suggestions for identifier replacements: ', utils_1.arr(vns));
            }
            if (validNames) {
                const clientSupportsSnippets = this.completionService._lspOptions.getClientCapability(utils_1.ClientCapability.SUPPORT_SNIPPETS, false);
                for (const identifier of Object.keys(validNames)) {
                    const validName = validNames[identifier];
                    if (this.completionService.matchesPrefix(true, prefix, identifier, validName.name.absolute || validName.name.id)) {
                        const sortPrefix = validName.builtin ? CompletionStructures_1.SortPrefix.BuiltinIdentifier : CompletionStructures_1.SortPrefix.CustomIdentifier;
                        const item = {
                            label: identifier,
                            sortText: sortPrefix + identifier,
                            kind: utils_1.adaptCompletionKind(validName.kind),
                            textEdit: LSP.TextEdit.replace(range, identifier),
                            commitCharacters: ['.'],
                            data: {}
                        };
                        if (sortPrefix === CompletionStructures_1.SortPrefix.CustomIdentifier) {
                            const workspaceFolder = this.completionService.workspaceService.getWorkspaceFolder(triggerUri);
                            const location = csn_api_1.adaptLocation(validName, workspaceFolder.adapter);
                            if (location) {
                                const def = index.definitionAt(location.uri, location.range.start);
                                await this.completionService.documentationProposals.attachDocsForDefinition(item, workspaceFolder.documentationProvider, def);
                                item.data.position = { ...position };
                                item.data.url = triggerUri;
                            }
                        }
                        expectedItems.push(item);
                        if (((_a = validName.parameters) === null || _a === void 0 ? void 0 : _a.length) && clientSupportsSnippets) {
                            const snippetItem = JSON.parse(JSON.stringify(item));
                            snippetItem.label += '(\u2026)';
                            const COMMA = ', ';
                            let paramExpr = '(';
                            for (let i = 0; i < validName.parameters.length; i++) {
                                const parameterName = validName.parameters[i];
                                paramExpr += '${' + (i + 1) + ':<' + parameterName + '>}' + COMMA;
                            }
                            paramExpr = paramExpr.slice(0, -COMMA.length);
                            paramExpr += ')';
                            snippetItem.textEdit = LSP.TextEdit.replace(range, identifier + paramExpr);
                            snippetItem.insertTextFormat = LSP.InsertTextFormat.Snippet;
                            snippetItem.kind = LSP.CompletionItemKind.Snippet;
                            expectedItems.push(snippetItem);
                        }
                    }
                }
            }
        }
        catch (e) {
            this.tracer.verbose(e.stack || e);
        }
        return expectedItems;
    }
}
__decorate([
    trace_1.Footprint(trace_1.LspTraceComponent.COMPLETION, { scope: 'Compiling @ beginning of prefix', argumentsRenderer: utils_1.renderNothing })
], IdentifierProposals.prototype, "fetchPossibleIdentifierItems", null);
exports.IdentifierProposals = IdentifierProposals;
//# sourceMappingURL=IdentifierProposals.js.map