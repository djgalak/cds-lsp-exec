"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LSP = require("vscode-languageserver-protocol");
const CompletionStructures_1 = require("./CompletionStructures");
class TranslationReferenceProposals {
    constructor(workspaceService) {
        this.workspaceService = workspaceService;
        this.name = __filename;
    }
    async fetchProposals(context) {
        const lineNumber = context.position.line;
        const line = context.textLines.getLines()[lineNumber];
        const cursorPos = context.position.character;
        const fetchAllTranslationIds = async (idPrefix, startPos, endPos, andTemplate = false) => {
            const addLocalizedTextSnippet = {
                label: 'Add localized text' + CompletionStructures_1.SnippetTail,
                kind: LSP.CompletionItemKind.Snippet,
                sortText: CompletionStructures_1.SortPrefix.Translation,
                insertText: '{i18n>${1:define translation id}\}',
                insertTextFormat: LSP.InsertTextFormat.Snippet
            };
            const result = andTemplate ? [addLocalizedTextSnippet] : [];
            const workspaceFolder = this.workspaceService.getWorkspaceFolder(context.triggerUri);
            const allTrans = await workspaceFolder.translationBroker.fetchAllTranslations(context.triggerUri);
            if (!allTrans.length) {
                return result;
            }
            return result
                .concat(allTrans
                .filter(t => !idPrefix || (t.id && t.id.startsWith(idPrefix)))
                .map((trans) => ({
                label: `${trans.id}`,
                filterText: `{i18n>${trans.id}}`,
                kind: LSP.CompletionItemKind.Enum,
                sortText: CompletionStructures_1.SortPrefix.Translation + trans.id,
                documentation: trans.text,
                textEdit: LSP.TextEdit.replace(LSP.Range.create(lineNumber, startPos, lineNumber, endPos), `{i18n>${trans.id}}`)
            })));
        };
        const quotedI18nString = /'{i18n>([^}'\s]*)}?'/;
        const genericTagMatch = quotedI18nString.exec(line);
        if (genericTagMatch && genericTagMatch.length > 1) {
            const endPos = genericTagMatch.index + genericTagMatch[0].length;
            const startPos = genericTagMatch.index;
            const cursorInsideString = cursorPos > startPos && cursorPos <= endPos;
            if (cursorInsideString && genericTagMatch[1]) {
                const idPrefix = line.slice(genericTagMatch.index + "'{i18n>".length, cursorPos - 1);
                return fetchAllTranslationIds(idPrefix, startPos + 1, endPos - 1);
            }
        }
        const docTagRegex = /(title|description|cds\.doc)\s*:\s*'([^'\s]*)[^']*'/;
        const docTagMatch = docTagRegex.exec(line);
        if (docTagMatch && docTagMatch.length > 2) {
            const startOfQuote = line.indexOf("'", docTagMatch.index);
            const endPos = docTagMatch.index + docTagMatch[0].length;
            const cursorInsideString = cursorPos > startOfQuote && cursorPos <= endPos;
            if (cursorInsideString) {
                return fetchAllTranslationIds('', startOfQuote + 1, endPos - 1, true);
            }
        }
        return [];
    }
}
exports.TranslationReferenceProposals = TranslationReferenceProposals;
//# sourceMappingURL=TranslationReferenceProposals.js.map