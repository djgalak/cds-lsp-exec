"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const StringUtil_1 = require("../../prettyprint/util/StringUtil");
const utils_1 = require("../../utils");
const CompletionStructures_1 = require("./CompletionStructures");
class DocumentationProposals {
    constructor(tracer, _lspOptions) {
        this.tracer = tracer;
        this._lspOptions = _lspOptions;
        this.nextFreeIdentifierDocIndex = 0;
    }
    resetIdentifiers() {
        this.nextFreeIdentifierDocIndex = 0;
        this.docsForIdentifiers = [];
    }
    attachDocumentation(item) {
        const sortText = item.sortText || 'zzz';
        if (sortText.startsWith(CompletionStructures_1.SortPrefix.BuiltinIdentifier)) {
            this._attachDocumentation(item, item.label, false, '04-Elements-Types-.md', [{ from: '### pre-defined types', to: '### custom-defined types' }]);
        }
        else if (sortText.startsWith(CompletionStructures_1.SortPrefix.Keyword)) {
            this._attachDocumentation(item, '@', false, '06-Annotations-.md', [{ from: '### annotation syntax' }]);
            this._attachDocumentation(item, 'action', false, '08-Services-.md', [{ from: '### actions / functions', to: '### derived services' }]);
            this._attachDocumentation(item, 'function', false, '08-Services-.md', [{ from: '### actions / functions', to: '### derived services' }]);
            this._attachDocumentation(item, 'excluding', false, '06-Excluding-Clause-.md', [{ from: '' }]);
            this._attachDocumentation(item, 'mixin', false, '07-Query-local-Mixins-.md', [{ from: '' }]);
            this._attachDocumentation(item, 'virtual', false, '04-Elements-Types-.md', [{ from: '### virtual elements', to: '### element constraints' }]);
        }
        else if (sortText.startsWith(CompletionStructures_1.SortPrefix.Module)) {
            this.attachPossibleModuleDocumentation(item);
        }
        else if (sortText.startsWith(CompletionStructures_1.SortPrefix.CustomIdentifier)) {
            this.attachPossibleIdentifierDocumentation(item);
        }
        else if (sortText.startsWith(CompletionStructures_1.SortPrefix.Snippet)) {
            this._attachDocumentation(item, 'annotate', true, '07-Aspects-.md', [{ from: '### annotate', to: '### extend view' }, { from: '### named aspects' }]);
            this._attachDocumentation(item, 'Association', true, '05-Associations-.md', [{ from: '## Associations', to: '<!-- TOC' }, { from: '### unmanaged', to: '### managed many-to-many' }]);
            this._attachDocumentation(item, 'Composition', true, '05-Associations-.md', [{ from: '### Compositions', to: '### ... of inner types' }]);
            this._attachDocumentation(item, 'context', true, '10-Namespaces-.md', [{ from: '### contexts' }]);
            this._attachDocumentation(item, 'entity', true, '03-Entities-.md', [{ from: '### entities', to: '### views' }, { from: '### abstract entities' }]);
            this._attachDocumentation(item, 'enum', true, '04-Elements-Types-.md', [{ from: '### enums', to: '### calculated fields' }]);
            this._attachDocumentation(item, 'extend', true, '07-Aspects-.md', [{ from: '### extend [ entity / type ]', to: '### annotate' }, { from: '### named aspects' }]);
            this._attachDocumentation(item, 'namespace', true, '10-Namespaces-.md', [{ from: '### namespace directive', to: '### contexts' }, { from: '### fully-qualified names' }]);
            this._attachDocumentation(item, 'service', true, '08-Services-.md', [{ from: '### service definitions', to: '#### auto-promoted associations' }, { from: '### actions / functions', to: '### derived services' }, { from: '### extend services' }]);
            this._attachDocumentation(item, 'structured type', true, '04-Elements-Types-.md', [{ from: '### struct elements', to: '### enums' }]);
            this._attachDocumentation(item, 'type', true, '04-Elements-Types-.md', [{ from: '### custom-defined types', to: '### struct elements' }]);
            this._attachDocumentation(item, 'using', true, '11-Imports-.md', [{ from: '### `using` directives', to: '### `import` directives' }, { from: '### model resolution' }]);
            this._attachDocumentation(item, 'view', true, '03-Entities-.md', [{ from: '### views', to: '### views with declared signatures' }, { from: '### views with parameters', to: '### abstract entities' }]);
        }
    }
    attachPossibleIdentifierDocumentation(item) {
        if (item.data && item.data.docId !== undefined) {
            const docs = this.docsForIdentifiers[item.data.docId];
            if (docs) {
                item.documentation = {
                    kind: 'markdown',
                    value: `${docs}`
                };
            }
        }
    }
    async attachDocsForDefinition(item, documentationProvider, def) {
        const docs = await documentationProvider.fetchDocumentation(def);
        if (docs.description || docs.title) {
            if (!docs.title) {
                docs.title = { foundTranslation: false, text: item.label };
            }
            this.docsForIdentifiers[this.nextFreeIdentifierDocIndex] = documentationProvider.renderDocumentation(docs);
            item.data.docId = this.nextFreeIdentifierDocIndex++;
        }
    }
    attachPossibleModuleDocumentation(item) {
        try {
            if (!item.data) {
                return;
            }
            const targetUri = item.data.targetUri;
            if (!targetUri) {
                return;
            }
            const decodedUri = decodeURIComponent(targetUri);
            const modulesFolder = '.*[/]node_modules[/]';
            const optionalScope = '(@[^/]+[/])?';
            const moduleName = '[^/]+[/]';
            const moduleRelativePath = '(.*)?';
            const uriPattern = `${modulesFolder}${optionalScope}${moduleName}${moduleRelativePath}`;
            const uriRegex = new RegExp(uriPattern);
            const match = uriRegex.exec(decodedUri);
            if (!match || !match[2]) {
                return;
            }
            const moduleUri = decodedUri.slice(0, decodedUri.length - match[2].length);
            const modulePath = utils_1.toLocalPath(moduleUri);
            const filenames = this._lspOptions.getUserSetting(utils_1.UserSetting.DOCFILES_FOR_COMPLETION, []);
            for (const filename of filenames) {
                const docfilePath = path.join(modulePath, filename);
                try {
                    if (fs.existsSync(docfilePath)) {
                        const docs = fs.readFileSync(docfilePath).toString();
                        item.documentation = {
                            kind: LSP.MarkupKind.Markdown,
                            value: docs
                        };
                        return;
                    }
                }
                catch (e) {
                    this.tracer.info(() => `Could not read file content of ${docfilePath}: `, e);
                }
            }
        }
        catch (e) {
            this.tracer.info('Could not attach documentation: ', e);
        }
    }
    getDocFolder() {
        if (this.docFolder) {
            return this.docFolder;
        }
        let folder = __dirname;
        while (folder !== '.' && !fs.existsSync(path.join(folder, 'package.json'))) {
            folder = path.dirname(folder);
        }
        return this.docFolder = path.join(folder, 'doc');
    }
    _attachDocumentation(item, labelHead, onlyIfSnippet, docPath, regions) {
        try {
            if (item.label.startsWith(labelHead) && (!onlyIfSnippet || item.kind === LSP.CompletionItemKind.Snippet)) {
                let content = this.tracer.footprint(`Reading doc content from ${docPath}`, () => fs.readFileSync(path.join(this.getDocFolder(), docPath), 'utf-8'));
                const errors = [];
                content = regions.reduce((strippedContent, region) => {
                    const contentRegion = filterContentRegion(content, region.from, region.to);
                    errors.push(...contentRegion.errors);
                    return `${strippedContent}${contentRegion.content}\n\n`;
                }, '');
                let lines = content.split(StringUtil_1.NEWLINE_REGEX);
                lines = lines.map(line => {
                    const match = line.match(/\[(.*)](\(\..*\))/);
                    if (match && match.length > 2) {
                        return line.substr(0, match.index) + match[1] + line.substr(match.index + match[0].length);
                    }
                    return line;
                });
                lines = lines.map(line => {
                    const match = line.match(/<a\s.*\/>/);
                    if (match) {
                        return line.substr(0, match.index) + line.substr(match.index + match[0].length);
                    }
                    return line;
                });
                const removeComments = (line) => line.replace(/<!--\s.*?-->/g, '');
                const removeIncludes = (line) => line.replace(/{%.*?%}/g, '');
                const removeTags = (line) => line.replace(/{:.*?}/g, '');
                const simplifySuperscript = (line) => line.replace(/<sup>(.*?)<\/sup>/g, '$1');
                const simplifyBreaks = (line) => line.replace(/<br\/?>/g, '&nbsp;');
                content = lines
                    .map(removeComments)
                    .map(removeIncludes)
                    .map(removeTags)
                    .map(simplifySuperscript)
                    .map(simplifyBreaks)
                    .join('\n')
                    .trim();
                item.documentation = {
                    kind: LSP.MarkupKind.Markdown,
                    value: content.trim()
                };
                if (errors.length) {
                    item.documentation.errors = errors;
                }
            }
        }
        catch (e) {
            this.tracer.error(e);
        }
    }
}
exports.DocumentationProposals = DocumentationProposals;
function filterContentRegion(content, contentHead = '', contentTail) {
    const errors = [];
    let fromIndex = content.indexOf(contentHead);
    if (fromIndex < 0) {
        errors.push(`Start delimiter '${contentHead}' not found`);
    }
    fromIndex = Math.max(fromIndex, 0);
    const checkTail = !!contentTail;
    contentTail = contentTail || '<<<<<<eof>>>>>>';
    const toIndex = content.indexOf(contentTail, fromIndex);
    if (checkTail && toIndex < 0) {
        errors.push(`End delimiter '${contentTail}' not found`);
    }
    return { content: content.slice(fromIndex, toIndex > 0 ? toIndex : undefined).trim(), errors };
}
//# sourceMappingURL=DocumentationProposals.js.map