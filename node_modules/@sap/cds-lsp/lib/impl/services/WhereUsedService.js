"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const LSP = require("vscode-languageserver-protocol");
const InternalAnnotationHandler_1 = require("../contributions/InternalAnnotationHandler");
const csn_api_1 = require("../csn-api");
const utils_1 = require("../utils");
const cdsenv_1 = require("../utils/cdsenv");
const trace_1 = require("../utils/trace");
const WorkspaceFolder_1 = require("./WorkspaceFolder");
class WhereUsedService {
    constructor(_options, workspaceService) {
        var _a, _b;
        this._options = _options;
        this.workspaceService = workspaceService;
        this.pathResolver = new utils_1.PathResolver();
        this.moduleLoader = new cdsenv_1.ModuleLoader();
        this.requestTracer = trace_1.currentTrace().tracer(trace_1.LspTraceComponent.REQUESTS);
        this.annotationHandlers = (_b = (_a = trace_1.currentFrame().appScope.iocFactory) === null || _a === void 0 ? void 0 : _a.newInstance(InternalAnnotationHandler_1.ANNOTATION_HANDLERS)) !== null && _b !== void 0 ? _b : [];
    }
    async fetchAllDefinitions(workspaceFolder, token, onDefinition) {
        if (token instanceof csn_api_1.IdentifierToken) {
            const localDefinitions = csn_api_1.allDefinitions(token.definitions);
            if (localDefinitions.size) {
                const indexes = await this.fetchIndexes(workspaceFolder);
                for (const localDefinition of localDefinitions) {
                    for (const foreignIndex of indexes) {
                        const defsInForeignIndex = csn_api_1.flatten(foreignIndex.correspondingDefinition(localDefinition));
                        csn_api_1.allDefinitions(defsInForeignIndex).forEach(d => {
                            onDefinition(d);
                        });
                    }
                }
            }
        }
    }
    async onDefinition(params) {
        const x = await this.fetchTranslation(params);
        if (x) {
            const [translation,] = x;
            const loc = {
                uri: translation.uri,
                range: {
                    start: { line: translation.line, character: translation.character },
                    end: { line: translation.line, character: translation.character + (translation.text ? translation.text.length : 0) }
                }
            };
            return [loc];
        }
        const uri = params.textDocument.uri;
        const position = params.position;
        const { token, workspaceFolder } = await this.fetchToken(uri, position);
        const result = [];
        if (token instanceof csn_api_1.IdentifierToken) {
            await this.fetchAllDefinitions(workspaceFolder, token, d => d instanceof csn_api_1.ExplicitDefinition && result.push(d.nameLocation));
        }
        return csn_api_1.sortAndUniqueLocations(result, l => l);
    }
    async fetchTranslation(params) {
        const uri = params.textDocument.uri;
        const workspaceFolder = this.workspaceService.getWorkspaceFolder(uri);
        const index = await workspaceFolder.fetchIndex(uri);
        const stringToken = index.stringAt(uri, params.position);
        if (stringToken && stringToken.translationId) {
            const tID = stringToken.translationId;
            const translation = workspaceFolder.translationBroker.getTranslation(tID);
            if (translation)
                return [translation, stringToken];
        }
        return undefined;
    }
    async fetchWorkspaceFolderAndIndex(uri) {
        const workspaceFolder = this.workspaceService.getWorkspaceFolder(uri);
        const index = await workspaceFolder.fetchIndex(uri);
        return [workspaceFolder, index];
    }
    async onDocumentHighlight(params) {
        const uri = params.textDocument.uri;
        const workspaceFolder = this.workspaceService.getWorkspaceFolder(uri);
        const index = await workspaceFolder.fetchIndex(uri);
        const highlights = [];
        const idToken = index.identifierAt(uri, params.position);
        if (idToken) {
            const definitions = csn_api_1.allDefinitions(idToken.definitions);
            definitions.forEach(definition => {
                if (definition instanceof csn_api_1.ExplicitDefinition) {
                    if (definition.nameLocation.uri === uri) {
                        highlights.push({
                            range: definition.nameLocation.range,
                            kind: LSP.DocumentHighlightKind.Write
                        });
                    }
                }
                highlights.push(...definition.references
                    .filter(r => r.uri === uri)
                    .map(r => ({
                    range: r.range,
                    kind: LSP.DocumentHighlightKind.Read
                })));
            });
        }
        return csn_api_1.sortAndUniqueLocations(highlights, hl => ({ uri, range: hl.range }));
    }
    async onDocumentLinks(params) {
        const uri = params.textDocument.uri;
        const [, index] = await this.fetchWorkspaceFolderAndIndex(uri);
        const stripSurroundingQuotes = (r) => ({ start: { line: r.start.line, character: r.start.character + 1 }, end: { line: r.end.line, character: r.end.character - 1 } });
        return index.forUri(uri).stringTokens.filter(t => t.isUsingPath).map(t => ({ range: stripSurroundingQuotes(t.range), data: uri }));
    }
    async onDocumentLinkResolve(params) {
        const uri = params.data;
        const [workspaceFolder, index] = await this.fetchWorkspaceFolderAndIndex(uri);
        const position = params.range.start;
        const token = index.stringAt(uri, position);
        const noTrailingSlash = (absolutePath) => absolutePath.endsWith('/')
            ? absolutePath.slice(0, -1)
            : absolutePath;
        const extensions = ['', '.cds', '.csn', '.json', path.sep + 'index.cds'];
        function* checkFileExtensions(absolutePath, workspacePaths) {
            absolutePath = noTrailingSlash(absolutePath);
            for (const extension of extensions) {
                const candidate = absolutePath + extension;
                if (workspacePaths.includes(candidate))
                    yield candidate;
            }
        }
        function* paths4(folder) {
            for (let parent = path.dirname(folder); parent !== folder; folder = parent, parent = path.dirname(parent)) {
                yield folder;
            }
        }
        function* resolveModulePath(modulePath, startPath, workspacePaths) {
            for (const folder of paths4(startPath)) {
                const existingPath = checkFileExtensions(path.resolve(folder, 'node_modules', modulePath), workspacePaths).next().value;
                if (existingPath)
                    yield existingPath;
            }
        }
        const resolveUsingPath = async (triggerUri) => {
            const workspaceDocuments = await workspaceFolder.fetchSourceFiles();
            const workspacePaths = Object.keys(workspaceDocuments).map(utils_1.toLocalPath);
            const pathOrModule = noTrailingSlash(token.text.slice(1, -1));
            const isRelative = /^[./]+\//.test(pathOrModule);
            const triggerDir = path.dirname(utils_1.toLocalPath(triggerUri));
            let resolvedPath = isRelative
                ? checkFileExtensions(path.resolve(triggerDir, pathOrModule), workspacePaths).next().value
                : resolveModulePath(pathOrModule, triggerDir, workspacePaths).next().value;
            if (resolvedPath) {
                this.requestTracer.verbose(`resolveUsingPath(${pathOrModule}, ${triggerDir}) => ${resolvedPath} (from workspace)`);
            }
            else {
                const resolveOnDisk = (candidate) => () => {
                    resolvedPath = this.pathResolver.resolveId(candidate, triggerDir);
                    if (resolvedPath && utils_1.isCdsFile(resolvedPath)) {
                        this.requestTracer.verbose(`resolveUsingPath(${candidate}, ${triggerDir}) => ${resolvedPath} (via require/path.resolve)`);
                        return true;
                    }
                    return false;
                };
                for (const extension of extensions) {
                    const candidate = pathOrModule + extension;
                    const resolved = this.requestTracer.tryCatch(resolveOnDisk(candidate), trace_1.LspTraceLevel.DEBUG, `resolveUsingPath(${candidate}, ${triggerDir})`, false);
                    if (resolved)
                        break;
                }
                if (!resolvedPath && pathOrModule.startsWith('@sap/cds/common')) {
                    resolvedPath = this.moduleLoader.resolveGlobalSapCds().resolvedPath;
                    if (resolvedPath) {
                        resolvedPath += '/common.cds';
                    }
                }
            }
            if (resolvedPath) {
                params.target = workspaceFolder.adapter.toUri(resolvedPath);
            }
            return params;
        };
        return resolveUsingPath(uri);
    }
    async onDocumentSymbol(params) {
        const uri = params.textDocument.uri;
        const [, index] = await this.fetchWorkspaceFolderAndIndex(uri);
        return index.getOwnDefinitions(uri)
            .filter(d => d.kind !== 'namespace')
            .map(csn_api_1.toSymbolInfo);
    }
    async onHover(params) {
        const hovers = [];
        {
            const { token, workspaceFolder } = await this.fetchToken(params.textDocument.uri, params.position, true);
            if (token) {
                const index = await workspaceFolder.fetchIndex(params.textDocument.uri);
                for (const annotationHandler of this.annotationHandlers) {
                    const hover = await annotationHandler.fetchHover(params, token, index);
                    if (hover) {
                        hover.range = hover.range || token.range;
                        hovers.push(hover);
                    }
                }
            }
        }
        {
            const { token, workspaceFolder } = await this.fetchToken(params.textDocument.uri, params.position);
            if (token) {
                const docs = await workspaceFolder.documentationProvider.fetchDocumentation(token);
                if (docs.title || docs.description) {
                    hovers.push({
                        contents: {
                            kind: 'markdown',
                            value: workspaceFolder.documentationProvider.renderDocumentation(docs)
                        },
                        range: token.range
                    });
                }
            }
        }
        return mergeHovers(hovers);
    }
    async fetchToken(uri, position, fetchAnnotationToken = false) {
        const workspaceFolder = this.workspaceService.getWorkspaceFolder(uri);
        const index = await workspaceFolder.fetchIndex(uri);
        const fileIndex = index.forUri(uri);
        let token;
        if (fetchAnnotationToken) {
            for (const annotationAssignment of fileIndex.annotationAssignments) {
                if (annotationAssignment.compare(position) === 0) {
                    token = annotationAssignment;
                    break;
                }
            }
        }
        else {
            token = csn_api_1.findToken(fileIndex.idTokens, position) || csn_api_1.findToken(fileIndex.i18nTokens, position) || csn_api_1.findToken(fileIndex.stringTokens, position);
        }
        return { token, workspaceFolder };
    }
    async fetchIndexes(workspaceFolder) {
        const indexes = [];
        const uris = Object.keys(await workspaceFolder.fetchSourceFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies));
        for (const uri of uris) {
            try {
                indexes.push(await workspaceFolder.fetchIndex(uri));
            }
            catch (e) {
                this.requestTracer.verbose(`Failed to calculate index for ${uri}:`, e.stack || e);
            }
        }
        return indexes;
    }
    async onReferences(params) {
        if (!params.context) {
            this.requestTracer.warn('invalid textDocument/references request: params.context not defined');
        }
        const includeDeclaration = (params.context && params.context.includeDeclaration !== undefined)
            ? params.context.includeDeclaration
            : true;
        const locations = [];
        const uri = params.textDocument.uri;
        const [workspaceFolder, index] = await this.fetchWorkspaceFolderAndIndex(uri);
        const collectLocations = async (wsf, blitzIndex) => {
            if (!blitzIndex) {
                return;
            }
            const identifierToken = blitzIndex.identifierAt(uri, params.position);
            if (identifierToken) {
                await this.fetchAllDefinitions(wsf, identifierToken, d => {
                    if (includeDeclaration && d instanceof csn_api_1.ExplicitDefinition) {
                        locations.push(d.nameLocation);
                    }
                    locations.push(...d.references.map(r => r.location));
                });
            }
            else {
                const stringToken = blitzIndex.stringAt(uri, params.position);
                if (stringToken) {
                    const indexes = await this.fetchIndexes(wsf);
                    for (const foreignIndex of indexes) {
                        const sameStringTokens = foreignIndex.correspondingStringTokens(stringToken.text);
                        const tokenToLocation = (t) => t.location;
                        locations.push(...sameStringTokens.map(tokenToLocation));
                    }
                }
            }
        };
        if (WorkspaceFolder_1.isOutsider(workspaceFolder)) {
            for (const wsf of this.workspaceService.workspaceFolders.filter(WorkspaceFolder_1.isRealWorkspaceFolder)) {
                const blitzIndex = await wsf.fetchIndex(uri);
                await collectLocations(wsf, blitzIndex);
            }
        }
        else {
            await collectLocations(workspaceFolder, index);
        }
        return csn_api_1.sortAndUniqueLocations(locations, l => l);
    }
    async onWorkspaceSymbol(params) {
        const symbols = [];
        for (const workspaceFolder of this.workspaceService.workspaceFolders) {
            const uris = Object.keys(await workspaceFolder.fetchSourceFiles(utils_1.WorkspaceValidationMode.OpenEditorsDirectSourcesAndDirectDependencies));
            for (const uri of uris) {
                try {
                    const index = await workspaceFolder.fetchIndex(uri);
                    const symbolInfos = await this._onWorkspaceSymbol(workspaceFolder, uri, index, params);
                    symbols.push(...symbolInfos);
                }
                catch (e) {
                    this.requestTracer.error(`Failed to calculate index for ${uri}:`, e.stack || e);
                }
            }
        }
        return symbols
            .sort((symbol1, symbol2) => csn_api_1.compareLocations(symbol1.location, symbol2.location))
            .filter((sym, i, all) => i === 0 || csn_api_1.compareLocations(sym.location, all[i - 1].location));
    }
    async _onWorkspaceSymbol(workspaceFolder, uri, index, params) {
        let artifacts = index.getOwnDefinitions(uri);
        const includeLibSymbols = () => {
            if (process.argv.includes('--always-include-lib-symbols')) {
                this.requestTracer.verbose('Always including symbols from libs');
                return true;
            }
            return false;
        };
        let query = params.query.trim();
        let includeLibs = false;
        let caseInsensitiveFlag;
        if (query.match('/(g|i|gi|ig)$')) {
            const options = query.slice(query.lastIndexOf('/') + 1);
            includeLibs = options.indexOf('g') >= 0;
            caseInsensitiveFlag = options.indexOf('i') >= 0 ? 'i' : undefined;
            query = query.slice(0, query.lastIndexOf('/'));
        }
        includeLibs = includeLibs || includeLibSymbols();
        const lazy = this._options.getUserSetting(utils_1.UserSetting.WORKSPACESYMBOLS_LAZY, false);
        const filters = [];
        const queryRegex = function (search) {
            let pattern = '';
            search.split('').forEach(char => {
                pattern += char;
                if (lazy) {
                    pattern += '.*';
                }
            });
            return new RegExp(pattern, caseInsensitiveFlag);
        };
        const addFilter = function (search, kind, type) {
            if (kind) {
                if (kind.startsWith(type)) {
                    filters.push(artifact => artifact.kind === kind
                        && queryRegex(search).test(csn_api_1.shortName(artifact)));
                }
            }
            else {
                filters.push(artifact => queryRegex(search).test(csn_api_1.shortName(artifact)));
            }
        };
        const queries = query.split(' ');
        queries.forEach((quer) => {
            const [type, value] = quer.split(/[:=]/);
            if (value === undefined) {
                addFilter(type);
            }
            else {
                addFilter(value, 'entity', type);
                addFilter(value, 'type', type);
                addFilter(value, 'element', type);
                addFilter(value, 'context', type);
                addFilter(value, 'namespace', type);
                addFilter(value, 'service', type);
                addFilter(value, 'annotate', type);
                addFilter(value, 'view', type);
            }
        });
        if (!includeLibs) {
            artifacts = artifacts.filter(artifact => artifact.nameLocation.uri.indexOf('node_modules') < 0);
        }
        if (filters.length > 0) {
            artifacts = artifacts.filter(artifact => undefined !== filters.find(filter => filter(artifact)));
        }
        return artifacts.map(csn_api_1.toSymbolInfo);
    }
}
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderTextPos,
        resultRenderer: utils_1.renderLocations,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onDefinition", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderTextPos,
        resultRenderer: utils_1.renderDocHighlights,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onDocumentHighlight", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocumentLinkParams,
        resultRenderer: utils_1.renderDocumentLinks,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onDocumentLinks", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocumentLink,
        resultRenderer: utils_1.renderDocumentLink,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onDocumentLinkResolve", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderDocSymbol,
        resultRenderer: utils_1.renderSymbolInfos,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onDocumentSymbol", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderTextPos,
        resultRenderer: utils_1.renderHov,
        onErrorReturn: undefined
    })
], WhereUsedService.prototype, "onHover", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderRef,
        resultRenderer: utils_1.renderLocations,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onReferences", null);
__decorate([
    trace_1.RequestMethod({
        paramsRenderer: utils_1.renderWsSymbol,
        resultRenderer: utils_1.renderSymbolInfos_Uri,
        onErrorReturn: []
    })
], WhereUsedService.prototype, "onWorkspaceSymbol", null);
exports.WhereUsedService = WhereUsedService;
function mergeHovers(hovers) {
    if (!hovers || !hovers.length)
        return undefined;
    const mergedHover = hovers[0];
    for (let i = 1; i < hovers.length; i++) {
        const hover = hovers[i];
        mergedHover.contents.value += `\n---\n${hover.contents.value}`;
        if (csn_api_1.comparePosition(hover.range.start, mergedHover.range.start) < 0) {
            mergedHover.range.start = hover.range.start;
        }
        if (csn_api_1.comparePosition(mergedHover.range.end, hover.range.end) < 0) {
            mergedHover.range.end = hover.range.end;
        }
    }
    return mergedHover;
}
exports.mergeHovers = mergeHovers;
//# sourceMappingURL=WhereUsedService.js.map